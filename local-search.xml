<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AI 学习计划</title>
    <link href="/2025-06-26-ai-study-plane/"/>
    <url>/2025-06-26-ai-study-plane/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>📆 针对我的时间，让 Gemini 安排了一份 AI 学习规划</p><p>我的情况比较典型：<strong>通勤时间长、白天可以学习、晚上容易累</strong>。我可以利用碎片时间+午休+白天工作间隙，晚上减少压力。</p><span id="more"></span><hr><h2 id="🕒-时间分配建议"><a href="#🕒-时间分配建议" class="headerlink" title="🕒 时间分配建议"></a><strong>🕒 时间分配建议</strong></h2><table><thead><tr><th>时间段</th><th>学习内容</th><th>备注</th></tr></thead><tbody><tr><td><strong>🚇 通勤时间（50 min × 2）</strong></td><td>看视频课程&#x2F;听播客</td><td>适合听讲解，不要求敲代码</td></tr><tr><td><strong>💻 工作间隙（1-2h）</strong></td><td>敲代码&#x2F;阅读文档</td><td>工作不忙，可利用部分时间实践</td></tr><tr><td><strong>🍱 午休时间（30-60 min）</strong></td><td>敲代码&#x2F;做笔记</td><td>若公司环境允许，可做轻量学习</td></tr><tr><td><strong>🏠 晚上（20:00 - 21:00）</strong></td><td>复习&#x2F;小练习</td><td>不求难度，保持学习节奏</td></tr><tr><td><strong>🛌 睡前（15 min）</strong></td><td>思考今天学的内容</td><td>利用“睡眠学习效应”加深记忆</td></tr></tbody></table><hr><h2 id="📌-具体学习方案"><a href="#📌-具体学习方案" class="headerlink" title="📌 具体学习方案"></a><strong>📌 具体学习方案</strong></h2><h3 id="🚇-通勤时间（听视频课程，轻量学习）"><a href="#🚇-通勤时间（听视频课程，轻量学习）" class="headerlink" title="🚇 通勤时间（听视频课程，轻量学习）"></a><strong>🚇 通勤时间（听视频课程，轻量学习）</strong></h3><blockquote><p><strong>目标</strong>：理解核心概念，不要求做笔记</p></blockquote><ul><li><p><strong>第 1 个月</strong>（机器学习入门）：<br>  🎥 <a href="https://www.coursera.org/learn/machine-learning">吴恩达 Machine Learning</a>（听完前 5 章）<br>  🎥 3Blue1Brown 线性代数讲解</p></li><li><p><strong>第 2 个月</strong>（神经网络基础）：<br>  🎥 <a href="https://www.coursera.org/specializations/deep-learning">吴恩达 Deep Learning Specialization</a>（前 3 章）<br>  🎥 3Blue1Brown 神经网络动画</p></li><li><p><strong>第 3-4 个月</strong>（深度学习进阶）：<br>  🎥 Stanford CS231n 计算机视觉<br>  🎥 Transformer 讲解</p></li></ul><hr><h3 id="💻-工作时间（写代码，实践为主）"><a href="#💻-工作时间（写代码，实践为主）" class="headerlink" title="💻 工作时间（写代码，实践为主）"></a><strong>💻 工作时间（写代码，实践为主）</strong></h3><blockquote><p><strong>目标</strong>：<strong>白天练代码，避免晚上熬夜</strong><br><strong>策略</strong>：在 IDE &#x2F; Jupyter Notebook 里写小项目，测试代码</p></blockquote><h4 id="第-1-个月：熟悉-Python-和-NumPy"><a href="#第-1-个月：熟悉-Python-和-NumPy" class="headerlink" title="第 1 个月：熟悉 Python 和 NumPy"></a><strong>第 1 个月：熟悉 Python 和 NumPy</strong></h4><p>📌 每天 30 分钟，写一两个小脚本，练习 NumPy、Pandas 数据处理<br>📌 实战项目：鸢尾花分类（scikit-learn）</p><h4 id="第-2-个月：训练神经网络"><a href="#第-2-个月：训练神经网络" class="headerlink" title="第 2 个月：训练神经网络"></a><strong>第 2 个月：训练神经网络</strong></h4><p>📌 用 PyTorch 训练 MNIST<br>📌 研究神经网络架构（MLP）</p><h4 id="第-3-个月：CNN"><a href="#第-3-个月：CNN" class="headerlink" title="第 3 个月：CNN"></a><strong>第 3 个月：CNN</strong></h4><p>📌 训练 CIFAR-10<br>📌 研究卷积神经网络（ResNet）</p><h4 id="第-4-个月：NLP"><a href="#第-4-个月：NLP" class="headerlink" title="第 4 个月：NLP"></a><strong>第 4 个月：NLP</strong></h4><p>📌 用 Transformer 进行文本分类<br>📌 研究 Hugging Face 库</p><hr><h3 id="🍱-午休（30-60-min，代码-思考）"><a href="#🍱-午休（30-60-min，代码-思考）" class="headerlink" title="🍱 午休（30-60 min，代码+思考）"></a><strong>🍱 午休（30-60 min，代码+思考）</strong></h3><ul><li><p><strong>前半小时</strong>（写代码）</p><ul><li>训练模型（跑 PyTorch &#x2F; TensorFlow 代码）</li><li>调试超参数，观察结果</li></ul></li><li><p><strong>后半小时</strong>（思考 + 笔记）</p><ul><li>复盘今天学习的内容</li><li>记录心得</li></ul></li></ul><hr><h3 id="🏠-晚上（20-00-21-00，轻松学习）"><a href="#🏠-晚上（20-00-21-00，轻松学习）" class="headerlink" title="🏠 晚上（20:00 - 21:00，轻松学习）"></a><strong>🏠 晚上（20:00 - 21:00，轻松学习）</strong></h3><blockquote><p><strong>策略</strong>：减少压力，不强迫高强度学习</p></blockquote><p>✅ 复习白天的代码<br>✅ 看 B 站 &#x2F; YouTube 讲解<br>✅ 参与讨论（知乎、Kaggle 论坛）<br>✅ 研究 AI 框架（Hugging Face、PyTorch Lightning）</p><hr><h3 id="🛌-睡前（回顾-沉淀）"><a href="#🛌-睡前（回顾-沉淀）" class="headerlink" title="🛌 睡前（回顾+沉淀）"></a><strong>🛌 睡前（回顾+沉淀）</strong></h3><ul><li><strong>听 AI 相关播客</strong>（比如《Data Skeptic》）</li><li><strong>用手机翻笔记</strong>，回顾今天学的内容</li><li><strong>设定明天的小目标</strong>，确保进度持续推进</li></ul><hr><h2 id="💡-额外建议"><a href="#💡-额外建议" class="headerlink" title="💡 额外建议"></a><strong>💡 额外建议</strong></h2><p>✅ <strong>避免晚上硬撑学习</strong>，把核心学习放到白天，晚上的学习内容尽量轻松<br>✅ <strong>避免学太多数学推导</strong>，直接用可视化工具（如 TensorFlow Playground）<br>✅ <strong>尝试找一个 Kaggle 小项目</strong>，实战效果更好<br>✅ <strong>利用周末</strong> 做整块时间的项目（比如 3-4 小时训练一个模型）</p><hr><h3 id="🔥-总结"><a href="#🔥-总结" class="headerlink" title="🔥 总结"></a><strong>🔥 总结</strong></h3><p>📆 <strong>最佳时间安排</strong></p><ul><li><p><strong>通勤听讲解</strong> 🎧（不需要写代码）</p></li><li><p><strong>工作间隙写代码</strong> 💻（敲代码为主）</p></li><li><p><strong>午休练习 + 复盘</strong> ✏️（整理思路）</p></li><li><p><strong>晚上轻松学习</strong> 📖（不搞高强度）</p></li><li><p><strong>睡前复习</strong> 💤（沉淀知识）</p></li></ul><p>这样安排，这样既能高效学习，又不会太累，能够坚持 4 个月完成 AI 之旅！ 🚀</p><p>（正文完）</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不懂装修 - 但爱思考</title>
    <link href="/2024-07-02-life-thinking/"/>
    <url>/2024-07-02-life-thinking/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对了，今年6月15号，我家开始装修了。</p><span id="more"></span><p>上周日水电验收，整体还可以。今天早上反复观察水电 VR 存档图，察觉零冷水的循环貌似有问题。最开始以为循环的路线如下，那么热水会混入冷水中，顿感不妙，因为施工很快要进入回填阶段了，水电可不能出问题。</p><p><img src="https://blogres.blackist.org/202407021816531719915414.jpg"></p><p>然后联系工长，问了这个事情，他解释一番后，我还是不放心。他让我自己想想清楚。我纠结了好大会儿，突然想通了，被那根软管给误导了。循环水路应该如下：</p><p><img src="https://blogres.blackist.org/202407021816531719915416.jpg"></p><p>恍然大悟后，心情也放松了许多，差点连早饭都吃不下去。可能是因为第一次装修，太在意一些细节了。</p><p>从刚开始陷入这个疑惑，到想通它，挺让人郁闷的。很多时候，就是差个“一点通”，整个脑回路就顺畅了。重要的是调整好心态，保持好心情。</p><p>（正文完）</p>]]></content>
    
    
    <categories>
      
      <category>生活场景</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人思考</tag>
      
      <tag>装修</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC 解决什么问题</title>
    <link href="/2023-11-21-talk-about-rpc/"/>
    <url>/2023-11-21-talk-about-rpc/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>远程服务调用（Remote Procedure Call, RPC）是分布式系统架构的基础，但作为一项拥有四十年历史的计算机技术，它仍备受关注、持续更迭，不可谓不是一个奇观。</p><p>RPC 在解决什么问题、如何解决这些问题？本文先讨论 RPC 解决什么问题。</p><span id="more"></span><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>分布式系统在当下应用很广泛，但它的起源并非是解决高并发问题。在原始分布式时代，计算机的单机计算能力有限，为了完成一个复杂计算，计算机科学家提出了分布式系统，使多台单机共同执行计算。</p><p>由此，也产生了计算机之间的远程方法调用问题，RPC 的提出正是为了让计算机能够<strong>跟调用本地方法一样</strong>去调用远程方法。</p><p>首先，看一下<strong>本地方法调用</strong>的几个步骤：</p><ol><li>传递方法参数</li><li>确定方法版本</li><li>执行被调方法</li><li>返回执行结果</li></ol><p>若远程方法调用与之相似，面临两个主要问题：</p><ul><li>第 1、4 两步传递参数、传回结果都依赖于栈内存，而计算机之间的不同进程无法拥有相同的栈内存；</li><li>第 2 步的方法版本选择，依赖编程语言的规则定义，若两端语言不一致，那么方法版本选择就是不可知的行为。</li></ul><p>讨论下第一个问题，两个进程之间如何交换数据？这是便是计算机科学中的<strong>进程间通信</strong>（Inter-Process Communication, IPC）。</p><ul><li>消息队列（Message Queue）用于进程间数据量较多的通信：进程可以向队列添加消息，被赋予读权限的进程则可以从队列消费消息；</li><li>共享内存（Shared Memory）：允许多个进程访问同一块公共的内存空间，这是效率最高的进程间通信形式。</li></ul><p>消息队列和共享内存只适合单机多进程间的通信，<strong>套接字接口</strong>（Socket）是更为普适的进程间通信机制，可用于不同机器之间的进程通信。</p><h2 id="忽略通信成本的八宗罪"><a href="#忽略通信成本的八宗罪" class="headerlink" title="忽略通信成本的八宗罪"></a>忽略通信成本的八宗罪</h2><p>由于 Socket 是网络栈的统一接口，它也理所当然地能支持<strong>基于网络的跨机器的进程间通信</strong>。</p><p>因此，早期分布式系统的 RPC 就是奔着<strong>透明调用</strong>的方向去做的（作为 IPC 的一种形式），把远程方法调用的通信细节<strong>隐藏在操作系统底层</strong>，从应用层面上看来可以做到远程调用与本地的进程间通信在编码上完全一致这。</p><p>但是，这种透明的调用形式却反而造成了程序员误以为 Socket 编程的<strong>通信是无成本</strong>的假象，因而被滥用以致于显著降低了分布式系统的性能；而且，这也增加了程序员工作的复杂度。</p><p>后来，几位计算机科学家共同总结了<strong>通过网络进行分布式运算</strong>的八宗罪 （8 Fallacies of Distributed Computing）：</p><ol><li>The network is reliable —— 网络是可靠的。</li><li>Latency is zero —— 延迟是不存在的。</li><li>Bandwidth is infinite —— 带宽是无限的。</li><li>The network is secure —— 网络是安全的。</li><li>Topology doesn’t change —— 拓扑结构是一成不变的。</li><li>There is one administrator —— 总会有一个管理员。</li><li>Transport cost is zero —— 不必考虑传输成本。</li><li>The network is homogeneous —— 网络是同质化的。</li></ol><p>如果 RPC 以透明的方式实现，则程序员很容易酿成以上的罪过，并为之买单。</p><p>至此，也确定了一种基本的观点：RPC 应该是一种高层次的或者说语言层次的特征，而不是像 IPC 那样，是低层次的或者说操作系统层次的特征。</p><h2 id="RPC-的三个基本问题"><a href="#RPC-的三个基本问题" class="headerlink" title="RPC 的三个基本问题"></a>RPC 的三个基本问题</h2><p>一般仍认为 RPC 概念的定义最早是由施乐公司首次提出的，也是完全符合以上结论的：</p><blockquote><p>Remote procedure call is the synchronous language-level transfer of control between programs in disjoint address spaces whose primary communication medium is a narrow channel.<br>远程服务调用是指位于互不重合的内存地址空间中的两个程序，在语言层面上，以同步的 方式使用带宽有限的信道来传输程序控制信息。<br>—— Bruce Jay Nelson，Remote Procedure Call ，Xerox PARC，1981</p></blockquote><p><img src="https://blogres.blackist.org/rpc-concept.png" alt="RPC 概念"></p><p>几十年来，流行过的、当下流行的 RPC 协议不外乎地在解决三个基本问题：</p><ul><li>如何表示数据</li><li>如何传递数据</li><li>如何表示方法</li></ul><h3 id="如何表示数据"><a href="#如何表示数据" class="headerlink" title="如何表示数据"></a>如何表示数据</h3><p>数据包括了传递给方法的参数，以及方法执行后的返回值。无论是将参数传递给另外一个进程，还是从另外一个进程中取回执行结果，都涉及到它们应该如何表示。</p><p>RPC 交互双方可能各自使用不同的程序语言，或者同样的数据类型在不同硬件指令集、不同操作系统下，也可能存在数据宽度、字节序等等的差异。</p><p>有效的做法是将交互双方所涉及的数据转换为某种事先<strong>约定好的中立数据流格式</strong>来进行传输，将数据流转换回不同语言中对应的数据类型来进行使用，这就是<strong>序列化与反序列化</strong>。</p><p>每种 RPC 协议都应该要有对应的序列化协议：</p><ul><li>Java RMI 的 <strong>Java Object Serialization Stream Protocol</strong>.</li><li>gRPC 的 <strong>Protocol Buffers</strong>.</li><li>Web Service 的 <strong>XML Serialization</strong>.</li><li>众多轻量级 RPC 支持的 <strong>JSON Serialization</strong>.</li></ul><h3 id="如何传递数据"><a href="#如何传递数据" class="headerlink" title="如何传递数据"></a>如何传递数据</h3><p>指如何通过网络，在两个服务的 Endpoint 之间相互<strong>操作</strong>、<strong>交换</strong>数据。</p><p>“交换数据”通常指的是应用层协议，实际传输一般是基于标准的 TCP、UDP 等标准的传输层协议来完成的。RPC 双方信息交换的需求除了序列化的数据，还包括异常、超时、安全、认证、授权、事务等。</p><p>“Wire Protocol” 来用于表示两个 Endpoint 之间交换这类数据的行为，常见的协议：</p><ul><li>Java RMI 的 Java Remote Message Protocol（JRMP）</li><li>Web Service 的 Simple Object Access Protocol（SOAP）</li><li>若要求足够简单，双方都是 HTTP Endpoint，直接使用 HTTP 协议即可（如 JSON-RPC）</li></ul><h3 id="如何表示方法"><a href="#如何表示方法" class="headerlink" title="如何表示方法"></a>如何表示方法</h3><p>语言无关的接口描述语言 （Interface Description Language，IDL），是许多 RPC 参考或依赖的基础。</p><ul><li>Android 的Android Interface Definition Language （AIDL）</li><li>Web Service 的Web Service Description Language （WSDL） </li><li>JSON-RPC 的JSON Web Service Protocol （JSON-WSP）</li></ul><p>尽管 RPC 早已不再追求实现成与本地方法调用完全一致，但其设计思路仍然带有本地方法调用的深刻烙印，抓住两者间的联系来类比，对我们更深刻地理解 RPC 的本质会很有好处。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志明，《凤凰架构》</li></ul><p>（正文完）</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>价值与销售</title>
    <link href="/2023-11-21-product-and-business/"/>
    <url>/2023-11-21-product-and-business/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>读到两句关于创造与商业的话：<br>1.世界上最值得肯定的行为是，你创造了一些东西，然后你销售它们。<br>2.世界上第二值得肯定的行为是，别人创造出你一直想要的东西，然后别人销售它们。</p><span id="more"></span><p>——来自 <a href="https://news.ycombinator.com/item?id=31354675">HackerNews</a></p><p>创业这件事情，其核心无外乎创造价值。价值是相对于人来说的，即有需要的人。让有需要的人得到你创造的东西，这就创造出了最大的价值。</p><p>对于一般生产者而言，往往可以通过工作创造出成果、产品或服务，但并不通晓市场、营销类的知识。产品、服务不被知晓、售卖，边没有发挥出它的价值，对于有需要的人、生产者来说都是如此。</p><p>以前遇到公司的销售同事，总觉得他们是在搞虚头巴脑的东西、不误事，对于用户是纯纯的大忽悠，颇有轻视之的心态。试想，没有他们在市场上的营销，给公司带来现金流，恐怕作为程序员的我们连薪资都拿不到，更别提加薪了。</p><p>况且，销售人员本身也是有自己的销售技巧与市场资源，这也是其自身的能力与价值的体现。</p><p>联想到现在电动汽车行业的竞争，各种品牌如雨后春笋般进入市场。这得益于国内生产力、供应链的完备，车企具备一定的资金和设计能力，便可找到厂商代工生产。因此，在产品差距不大的情况下，各品牌的营销能力显得很重要。足够多的宣传、出奇营销，带来足够的订单，保证一定的现金流，那么这个品牌就能做下去。</p><p>现在的开发工具、中间件免费Saas平台都挺完善，只要开发者有一定的产品想法，实现这个产品不是极其困难的事情。作出 MVP 产品后，在市场上被知晓、被安装，得到反馈，便是事业的开始。稳定版本、完善版本则是收费的开始、持续产生价值的开始。</p><p>（正文完）</p>]]></content>
    
    
    <categories>
      
      <category>运营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运营</tag>
      
      <tag>商业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标点符号及数学符号的中英文表达</title>
    <link href="/2022-12-13-punctuation-en/"/>
    <url>/2022-12-13-punctuation-en/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>收录一些符号及其英语表达，变量、常量命名时以做参考。在工程中提取常用的符号作为常量，严格的命名使得程序看着更规范。</p><span id="more"></span><h2 id="1-标点符号（Punctuation）"><a href="#1-标点符号（Punctuation）" class="headerlink" title="1.标点符号（Punctuation）"></a>1.标点符号（Punctuation）</h2><p>． period or full stop 句号<br>， comma 逗号<br>： colon 冒号<br>； semicolon 分号<br>！ exclamation mark 惊叹号<br>？ question mark 问号<br>- hyphen 连字符<br>* asterisk 星号<br>‘ apostrophe 所有格符号，单词内部的省略<br>— dash 破折号<br>_ underscore<br>‘ ’ single quotation marks 单引号<br>“ ” double quotation marks 双引号<br>( ) parenthesis or round brackets 圆括号<br>[ ] square brackets 方括号<br>&lt;&gt; Angle brackets 尖括号<br>{} curly brackets or braces 大括号<br>《 》French quotes 法文引号；书名号<br>… ellipsis 省略号<br>¨ tandem colon 双点号<br>“ ditto 同上<br>‖ parallel 双线号<br>／ slash or virgule or diagonal mark 斜线号<br>＆ ampersand &#x3D; and<br>～ tilde or swung dash 代字号<br>§ section; division 分节号<br>→ arrow 箭号；参见号<br>| vertical bar 竖线<br>\ backslash 反斜线</p><h2 id="2-数学符号（Mathematical-Codes）"><a href="#2-数学符号（Mathematical-Codes）" class="headerlink" title="2.数学符号（Mathematical Codes）"></a>2.数学符号（Mathematical Codes）</h2><p>＋ plus 加号；正号<br>－ minus 减号；负号<br>± plus or minus 正负号<br>× is multiplied by 乘号<br>÷ is divided by 除号<br>＝ is equal to 等于号<br>≠ is not equal to 不等于号<br>≡ is equivalent to 全等于号<br>≌ is equal to or approximately equal to 等于或约等于号<br>≈ is approximately equal to 约等于号<br>＜ less than sign 小于号<br>＞ more than or greater than sign大于号<br>≤ is less than or equal to 小于或等于号<br>≥ is more than or equal to 大于或等于号<br>％ per cent 百分之…<br>‰ per mill 千分之…<br>∞ infinity 无限大号<br>∝ varies as 与…成比例<br>√ (square) root 平方根<br>∵ since; because 因为<br>∴ hence 所以<br>∷ equals, as (proportion) 等于，成比例<br>∠ angle 角<br>⌒ semicircle 半圆<br>⊙ circle 圆<br>○ circumference 圆周<br>△ triangle 三角形<br>⊥ perpendicular to 垂直于<br>∪ union of 并，合集<br>∩ intersection of 交，通集<br>∫ the integral of …的积分<br>∑ (sigma) summation of 总和<br>° degree 度<br>′ minute 分<br>″ second 秒<br>＃ number …号<br>℃ Celsius system 摄氏度</p><p>（正文完）</p>]]></content>
    
    
    <categories>
      
      <category>公共领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>规范</tag>
      
      <tag>英文</tag>
      
      <tag>标点符号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>置身事内</title>
    <link href="/2022-12-06-reading/"/>
    <url>/2022-12-06-reading/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>读兰小欢的《置身事内》。</p><span id="more"></span><ul><li>一如书中所说，主流经济学研究，偏向于放之四海而皆准的理论，但成熟完备的市场机制是经济发展的结果而非前提。因此，经济发展过程中的具体问题与解决方法才是更有趣的地方。<ul><li>例如，在中国经济发展、城市化的过程中，乡镇企的最初来源于建国之初应对潜在军事冲突的分散工业，这些分散的工业区域培养了当地人的知识和能力，包括对外界的认知。这个阶段的农民离土不离乡，但也为后续分税制改革后，人口向城市聚集奠定了基础。既有作为工人的知识能力，也有对外界的认识和向往，从而完成农民到工人、工人到市民的转变，这也是工业生产技术和基础设施建设的更深层次的问题所在。</li><li>很喜欢看王凯主演的《大江大河》，其中小雷家的铜厂、电缆厂便是典型的乡镇企业。</li><li>在这个问题上，中国可行的政策空间和演变路径，主要受制于三大制度因素：农村集体所有制、城市土地公有制、户籍制度。所以工业化离不开乡镇企业、城市化离不开土地财政和土地金融。</li></ul></li><li>也能一览地方政府的钱与权的划分，尤其在工业化中扮演的角色——深度参与。<ul><li>包括分税制改革中，朱镕基带队去各省游说，推动税收向中央政府集中，从而使得中央政府更有更强的财政能力。</li><li>在一系列改革措施后，历史也给了中国机会，2001年入世，中国进入市场经济时代，经济发展腾飞。</li><li>地方政府进入“县域竞争”模式——经济发展目标与升迁（激励相容），发挥主观能动性，通过招商引资、土地财政等模式发展地方经济。<ul><li>合肥政府引入京东方，帮助建立显示屏6代生产线</li><li>各地竞相发展光伏产业</li></ul></li><li>包括地方政府设立城头公司，撬动更大的资金建立工业园区。苏州工业园区便是一个成功代表。</li></ul></li><li>相信很多人认同书中的一段话<ul><li>“经济发展必然要改变旧有的生活方式，重新分配利益，所以必然伴随着矛盾和冲突。政府的关键作用之一，就是调控改变速度的快慢。社会变化过程快慢之间，对身处其中的人而言，感受天差地别。对于环境的变化，人们需要时间去适应。人不是机器部件，不可能瞬间调整，也没有人能一直紧跟时代，所以稳定的改革过程要留下足够的时间和资源去缓冲。这种“渐进性改革”中的各种缓冲机制，往往会拖低效率，所以常常被解读为“扭曲”和“资源错配”。但任何成功的转型过程都离不开缓冲机制。”</li><li>书中推荐了周浩导演的纪录片《中国市长》，描述的是山西大同市市长耿彦波进行城市改造的过程。为将大同打造成历史文化名城，翻两番，拆迁了十多万户，牵涉50万左右的居民，“历史不会给大同第二次机会”。<ul><li>影片中反映了不少这个大规模改造影响到了个人利益的画面，身处其中的人感受我们很难感同身受。</li><li>耿彦波对做官已经没有概念了，想的只是做事。当贪官污吏横行，耿彦波这样的实干派变得格外耀眼。</li></ul></li></ul></li><li>近期在看于杰的节目《时运变迁 Changing Fortunes》，了解了一些中国经济增长的底层逻辑——入世和美元。<ul><li>与《置身事内》中的一些观点不谋而合，包括过剩产能出口等带来的贸易冲突，已经因此带来的潜在危机——产业转移、美元流出等，着实大开眼界。</li><li>《时运变迁》也是一本书，于杰翻译自 <em>Changing Fortunes</em>, 打算买来看看。</li></ul></li><li>用 Books 看完了《置身事内》，然后买了本纸质的，方便以后翻阅</li></ul><p>（正文完）</p>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git - IDEA 修改暂存不提交</title>
    <link href="/2022-07-12-git-idea-changes-not-to-commit/"/>
    <url>/2022-07-12-git-idea-changes-not-to-commit/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拥有企业级的 IntelliJ IDEA 密钥是值得开心的事情。假设你和我一样使用 IDEA 开发 java 项目，并有这样的一个需求：修改或新建一个文件，只在本机用于测试或其他目的，无需使用 Git 提交并推送远程仓库。</p><span id="more"></span><p>IDEA 有一个功能可以满足以上需求：Git Changelist.</p><p>假设修改了两个文件：</p><ul><li>MainTest: 业务代码，修改需要被提交并推送到远程仓库</li><li>TempTest: 本地测试代码，无需提交</li></ul><p>IDEA 的 Commit 窗口显示如下：<br><img src="https://blogres.blackist.org/20220713-default-changes.png"></p><p>接下来，新建一个 Changelist. 在 Changes 上打开菜单选项，选择 New Changelist, 如下：</p><p><img src="https://blogres.blackist.org/20220713-create-list-1.png"></p><p>输入新列表名称，比如 To Revert:</p><p><img src="https://blogres.blackist.org/20220713-create-list-2.png"></p><p>将无需提交的文件拖动至新建的变更列表 To Revert: </p><p><img src="https://blogres.blackist.org/20220713-use-list-1.png"></p><p>此时，需要提交的变更默认进入 Changes 这个变更列表，无需提交的变更可被拖动至 To Revert 变更列表：</p><p><img src="https://blogres.blackist.org/20220713-two-list.png"></p><p>接下来，照常选择 Changes 下的所有变更，提交并推送远程仓库：</p><p><img src="https://blogres.blackist.org/20220713-use-list-3.png"></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>git</tag>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生活乐趣——猜猜乐</title>
    <link href="/2021-06-12-life-playing-in-work/"/>
    <url>/2021-06-12-life-playing-in-work/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>目前我们团队内开周会有个生活话题环节，选定一个话题后，大家各自畅谈经历和想法。我挺喜欢这个环节，大家可以放松下心情。</p><span id="more"></span><p>当然，生活话题只是个方案级需求，放松身心、增进成员间的了解、增强凝聚力才是问题级需求。因此，这个环节可以不限于生活话题，今天我就选择猜猜乐的形式让大家放松下。</p><p>请听题：</p><h4 id="1-什么水果容易忘记回家的路？"><a href="#1-什么水果容易忘记回家的路？" class="headerlink" title="1.什么水果容易忘记回家的路？"></a>1.什么水果容易忘记回家的路？</h4><p>我们开周会时会订一些水果，大家边吃边聊，也算是一种福利了，所以第一题就以水果开始。聪明的你猜猜看。</p><h4 id="2-一颗石榴，它发疯了，会变成什么？"><a href="#2-一颗石榴，它发疯了，会变成什么？" class="headerlink" title="2.一颗石榴，它发疯了，会变成什么？"></a>2.一颗石榴，它发疯了，会变成什么？</h4><p>这些谜题大多是谐音梗，看看你的词库够不够丰富啦。</p><h4 id="3-哪三个动物-撞墙，再撞墙，还撞墙？"><a href="#3-哪三个动物-撞墙，再撞墙，还撞墙？" class="headerlink" title="3.哪三个动物 撞墙，再撞墙，还撞墙？"></a>3.哪三个动物 撞墙，再撞墙，还撞墙？</h4><p>强壮的它们相信大力出奇迹，所以撞了南墙也不回头，但有时。。。真的会废的！</p><h4 id="4-什么东西天天都尝，从来不吃？"><a href="#4-什么东西天天都尝，从来不吃？" class="headerlink" title="4.什么东西天天都尝，从来不吃？"></a>4.什么东西天天都尝，从来不吃？</h4><p>这个考验的是智商，不是谐音梗啊，加油⛽️</p><h4 id="5-阴气最重的两个地方是什么？"><a href="#5-阴气最重的两个地方是什么？" class="headerlink" title="5.阴气最重的两个地方是什么？"></a>5.阴气最重的两个地方是什么？</h4><p>唤醒你童年的记忆，去西游记里寻找答案吧。</p><h4 id="6-从前有个人姓铁，为什么一直不长头发？"><a href="#6-从前有个人姓铁，为什么一直不长头发？" class="headerlink" title="6.从前有个人姓铁，为什么一直不长头发？"></a>6.从前有个人姓铁，为什么一直不长头发？</h4><p>一句红遍大江南北的口头禅，相信你可以的。</p><p>我一直认为，人生最宝贵的就是昨日的开心，因为即使你明天再怎么富贵，也买不到昨天的一个开怀大笑。</p><p>生活中不如意十之八九，能不时让自己爽朗地笑一笑，生活会好起来的。</p><p>前段时间我和老婆两个人经历了生活中的一阵低谷，但我们戮力同心，也相信困难肯定会过去的。那么在这个过程中怎么保持一个好的心态很重要，因为我一直都想昨天的自己是开心的。首先两个人会一起努力，互相安慰；情绪低落是会有的，但不能任由负面情绪蔓延，我听了一些德云社相声和网易轻松一刻调节情绪。</p><h4 id="谜底"><a href="#谜底" class="headerlink" title="谜底"></a>谜底</h4><p>1.榴莲忘返</p><p>2.疯榴成杏</p><p>3.猩猩 大猩猩 狒狒</p><p>4.牙膏不好吃</p><p>5.嘿，钢琴住了几个妖，油箱住了几个魔</p><p>6.老铁，没毛病！</p><p>记住啊，让昨天的自己开心些。</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>乐趣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 查询优化 - Explain</title>
    <link href="/2020-10-11-mysql-optimize-basic/"/>
    <url>/2020-10-11-mysql-optimize-basic/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用 <code>EXPLAIN</code> 分析查询语句，解析每一项的含义，并给出优化建议。</p><p>MySQL 版本：10.5.5-MariaDB MariaDB Server。</p><span id="more"></span><h2 id="一、EXPLAIN"><a href="#一、EXPLAIN" class="headerlink" title="一、EXPLAIN"></a>一、EXPLAIN</h2><p>查看某一查询语句的执行计划：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">MariaDB [ar]&gt; EXPLAIN SELECT * FROM `user` WHERE true_name like <span class="hljs-string">&#x27;董%&#x27;</span>;  <br></code></pre></td></tr></table></figure><p>得到如下执行结果：</p><img src="https://blogres.blackist.org/20201011163022.jpg" style="zoom:50%;" /><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>含有子查询的时候，表明各语句执行的先后顺序，如果数字相同，则按照先后顺序执行，如果为 null，则代表是结果集，不需要查询。</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>分为 simple（简单查询）、subquery（子查询）、drived（衍生表，from 列表中有子查询）、union（联合查询）等。</p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>通常是表名，或者表的别名，或者一个为查询产生临时表的标示符（如派生表、子查询、集合）。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>扫描类型（<strong>性能</strong>从高到低）：</p><ul><li><p>null：MySQL在优化过程中分解语句，不需要访问索引或表就可以得到结果。</p></li><li><p>system：表中只有一行数据或者该表为空表，这个方式通常出现在 myisam 和 memory 的引擎中，innodb 一般会展示为 all 或 index。</p></li><li><p><strong>const</strong>：使用唯一索引或者主键，返回记录一定是 1 行记录的<strong>等值 where 条</strong>件时。</p><blockquote><p> const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p></blockquote></li><li><p>eq_ref：出现在要连接几个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为 not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现 eq_ref。唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</p></li><li><p><strong>ref</strong>：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现。常见于辅助索引的等值查找；多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</p></li><li><p>ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</p></li><li><p><strong>range</strong>：以范围的形式扫描数据，对索引的扫描开始于某一点，返回匹配值域的行，常见于使用 <code>&gt;</code>, <code>&lt;</code>, <code>is null</code>, <code>between</code>, <code>in</code>, <code>like</code> 等运算符的查询中。</p></li><li><p>index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所有索引，性能可能大部分时间都不如range</p></li><li><p><strong>index</strong>：索引全表扫描（Full Index Scan），把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取<strong>数据文件</strong>的查询、可以使用索引排序或者分组的查询。index 与 ALL 区别为 index 类型只遍历索引树。</p></li><li><p><strong>all</strong>：这个就是全表扫描<strong>数据文件</strong>（Full Table Scan），然后再在 server 层进行过滤返回符合要求的记录。</p></li></ul><p>range、index、all 需要添加<strong>合适的索引</strong>。</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>本次查询可能会用到的索引</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>实际使用到的索引。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>键长</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>使用的索引列用的查找方式：</p><ul><li><p>const：使用常数等值进行查询。</p></li><li><p>func：使用了表达式或函数。</p></li></ul><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>预估需要扫描的行数，其中如果行数到达表总行数一定的比例的时候，就会不使用索引。</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>通过过滤条件之后对比总数的百分比。</p><p>给出了一个百分比的值，这个百分比值和rows列的值一起使用，可以估计出那些将要和执行计划中的前一个表（前一个表就是指id列的值比当前表的id小的表）进行连接的行的数目。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><h4 id="using-index"><a href="#using-index" class="headerlink" title="using index"></a>using index</h4><p>本次查询使用了覆盖索引，直接通过索引就可以返回结果，无需进行回表。</p><blockquote><p>The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index.</p><p>For InnoDB tables that have a user-defined clustered index, that index can be used even when Using index is absent from the Extra column. This is the case if type is index and key is PRIMARY.</p></blockquote><p>从表中仅使用索引树中的信息就能获取查询语句的列的信息, 而不必进行其他额外查找（seek）去读取实际的行记录。当查询的列是单个索引的部分的列时, 可以使用此策略。对于具有用户定义的聚集索引的 InnoDB 表, 即使从Extra列中没有使用索引, 也可以使用该索引。如果 type 是 index 并且 Key 是主键, 则会出现这种情况（并非只有这一种情况）。</p><h4 id="using-where"><a href="#using-where" class="headerlink" title="using where"></a>using where</h4><blockquote><p>A WHERE clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the Extra value is not Using where and the table join type is ALL or index.</p><p>Using where has no direct counterpart in JSON-formatted output; the attached_condition property contains any WHERE condition used.</p></blockquote><p>where 子句用于限制与下一个表匹配的行记录或发送到客户端的行记录。除非您特意打算从表中提取或检查所有行,否则如果 Extra 值不是Using where 并且表连接类型为 ALL 或 index，则查询可能会出错。</p><p>MySQL 服务器在存储引擎收到记录后进行后过滤（Post-filter），先读取整行数据，再判断是否符合条件，符合保留，不符合丢弃。如果查询未能使用索引，Using where 的作用只是提醒我们 MySQL 将用 where 子句来过滤结果集。这个一般发生在 MySQL 服务器，而不是存储引擎层。一般发生在不能走索引扫描的情况下或者走索引扫描，但是有些查询条件不在索引当中的情况下。</p><h4 id="using-index-condition"><a href="#using-index-condition" class="headerlink" title="using index condition"></a>using index condition</h4><blockquote><p>Tables are read by accessing index tuples and testing them first to determine whether to read full table rows. In this way, index information is used to defer (“push down”) reading full table rows unless it is necessary. See Section 8.2.1.5, “Index Condition Pushdown Optimization”.</p></blockquote><p>mysql 5.6 时出现的新特性，基于 ICP（<strong>Index Condition Pushdown</strong>），即如果你的查询条件里有部分可以走索引，那么则会先将条件推到底层的存储引擎层去做一部分过滤，找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行，以此减少查询的条数。因此基于 icp 的概念，在我们使用组合索引的场景不是很明确时，最好可以分别建立索引。</p><h4 id="using-filesort"><a href="#using-filesort" class="headerlink" title="using filesort"></a>using filesort</h4><p>当需要的排序和使用索引的排序不一致时，即无法通过索引排序，在获取结果之后，还需要对结果进行再一次的排序。</p><p>MySQL 中<strong>无法利用索引</strong>完成的排序操作称为“文件排序”。</p><p>当我们试图对一个没有索引的字段进行排序时，就是filesoft。它跟文件没有任何关系，实际上是<strong>内部的一个快速排序</strong>。</p><h3 id="Using-where-Using-index-和-Using-index-condition"><a href="#Using-where-Using-index-和-Using-index-condition" class="headerlink" title="Using where; Using index 和 Using index condition"></a>Using where; Using index 和 Using index condition</h3><p><strong>Using index condition</strong> : where condition contains indexed and non-indexed column and the optimizer will first resolve the indexed column and will look for the rows in the table for the other condition (index push down)</p><p><strong>Using where; Using index</strong> : ‘Using index’ meaning not doing the scan of entire table. ‘Using where’ may still do the table scan on non-indexed column but it will use if there is any indexed column in the where condition first more like using index condition</p><p><strong>Which is better?</strong> </p><ul><li><p><code>Using where; Using index</code> would be better then <code>Using index condition</code> if query has index all covering.</p></li><li><p>When ‘Column Extra’ says <code>Using Index Condition</code>, all columns in where condition are using index. If there are any columns out of index, then Column Extra say <code>Using Where; Using Index</code> (in this case, Mysql need look for in data row to apply where clause). It’s better <code>Using Index Condition</code>.</p></li></ul><h3 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h3><p>在没有 ICP 之前，存储引擎根据索引去基表查找，然后将数据返回给 mysql server，mysql server 再根据 where 条件进行过滤。</p><p>ICP 是在取出索引的同时，判断是否可以根据索引当中的列进行 where 条件过滤，将 where 条件的过滤放在了存储引擎。</p><p>ICP 的执行步骤是：</p><ol><li><p>在存储引擎获取一条索引基础数据。</p></li><li><p>存储引擎根据上面的数据，结合where条件，判断是否满足where条件，如果没有满足条件，回到第一步，筛选下一条数据，否则的话，进行下面的判断。</p></li><li><p>对于满足下推条件的数据，存储引擎根据 B+ 树的 key，定位基表的行数据，并返回整行数据至 server 层。</p></li><li><p>在 server 层筛选没有被下推到存储引擎层 where 条件，满足则使用，否则丢弃。</p></li></ol><img src="https://blogres.blackist.org/20200814104611.jpg" style="zoom: 45%;" /><h2 id="二、优化经验"><a href="#二、优化经验" class="headerlink" title="二、优化经验"></a>二、优化经验</h2><ol><li>要对经常进行搜索，排序，分组的列创建索引。</li><li>考虑列基数（同一个列中的不重复的值的数量），列基数越大，效果越好，即区分度越高。</li><li>索引的数据类型尽可能的短，如果tinyint可以实现，就不要用Int</li><li>使用最左前缀。</li><li>不要建立过多的索引。</li><li>insert的时候可以考虑使用批量插入。</li><li>like的时候不要在初始位置使用通配符。</li></ol><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h3><p>出现以下情况时，考虑优化：</p><ul><li><p>using filesort 使用外部排序，而不是按照索引顺序排序，数据量少时通过内存排序，否则需要通过磁盘排序（<strong>需要添加合适的索引</strong>）</p></li><li><p>using temporary 创建一个临时表来存储数据，一般出现在对非索引的列集进行 group by 时 （需要添加合适的索引）  </p></li><li><p>using where 通常是对全表&#x2F;全索引进行扫描之后，再用 where 条件进行筛选查询出来的，<strong>通常 type 列为 all 或者 index</strong>.（<strong>需要添加合适的索引</strong>）</p></li><li><p>using index 表示当前的查询条件都能够从索引树当中获取，不需要进行回表查询，即（索引覆盖）说明性能还可以，需要和type列当中的 index 进行区分。如果同时出现了 using where 表明进行了索引被用来执行键值的查询，如果没有using where表明索引用来读取数据，而非查找，以上两种情况都是从 mysql 服务层完成的，无需再回表查询记录。</p></li></ul><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。</p><h4 id="1-ALTER-TABLE"><a href="#1-ALTER-TABLE" class="headerlink" title="1.ALTER TABLE"></a>1.ALTER TABLE</h4><p>ALTER TABLE 用来创建普通索引、UNIQUE 索引或 PRIMARY KEY 索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> INDEX index_name (column_list)<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> (column_list)<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (column_list)<br></code></pre></td></tr></table></figure><p> 其中 table_name 是要增加索引的表名，column_list 指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名 index_name 可选，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，ALTER TABLE 允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><h4 id="2-CREATE-INDEX"><a href="#2-CREATE-INDEX" class="headerlink" title="2.CREATE INDEX"></a>2.CREATE INDEX</h4><p>CREATE INDEX 可对表增加普通索引或 UNIQUE 索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name (column_list)<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name (column_list)<br></code></pre></td></tr></table></figure><p>table_name、index_name 和 column_list 具有与 ALTER TABLE 语句中相同的含义，索引名不可选。另外，不能用 CREATE INDEX 语句创建 PRIMARY KEY 索引。</p><h4 id="3-索引类型"><a href="#3-索引类型" class="headerlink" title="3.索引类型"></a>3.索引类型</h4><p>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为 PRIMARY KEY 或 UNIQUE 索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。</p><p>PRIMARY KEY 索引和 UNIQUE 索引非常类似。事实上，PRIMARY KEY 索引仅是一个具有名称 PRIMARY 的 UNIQUE 索引。这表示一个表只能包含一个 PRIMARY KEY，因为一个表中不可能具有两个同名的索引。</p><p>下面的SQL语句对 students 表在 sid 上添加 PRIMARY KEY 索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (sid)<br></code></pre></td></tr></table></figure><h4 id="4-删除索引"><a href="#4-删除索引" class="headerlink" title="4.删除索引"></a>4.删除索引</h4><p>可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> talbe_name<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> INDEX index_name<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY<br></code></pre></td></tr></table></figure><p>其中，前两条语句是等价的，删除掉table_name中的索引index_name。</p><p>第3条语句只在删除 PRIMARY KEY 索引时使用，因为一个表只可能有一个 PRIMARY KEY 索引，因此不需要指定索引名。如果没有创建 PRIMARY KEY 索引，但表具有一个或多个 UNIQUE 索引，则 MySQL 将删除第一个 UNIQUE 索引。</p><p>如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p><h4 id="5-查看索引"><a href="#5-查看索引" class="headerlink" title="5.查看索引"></a>5.查看索引</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; show index from tblname;<br>mysql&gt; show keys from tblname;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/index-extensions.html">https://dev.mysql.com/doc/refman/5.7/en/index-extensions.html</a></p><p><a href="https://www.cnblogs.com/kerrycode/p/9909093.html">https://www.cnblogs.com/kerrycode/p/9909093.html</a></p><p><a href="https://www.cnblogs.com/tianhuilove/archive/2011/09/05/2167795.html">https://www.cnblogs.com/tianhuilove/archive/2011/09/05/2167795.html</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell 脚本自动部署 Redis 集群</title>
    <link href="/2020-04-17-linux-redis-cluster-shell/"/>
    <url>/2020-04-17-linux-redis-cluster-shell/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时常需要在云服务器上搭建测试环境，每次入手新的服务器配置集群环境时，跟着笔记敲一遍命令行挺麻烦的。简单了解 shell 脚本后，用脚本在单机服务器上部署 Redis 集群。</p><span id="more"></span><h2 id="安装-Redis-服务器"><a href="#安装-Redis-服务器" class="headerlink" title="安装 Redis 服务器"></a>安装 Redis 服务器</h2><p>参照 <a href="https://blackist.org/2020/04/03/redis-cluster-masterandslave/">Redis 主从集群及自启动配置</a> 实现自动安装，首先判断是否已安装，若存在 Redis 服务程序则跳过，否则安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Check redis <span class="hljs-built_in">command</span></span><br>if [ ! -f &quot;/usr/local/bin/redis-server&quot; ]; then<br>  echo &quot;Redis not ready, please install redis firstly!&quot;<br>  echo &quot;&quot;<br>  echo &quot;===== Install redis as follows =====&quot;<br>  wget http://download.redis.io/releases/redis-5.0.7.tar.gz -P /usr/local/src<br>  cd /usr/local/src/<br>  tar -zxvf redis-5.0.7.tar.gz<br>  cd redis-5.0.7<br>  install GCC if not exists<br>  yum install -y gcc-c++<br>  make MALLOC=libc install<br><br>  echo &quot;&quot;<br>  echo &quot;Redis Server Installation Finished!&quot;<br>fi<br></code></pre></td></tr></table></figure><p>通过 <code>if [ ! -f &quot;/usr/local/bin/redis-server&quot; ]</code> 判断 server 程序是否存在，若存在则认为 Redis 已安装。</p><p>采用源码编译的方式安装 Redis，已指定 5.0.7 版本，防止出现兼容性问题。</p><h2 id="生成-Redis-实例的配置文件"><a href="#生成-Redis-实例的配置文件" class="headerlink" title="生成 Redis 实例的配置文件"></a>生成 Redis 实例的配置文件</h2><h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Constants</span><br>BASE_DIR=/usr/local/redis-cluster<br>PORTS=`seq 7000 7005`<br>START_UP=$BASE_DIR/startup.sh<br></code></pre></td></tr></table></figure><ul><li>BASE_DIR 为集群配置 directory；</li><li>PORTS 为集群在本地所占用的端口列表，<code>seq 7000 7005</code> 生成 7000-7005 的整数数组；</li><li>START_UP 为集群实例启动脚本，集群需要启动 6 个 Redis 实例，使用脚本简化操作。</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建工作目录，在工作目录下进行后续操作</span><br>mkdir -p $BASE_DIR<br>cd $BASE_DIR<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">准备集群实例启动脚本，在每次实例配置循环时将启动命令追加到脚本中</span><br>echo &quot;#!/bin/bash&quot; &gt; $START_UP<br>servers=<br>for port in $PORTS; do <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">设置每个实例的工作目录, data为数据存放目录</span><br>  mkdir -p $BASE_DIR/$port/data<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">生成单个实例的配置文件</span><br>  generate_instance_conf $port<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">追加实例启动命令到启动脚本</span><br>  echo &quot;/usr/local/bin/redis-server $BASE_DIR/$port/redis.conf&quot; &gt;&gt; $START_UP<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">记录所有的实例位置，用于之后的集群启动</span><br>  servers=&quot;$servers 127.0.0.1:$port &quot;<br>done<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>每个实例的配置文件相似，只是端口号和工作目录不同。还有一点需要注意，要想可以从其它外部主机访问此主机上的 Redis 集群，需要将实例的集群地址设置为主机的外网地址，因此需要用户手动输入主机外网地址。</p><p>使用 shell 实现外网地址获取的交互模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">User custom setting</span><br>echo -n &quot;Enter your host&#x27;s public address(default 127.0.0.1):&quot;<br>read cluster_address<br></code></pre></td></tr></table></figure><p>将实例配置依次写入 redis.conf 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">generate configuration files</span><br>function generate_instance_conf() &#123;<br>  echo &quot;configuring server $1&quot;<br>  <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">clean conf file</span><br>  echo &quot;&quot; &gt; $1/redis.conf<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">write conf</span><br>  echo &quot;port $1&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;bind 0.0.0.0&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;dir $BASE_DIR/$port/data&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;cluster-enabled yes&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;cluster-config-file nodes-$1.conf&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;cluster-node-timeout 5000&quot; &gt;&gt; $1/redis.conf<br>  if [ -n &quot;$cluster_address&quot; ]; then <br>    echo &quot;cluster-announce-ip $cluster_address&quot; &gt;&gt; $1/redis.conf<br>  else <br>    echo &quot;cluster-announce-ip 127.0.0.1&quot; &gt;&gt; $1/redis.conf<br>  fi<br>  echo &quot;appendonly yes&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;daemonize yes&quot; &gt;&gt; $1/redis.conf<br>&#125;<br>chmod +x $START_UP<br></code></pre></td></tr></table></figure><p>如上步骤完成后，集群工作目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">drwxr-xr-x 3 root root 4096 Apr 19 11:07 7000<br>drwxr-xr-x 3 root root 4096 Apr 19 11:07 7001<br>drwxr-xr-x 3 root root 4096 Apr 19 11:07 7002<br>drwxr-xr-x 3 root root 4096 Apr 19 11:07 7003<br>drwxr-xr-x 3 root root 4096 Apr 19 11:07 7004<br>drwxr-xr-x 3 root root 4096 Apr 19 11:07 7005<br>-rwxr-xr-x 1 root root  426 Apr 19 11:07 startup.sh<br></code></pre></td></tr></table></figure><h2 id="启动实例并建立集群"><a href="#启动实例并建立集群" class="headerlink" title="启动实例并建立集群"></a>启动实例并建立集群</h2><h3 id="启动-Redis-服务实例"><a href="#启动-Redis-服务实例" class="headerlink" title="启动 Redis 服务实例"></a>启动 Redis 服务实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">startup instances</span><br>echo &quot;starting servers...&quot;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">START_UP</span><br>sleep 5s<br>echo &quot;servers ready!&quot;<br></code></pre></td></tr></table></figure><p>执行启动脚本，启动 6 个 Redis 实例，并保持休眠 5 秒，等待集群启动完成，执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">starting servers...<br>27764:C 19 Apr 2020 11:07:58.874 <span class="hljs-comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br>27764:C 19 Apr 2020 11:07:58.874 <span class="hljs-comment"># Redis version=5.0.7, ..</span><br>27764:C 19 Apr 2020 11:07:58.874 <span class="hljs-comment"># Configuration loaded</span><br>...<br>27777:C 19 Apr 2020 11:07:58.885 <span class="hljs-comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br>27777:C 19 Apr 2020 11:07:58.885 <span class="hljs-comment"># Redis version=5.0.7, ..</span><br>27777:C 19 Apr 2020 11:07:58.885 <span class="hljs-comment"># Configuration loaded</span><br>servers ready! <br></code></pre></td></tr></table></figure><h3 id="建立集群"><a href="#建立集群" class="headerlink" title="建立集群"></a>建立集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">create cluster</span><br>echo &quot;configuring cluster...&quot;<br>/usr/local/bin/redis-cli --cluster create $servers --cluster-replicas 1<br>echo &quot;configured!&quot;<br></code></pre></td></tr></table></figure><p>使用 redis-cli 建立集群，指定所要包含实例的 host 和 port，$servers 中就是这些信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">configuring cluster...<br>&gt;&gt;&gt; Performing <span class="hljs-built_in">hash</span> slots allocation on 6 nodes...<br>Master[0] -&gt; Slots 0 - 5460<br>Master[1] -&gt; Slots 5461 - 10922<br>Master[2] -&gt; Slots 10923 - 16383<br>...<br>Can I <span class="hljs-built_in">set</span> the above configuration? (<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;yes&#x27;</span> to accept): <span class="hljs-built_in">yes</span><br>...<br>[OK] All nodes agree about slots configuration.<br>&gt;&gt;&gt; Check <span class="hljs-keyword">for</span> open slots...<br>&gt;&gt;&gt; Check slots coverage...<br>[OK] All 16384 slots covered.<br>configured!<br></code></pre></td></tr></table></figure><p>集群建立时需要用户手动确认槽数划分，输入 <code>yes</code> 即可。</p><p>至此集群部署完成，下面配置集群开机自启动。</p><h2 id="systemd-自启动"><a href="#systemd-自启动" class="headerlink" title="systemd 自启动"></a>systemd 自启动</h2><p>使用 systemd 配置 Redis 集群启动服务，首先配置 service 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">generate redis-cluster service file</span><br>cat &lt;&lt; EOT &gt; $BASE_DIR/redis-cluster.service<br>[Unit]<br>Description=Redis 5.0 Cluster Service<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/redis-cluster/startup.sh<br><br>[Install]<br>WantedBy=default.target<br>EOT<br></code></pre></td></tr></table></figure><p><code>cat &lt;&lt; EOT &gt; $BASE_DIR/redis-cluster.service</code> 表示向 <code>redis-cluster.service</code> 文件中覆盖一段内容，内容为下一行至 <code>EOT</code> 之间的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">create service</span><br>echo &quot;Creating redis cluster service...&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 systemd 文件夹下创建 service 的软连接并启动 redis 集群服务</span><br>ln -s $BASE_DIR/$SERVICE /etc/systemd/system/$SERVICE <br>sudo systemctl daemon-reload &amp;&amp; sudo systemctl enable $SERVICE &amp;&amp; sudo systemctl start $SERVICE<br></code></pre></td></tr></table></figure><h2 id="集群删除"><a href="#集群删除" class="headerlink" title="集群删除"></a>集群删除</h2><p>使用 <code>--remove</code> 参数执行集群删除操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Remove redis cluster</span><br>function remove_cluster() &#123;<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">终止各 Reids 实例进程</span><br>  ps -ef | grep redis-server | grep cluster | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">移除 systemd 服务</span><br>  systemctl disable redis-cluster.service<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">移除工作目录（配置文件和数据）</span><br>  if [ -d $BASE_DIR ]; then<br>    rm -rf $BASE_DIR<br>  fi<br>&#125;<br><br>if [ &quot;$1&quot; = &quot;--remove&quot; ]; then<br>  remove_cluster<br>  exit 0<br>fi<br></code></pre></td></tr></table></figure><p>通过过滤器 <code>grep</code> 和流式编辑器 <code>awk</code> 查询到 Redis 实例的 pid，使用 <code>kill</code> 命令结束进程。</p><p>其中 <code>awk &#39;&#123;print $2&#125;&#39;</code> 为 <code>awk -F &#39; &#39; &#39;&#123;print $2&#125;&#39;</code> 的缩写，<code>-F</code> 表示分隔符参数，默认为空格，&#96;&#96;awk -F ‘ ‘&#96; 将如下内容分割为数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root 27765 1 0 11:07 ? 00:00:03 /usr/local/bin/redis-server 0.0.0.0:7000 [cluster]<br></code></pre></td></tr></table></figure><p><code>&#123;print $2&#125;</code> 表述输出第 2 个元素，$0 表述输出整行。</p><h2 id="完整的-shell"><a href="#完整的-shell" class="headerlink" title="完整的 shell"></a>完整的 shell</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>BASE_DIR=/usr/local/redis-cluster<br><br>PORTS=`seq 7000 7005`<br><br>START_UP=$BASE_DIR/startup.sh<br><br>SERVICE=redis-cluster.service<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Remove redis cluster</span><br>function remove_cluster() &#123;<br><span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-built_in">kill</span> redis servers</span><br>  ps -ef | grep redis-server | grep cluster | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9<br><span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-built_in">disable</span> systemd</span><br>  systemctl disable redis-cluster.service<br><span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-built_in">rm</span> cluster data</span><br>  if [ -d $BASE_DIR ]; then<br>    rm -rf $BASE_DIR<br>  fi<br>&#125;<br><br>if [ &quot;$1&quot; = &quot;--remove&quot; ]; then<br>  remove_cluster<br>  exit 0<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Check redis <span class="hljs-built_in">command</span></span><br>if [ ! -f &quot;/usr/local/bin/redis-server&quot; ]; then<br>  echo &quot;Redis not ready, please install redis firstly!&quot;<br>  echo &quot;&quot;<br>  echo &quot;===== Install redis as follows =====&quot;<br>  wget http://download.redis.io/releases/redis-5.0.7.tar.gz -P /usr/local/src<br>  cd /usr/local/src/<br>  tar -zxvf redis-5.0.7.tar.gz<br>  cd redis-5.0.7<br>  install GCC if not exists<br>  yum install -y gcc-c++<br>  make MALLOC=libc install<br><br>  echo &quot;&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">User custom setting</span><br>echo -n &quot;Enter your host&#x27;s public address(default 127.0.0.1):&quot;<br>read cluster_address<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">enter work directory</span><br>mkdir -p $BASE_DIR<br>cd $BASE_DIR<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">generate configuration files</span><br>function generate_instance_conf() &#123;<br>  echo &quot;configuring server $1&quot;<br>  <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">clean conf file</span><br>  echo &quot;&quot; &gt; $1/redis.conf<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">write conf</span><br>  echo &quot;port $1&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;bind 0.0.0.0&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;dir $BASE_DIR/$1/data&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;cluster-enabled yes&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;cluster-config-file nodes-$1.conf&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;cluster-node-timeout 5000&quot; &gt;&gt; $1/redis.conf<br>  if [ -n &quot;$cluster_address&quot; ]; then <br>    echo &quot;cluster-announce-ip $cluster_address&quot; &gt;&gt; $1/redis.conf<br>  else <br>    echo &quot;cluster-announce-ip 127.0.0.1&quot; &gt;&gt; $1/redis.conf<br>  fi<br>  echo &quot;appendonly yes&quot; &gt;&gt; $1/redis.conf<br>  echo &quot;daemonize yes&quot; &gt;&gt; $1/redis.conf<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">dirs</span> and setup startup.sh</span><br>echo &quot;#!/bin/bash&quot; &gt; $START_UP<br>servers=<br>for port in $PORTS; do <br>  mkdir -p $BASE_DIR/$port/data<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">generate conf files</span><br>  generate_instance_conf $port<br><span class="hljs-meta prompt_">  # </span><span class="language-bash"></span><br><span class="language-bash">  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/usr/local/bin/redis-server <span class="hljs-variable">$BASE_DIR</span>/<span class="hljs-variable">$port</span>/redis.conf&quot;</span> &gt;&gt; <span class="hljs-variable">$START_UP</span></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">servers</span><br>  servers=&quot;$servers 127.0.0.1:$port &quot;<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">startup instances</span><br>chmod +x $START_UP<br>echo &quot;starting servers...&quot;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">START_UP</span><br>sleep 5s<br>echo &quot;servers ready!&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">create cluster</span><br>echo &quot;configuring cluster...&quot;<br>/usr/local/bin/redis-cli --cluster create $servers --cluster-replicas 1<br>echo &quot;configured!&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">generate redis-cluster service file</span><br>cat &lt;&lt; EOT &gt; $BASE_DIR/redis-cluster.service<br>[Unit]<br>Description=Redis 5.0 Cluster Service<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/redis-cluster/startup.sh<br><br>[Install]<br>WantedBy=default.target<br>EOT<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">create service</span><br>echo &quot;Creating redis cluster service...&quot;<br>ln -s $BASE_DIR/$SERVICE /etc/systemd/system/$SERVICE <br>sudo systemctl daemon-reload &amp;&amp; sudo systemctl enable $SERVICE &amp;&amp; sudo systemctl start $SERVICE<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Cluster OK</span><br>echo &quot;&quot;<br>echo &quot;Completed!&quot;<br>echo &quot;&quot;<br>echo &quot;Test cluster with: /usr/local/bin/redis-cli -h 127.0.0.1 -p 7000&quot;<br>echo &quot;&quot;<br>echo &quot;127.0.0.1:7000&gt;cluster nodes&quot;<br></code></pre></td></tr></table></figure><p>脚本下载：<a href="https://blogres.blackist.org/202004232347_404.sh">https://blogres.blackist.org/202004232347_404.sh</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blackist.org/2020/04/03/redis-cluster-masterandslave/">https://blackist.org/2020/04/03/redis-cluster-masterandslave/</a></p><p><a href="https://stackoverflow.com/questions/13910087/shell-script-to-capture-process-id-and-kill-it-if-exist">https://stackoverflow.com/questions/13910087/shell-script-to-capture-process-id-and-kill-it-if-exist</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>OPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>OPS</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Shell 脚本基础</title>
    <link href="/2020-04-17-linux-shell-base/"/>
    <url>/2020-04-17-linux-shell-base/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>接触过一些 shell 脚本，做服务端运维时也时常用到，是时候专门学习一下了。</p><span id="more"></span><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Here-Script"><a href="#Here-Script" class="headerlink" title="Here Script"></a>Here Script</h3><p>使用 _EOF_ 将多行语句作为单句，避免转义字符的麻烦：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">echos</span> <br>echo &quot;&lt;html&gt;&quot;<br>echo &quot;&lt;head&gt;&quot;<br>echo &quot;&lt;/head&gt;&quot;<br>echo &quot;&lt;/html&gt;&quot;<br><br>echo &quot;&lt;html&gt;<br> &lt;head&gt;<br> &lt;/head&gt;<br> &lt;/html&gt;&quot;<br><br>cat &lt;&lt; _EOF_<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;/head&gt;<br>&lt;/html&gt;<br>_EOF_<br></code></pre></td></tr></table></figure><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>Rules: </p><ol><li>Names must start with a letter.</li><li>A name must not contain embedded spaces. Use underscores instead.</li><li>You cannot use punctuation marks.</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>title=&quot;System Information for&quot;<br>echo $title<br></code></pre></td></tr></table></figure><h3 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h3><p>脚本文件启动前，系统已预设一些环境变量，在命令行中使用 <code>printenv</code> 查看这些变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@bhc004 ~]<span class="hljs-comment"># printenv</span><br>XDG_SESSION_ID=87<br>HOSTNAME=bhc004<br>TERM=linux<br>SHELL=/bin/bash<br>HISTSIZE=10000<br>SSH_CLIENT=125.117.180.232 57544 22<br>SSH_TTY=/dev/pts/0<br>USER=root<br>LS_COLORS=rs=0:di=01;34:<span class="hljs-built_in">ln</span>=01;``````.spx=01;36:*.xspf=01;36:<br>MAIL=/var/spool/mail/root<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/jdk/bin<br>PWD=/root<br>LANG=en_US.UTF-8<br>HISTCONTROL=ignoredups<br>SHLVL=1<br>HOME=/root<br>LOGNAME=root<br>SSH_CONNECTION=125.117.180.232 57544 192.168.0.182 22<br>LESSOPEN=||/usr/bin/lesspipe.sh %s<br>XDG_RUNTIME_DIR=/run/user/0<br>HISTTIMEFORMAT=%F %T root <br>_=/usr/bin/printenv<br></code></pre></td></tr></table></figure><p>在 shell 中可以使用这些环境变量 <code>echo $HOSTNAME</code>。</p><h2 id="命令替换和常量"><a href="#命令替换和常量" class="headerlink" title="命令替换和常量"></a>命令替换和常量</h2><p>Command Substitution and Constants</p><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo Updated on $(date +&quot;%x %r %Z&quot;) by $USER<br></code></pre></td></tr></table></figure><p><code>$(date +&quot;%x %r %Z&quot;)</code> 中 <code>$()</code> 告诉 shell 替换附带命令的执行结果，即插入 <code>date +&quot;%x %r %Z</code> 的执行结果（当前时间）。</p><blockquote><p>Be aware that there is an older, alternate syntax for “$(command)” that uses the backtick character “`“. This older form is compatible with the original Bourne shell (sh). I tend not to use the older form since I am teaching modern <code>bash</code> here, not <code>sh</code>, and besides, I think backticks are ugly. The bash shell fully supports scripts written for sh, so the following forms are equivalent:</p><p>$(command)     `command`</p></blockquote><p>把命令执行结果赋值给变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">right_now=$(date +&quot;%x %r %z&quot;)<br></code></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">RIGHT_NOW=$(date +&quot;%x %r %Z&quot;)<br>TIME_STAMP=&quot;Updated on $RIGHT_NOW by $USER&quot;<br></code></pre></td></tr></table></figure><p>很少用，使用大写字母定义常量名（非强制）。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>自定义函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### Functions</span></span><br>show_uptime() &#123;<br>    echo &quot;&lt;h2&gt;System uptime&lt;/h2&gt;&quot;<br>    echo &quot;&lt;pre&gt;&quot;<br>    uptime<br>    echo &quot;&lt;/pre&gt;&quot;<br>&#125;<br><br>drive_space() &#123;<br>    echo &quot;&lt;h2&gt;Filesystem space&lt;/h2&gt;&quot;<br>    echo &quot;&lt;pre&gt;&quot;<br>    df<br>    echo &quot;&lt;/pre&gt;&quot;<br>&#125;<br><br>cat &lt;&lt; _EOF_<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">(show_uptime)</span><br><span class="hljs-meta prompt_">  $</span><span class="language-bash">(drive_space)</span><br>_EOF_<br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">function generate_instance_conf() &#123;<br>  echo &quot;configuring server $1&quot;<br>&#125;<br>generate_instance_conf server1<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">configuring server server1<br></code></pre></td></tr></table></figure><h3 id="date-格式化"><a href="#date-格式化" class="headerlink" title="date 格式化"></a>date 格式化</h3><p>Following are the list of available options for date command :</p><table><thead><tr><th align="left">Format option</th><th align="left">Part of Date</th><th align="left">Desciption</th><th align="left">Example Output</th></tr></thead><tbody><tr><td align="left">date +%a</td><td align="left">Weekday</td><td align="left">Name of weekday in short (like Sun, Mon, Tue, Wed, Thu, Fri, Sat)</td><td align="left">Mon</td></tr><tr><td align="left">date +%A</td><td align="left">Weekday</td><td align="left">Name of weekday in full (like Sunday, Monday, Tuesday)</td><td align="left">Monday</td></tr><tr><td align="left">date +%b</td><td align="left">Month</td><td align="left">Name of Month in short (like Jan, Feb, Mar )</td><td align="left">Jan</td></tr><tr><td align="left">date +%B</td><td align="left">Month</td><td align="left">Month name in full short (like January, February)</td><td align="left">January</td></tr><tr><td align="left">date +%d</td><td align="left">Day</td><td align="left">Day of month (e.g., 01)</td><td align="left">04</td></tr><tr><td align="left">date +%D</td><td align="left">MM&#x2F;DD&#x2F;YY</td><td align="left">Current Date; shown in MM&#x2F;DD&#x2F;YY</td><td align="left">02&#x2F;18&#x2F;18</td></tr><tr><td align="left">date +%F</td><td align="left">YYYY-MM-DD</td><td align="left">Date; shown in YYYY-MM-DD</td><td align="left">2018-01-19</td></tr><tr><td align="left">date +%H</td><td align="left">Hour</td><td align="left">Hour in 24-hour clock format</td><td align="left">18</td></tr><tr><td align="left">date +%I</td><td align="left">Hour</td><td align="left">Hour in 12-hour clock format</td><td align="left">10</td></tr><tr><td align="left">date +%j</td><td align="left">Day</td><td align="left">Day of year (001..366)</td><td align="left">152</td></tr><tr><td align="left">date +%m</td><td align="left">Month</td><td align="left">Number of month (01..12) (01 is January)</td><td align="left">05</td></tr><tr><td align="left">date +%M</td><td align="left">Minutes</td><td align="left">Minutes (00..59)</td><td align="left">52</td></tr><tr><td align="left">date +%S</td><td align="left">Seconds</td><td align="left">Seconds (00..59)</td><td align="left">18</td></tr><tr><td align="left">date +%N</td><td align="left">Nanoseconds</td><td align="left">Nanoseconds (000000000..999999999)</td><td align="left">300231695</td></tr><tr><td align="left">date +%T</td><td align="left">HH:MM:SS</td><td align="left">Time as HH:MM:SS (Hours in 24 Format)</td><td align="left">18:55:42</td></tr><tr><td align="left">date +%u</td><td align="left">Day of Week</td><td align="left">Day of week (1..7); 1 is Monday</td><td align="left">7</td></tr><tr><td align="left">date +%U</td><td align="left">Week</td><td align="left">Displays week number of year, with Sunday as first day of week (00..53)</td><td align="left">23</td></tr><tr><td align="left">date +%Y</td><td align="left">Year</td><td align="left">Displays full year i.e. YYYY</td><td align="left">2018</td></tr><tr><td align="left">date +%Z</td><td align="left">Timezone</td><td align="left">Time zone abbreviation (Ex: IST, GMT)</td><td align="left">IST</td></tr></tbody></table><p>You may use any of the above-mentioned format options (first column) for the date command in the aforementioned syntax.</p><h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><code>if</code> 语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if commands; then<br>commands<br>[elif commands; then<br>commands...]<br>[else<br>commands]<br>fi<br></code></pre></td></tr></table></figure><h3 id="Exit-Status"><a href="#Exit-Status" class="headerlink" title="Exit Status"></a>Exit Status</h3><p>退出状态，即命令执行后会给系统一个值，0-255，0 代表 success：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@bhc004 ~]<span class="hljs-comment"># true</span><br>[root@bhc004 ~]<span class="hljs-comment"># echo $?</span><br>0<br>[root@bhc004 ~]<span class="hljs-comment"># false</span><br>[root@bhc004 ~]<span class="hljs-comment"># echo $?</span><br>1<br></code></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">First form</span><br>test expression<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Second form</span><br>[ expression ]<br></code></pre></td></tr></table></figure><p>test 命令和 if 命令一起完成 true &#x2F; false 判断，当表达式为 true，test 以 0 退出；为 false，test 以 1 退出。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ -f .bash_profile ]; then<br>    echo &quot;You have a .bash_profile. Things are fine.&quot;<br>else<br>    echo &quot;Yikes! You have no .bash_profile!&quot;<br>fi<br></code></pre></td></tr></table></figure><p>表达式“-f .bash_profile”表示 .bash_profile 是一个文件，若为 true，则执行 <code>then</code> 后的命令；否则执行 else 后的命令。</p><p>test 可以评估的表达式如下：</p><table><thead><tr><th><strong>Expression</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>-d <em>file</em></td><td>True if <em>file</em> is a directory.</td></tr><tr><td>-e <em>file</em></td><td>True if <em>file</em> exists.</td></tr><tr><td>-f <em>file</em></td><td>True if <em>file</em> exists and is a regular file.</td></tr><tr><td>-L <em>file</em></td><td>True if <em>file</em> is a symbolic link.</td></tr><tr><td>-r <em>file</em></td><td>True if <em>file</em> is a file readable by you.</td></tr><tr><td>-w <em>file</em></td><td>True if <em>file</em> is a file writable by you.</td></tr><tr><td>-x <em>file</em></td><td>True if <em>file</em> is a file executable by you.</td></tr><tr><td><em>file1</em> -nt <em>file2</em></td><td>True if <em>file1</em> is newer than (according to modification time) <em>file2</em></td></tr><tr><td><em>file1</em> -ot <em>file2</em></td><td>True if <em>file1</em> is older than <em>file2</em></td></tr><tr><td>-z <em>string</em></td><td>True if <em>string</em> is empty.</td></tr><tr><td>-n <em>string</em></td><td>True if <em>string</em> is not empty.</td></tr><tr><td><em>string1</em> &#x3D; <em>string2</em></td><td>True if <em>string1</em> equals <em>string2.</em></td></tr><tr><td><em>string1</em> !&#x3D; <em>string2</em></td><td>True if <em>string1</em> does not equal <em>string2.</em></td></tr></tbody></table><p>不同的书写格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Alternate form</span><br>if [ -f .bash_profile ]<br>then<br>    echo &quot;You have a .bash_profile. Things are fine.&quot;<br>else<br>    echo &quot;Yikes! You have no .bash_profile!&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Another alternate form</span><br>if [ -f .bash_profile ]<br>then echo &quot;You have a .bash_profile. Things are fine.&quot;<br>else echo &quot;Yikes! You have no .bash_profile!&quot;<br>fi<br></code></pre></td></tr></table></figure><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>exit 命令可以立即结束此脚本，并设置退出状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit 0<br></code></pre></td></tr></table></figure><h3 id="test-for-superuser"><a href="#test-for-superuser" class="headerlink" title="test for superuser"></a>test for superuser</h3><p><code>id</code> 命令可以查看当前用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@bhc004 ~]<span class="hljs-comment"># id</span><br>uid=0(root) gid=0(root) <span class="hljs-built_in">groups</span>=0(root)<br>[root@bhc004 ~]<span class="hljs-comment"># id -u</span><br>0<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ $(id -u) != &quot;0&quot; ]; then<br>    # &gt;&amp;2 输出到标准错误<br>    echo &quot;You must be the superuser to run this script&quot; &gt;&amp;2<br>    # 1 向操作系统表示脚本执行不成功<br>    exit 1<br>else<br>    echo &quot;superuser&quot;<br>fi<br></code></pre></td></tr></table></figure><h3 id="Watching-your-script"><a href="#Watching-your-script" class="headerlink" title="Watching your script"></a>Watching your script</h3><p>在第一行加 <code>+x</code> 监控脚本执行状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash -x</span><br></code></pre></td></tr></table></figure><p>或者，使用 <code>set -x</code> 和 <code>set +x</code>监控一段代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>number=1<br><br>set -x<br>if [ $number = &quot;1&quot; ]; then<br>    echo &quot;Number equals 1&quot;<br>else<br>    echo &quot;Number does not equal 1&quot;<br>fi<br>set +x<br></code></pre></td></tr></table></figure><h2 id="键盘输入和算术"><a href="#键盘输入和算术" class="headerlink" title="键盘输入和算术"></a>键盘输入和算术</h2><p>用户交互。</p><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>从键盘输入并赋值给变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo -n &quot;Enter some text &gt; &quot;<br>read text<br>echo &quot;You entered: $text&quot;<br></code></pre></td></tr></table></figure><p><code>-n</code> 使输入和字符串在同一行。read 有 <code>-t</code>、<code>-s</code> 等参数：</p><ul><li><code>-t</code> 表示在指定时间内获得响应，当无论用户是否输入都要继续执行时使用；</li><li><code>is</code> 表示不显示输入的内容；当输入密码时使用；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo -n &quot;Hurry up and type something! &gt; &quot;<br>if read -t 3 response; then<br>    echo &quot;Great, you made it in time!&quot;<br>else<br>    echo &quot;Sorry, you are too slow!&quot;<br>fi<br></code></pre></td></tr></table></figure><h3 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h3><p>使用双括号计算算术表达式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>first_num=0<br>second_num=0<br><br>echo -n &quot;Enter the first number --&gt; &quot;<br>read first_num<br>echo -n &quot;Enter the second number -&gt; &quot;<br>read second_num<br><br>echo &quot;first number + second number = $((first_num + second_num))&quot;<br>echo &quot;first number - second number = $((first_num - second_num))&quot;<br>echo &quot;first number * second number = $((first_num * second_num))&quot;<br>echo &quot;first number / second number = $((first_num / second_num))&quot;<br>echo &quot;first number % second number = $((first_num % second_num))&quot;<br>echo &quot;first number raised to the&quot;<br>echo &quot;power of the second number   = $((first_num ** second_num))&quot;<br></code></pre></td></tr></table></figure><p>括号内的变量不需要 <code>$</code> 就可以引用，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>number=0<br><br>echo -n &quot;Enter a number &gt; &quot;<br>read number<br><br>echo &quot;Number is $number&quot;<br>if [ $((number % 2)) -eq 0 ]; then<br>    echo &quot;Number is even&quot;<br>else<br>    echo &quot;Number is odd&quot;<br>fi<br></code></pre></td></tr></table></figure><h2 id="流控制2"><a href="#流控制2" class="headerlink" title="流控制2"></a>流控制2</h2><p>更过分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo -n &quot;Enter a number between 1 and 3 inclusive &gt; &quot;<br>read character<br>if [ &quot;$character&quot; = &quot;1&quot; ]; then<br>    echo &quot;You entered one.&quot;<br>elif [ &quot;$character&quot; = &quot;2&quot; ]; then<br>    echo &quot;You entered two.&quot;<br>elif [ &quot;$character&quot; = &quot;3&quot; ]; then<br>    echo &quot;You entered three.&quot;<br>else<br>    echo &quot;You did not enter a number between 1 and 3.&quot;<br>fi<br></code></pre></td></tr></table></figure><p>使用 case 优化分支结构</p><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>case 语句格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">case word in<br>    patterns ) commands ;;<br>esac<br></code></pre></td></tr></table></figure><p>改造如上语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo -n &quot;Enter a number between 1 and 3 inclusive &gt; &quot;<br>read character<br>case $character in<br>    1 ) echo &quot;You entered one.&quot;<br>        ;;<br>    2 ) echo &quot;You entered two.&quot;<br>        ;;<br>    3 ) echo &quot;You entered three.&quot;<br>        ;;<br>    * ) echo &quot;You did not enter a number between 1 and 3.&quot;<br>esac<br></code></pre></td></tr></table></figure><p>case 也可以匹配表达式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo -n &quot;Type a digit or a letter &gt; &quot;<br>read character<br>case $character in<br>                                # Check for letters<br>    [[:lower:]] | [[:upper:]] ) echo &quot;You typed the letter $character&quot;<br>                                ;;<br><br>                                # Check for digits<br>    [0-9] )                     echo &quot;You typed the digit $character&quot;<br>                                ;;<br><br>                                # Check for anything else<br>    * )                         echo &quot;You did not type a letter or a digit&quot;<br>esac<br></code></pre></td></tr></table></figure><p><code>*</code> 通常用来检测无效输入。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>number=0<br><span class="hljs-keyword">while</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$number</span>&quot;</span> -lt 10 ]; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Number = <span class="hljs-variable">$number</span>&quot;</span><br>    number=$((number + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="util"><a href="#util" class="headerlink" title="util"></a>util</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>number=0<br>until [ &quot;$number&quot; -ge 10 ]; do<br>    echo &quot;Number = $number&quot;<br>    number=$((number + 1))<br>done<br></code></pre></td></tr></table></figure><h4 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>selection=<br>until [ &quot;$selection&quot; = &quot;0&quot; ]; do<br>    echo &quot;<br>    PROGRAM MENU<br>    1 - Display free disk space<br>    2 - Display free memory<br><br>    0 - exit program<br>&quot;<br>    echo -n &quot;Enter selection: &quot;<br>    read selection<br>    echo &quot;&quot;<br>    case $selection in<br>        1 ) df ;;<br>        2 ) free ;;<br>        0 ) exit ;;<br>        * ) echo &quot;Please enter 1, 2, or 0&quot;<br>    esac<br>done<br></code></pre></td></tr></table></figure><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo &quot;Positional Parameters&quot;<br>echo &#x27;$0 = &#x27; $0<br>echo &#x27;$1 = &#x27; $1<br>echo &#x27;$2 = &#x27; $2<br>echo &#x27;$3 = &#x27; $3<br><br>if [ &quot;$1&quot; != &quot;&quot; ]; then<br>    echo &quot;Positional parameter 1 contains something&quot;<br>else<br>    echo &quot;Positional parameter 1 is empty&quot;<br>fi<br></code></pre></td></tr></table></figure><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">interactive=<br>filename=~/sysinfo_page.html<br><br>while [ &quot;$1&quot; != &quot;&quot; ]; do<br>    case $1 in<br>        -f | --file )           shift<br>                                filename=$1<br>                                ;;<br>        -i | --interactive )    interactive=1<br>                                ;;<br>        -h | --help )           usage<br>                                exit<br>                                ;;<br>        * )                     usage<br>                                exit 1<br>    esac<br>    shift<br>done<br></code></pre></td></tr></table></figure><h3 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h3><p><code>shift</code> 是内建命令，每次调用 <code>shift</code> 使所有参数的索引减一，即 $2 变成 $1，$3 变成 $2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo &quot;You start with $# positional parameters&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Loop until all parameters are used up</span><br>while [ &quot;$1&quot; != &quot;&quot; ]; do<br>    echo &quot;Parameter 1 equals $1&quot;<br>    echo &quot;You now have $# positional parameters&quot;<br><br>    # Shift all the parameters down by one<br>    shift<br><br>done<br></code></pre></td></tr></table></figure><h3 id="命令行处理器"><a href="#命令行处理器" class="headerlink" title="命令行处理器"></a>命令行处理器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sysinfo_page - A script to produce a system information HTML file</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#### Constants</span></span><br><br>TITLE=&quot;System Information for $HOSTNAME&quot;<br>RIGHT_NOW=$(date +&quot;%x %r %Z&quot;)<br>TIME_STAMP=&quot;Updated on $RIGHT_NOW by $USER&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#### Functions</span></span><br><br>system_info()<br>&#123;<br>    echo &quot;&lt;h2&gt;System release info&lt;/h2&gt;&quot;<br>    echo &quot;&lt;p&gt;Function not yet implemented&lt;/p&gt;&quot;<br><br>&#125;   # end of system_info<br><br><br>show_uptime()<br>&#123;<br>    echo &quot;&lt;h2&gt;System uptime&lt;/h2&gt;&quot;<br>    echo &quot;&lt;pre&gt;&quot;<br>    uptime<br>    echo &quot;&lt;/pre&gt;&quot;<br><br>&#125;   # end of show_uptime<br><br><br>drive_space()<br>&#123;<br>    echo &quot;&lt;h2&gt;Filesystem space&lt;/h2&gt;&quot;<br>    echo &quot;&lt;pre&gt;&quot;<br>    df<br>    echo &quot;&lt;/pre&gt;&quot;<br><br>&#125;   # end of drive_space<br><br><br>home_space()<br>&#123;<br>    # Only the superuser can get this information<br><br>    if [ &quot;$(id -u)&quot; = &quot;0&quot; ]; then<br>        echo &quot;&lt;h2&gt;Home directory space by user&lt;/h2&gt;&quot;<br>        echo &quot;&lt;pre&gt;&quot;<br>        echo &quot;Bytes Directory&quot;<br>        du -s /home/* | sort -nr<br>        echo &quot;&lt;/pre&gt;&quot;<br>    fi<br><br>&#125;   # end of home_space<br><br><br>write_page()<br>&#123;<br>    cat &lt;&lt;- _EOF_<br>    &lt;html&gt;<br>        &lt;head&gt;<br>        &lt;title&gt;$TITLE&lt;/title&gt;<br>        &lt;/head&gt;<br>        &lt;body&gt;<br>        &lt;h1&gt;$TITLE&lt;/h1&gt;<br>        &lt;p&gt;$TIME_STAMP&lt;/p&gt;<br>        $(system_info)<br>        $(show_uptime)<br>        $(drive_space)<br>        $(home_space)<br>        &lt;/body&gt;<br>    &lt;/html&gt;<br>_EOF_<br><br>&#125;<br><br>usage()<br>&#123;<br>    echo &quot;usage: sysinfo_page [[[-f file ] [-i]] | [-h]]&quot;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#### Main</span></span><br><br>interactive=<br>filename=~/sysinfo_page.html<br><br>while [ &quot;$1&quot; != &quot;&quot; ]; do<br>    case $1 in<br>        -f | --file )           shift<br>                                filename=$1<br>                                ;;<br>        -i | --interactive )    interactive=1<br>                                ;;<br>        -h | --help )           usage<br>                                exit<br>                                ;;<br>        * )                     usage<br>                                exit 1<br>    esac<br>    shift<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Test code to verify <span class="hljs-built_in">command</span> line processing</span><br><br>if [ &quot;$interactive&quot; = &quot;1&quot; ]; then<br>response=<br><br>    echo -n &quot;Enter name of output file [$filename] &gt; &quot;<br>    read response<br>    if [ -n &quot;$response&quot; ]; then<br>        filename=$response<br>    fi<br><br>    if [ -f $filename ]; then<br>        echo -n &quot;Output file exists. Overwrite? (y/n) &gt; &quot;<br>        read response<br>        if [ &quot;$response&quot; != &quot;y&quot; ]; then<br>            echo &quot;Exiting program.&quot;<br>            exit 1<br>        fi<br>    fi<br>fi<br>echo &quot;output file = $filename&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Write page (comment out until testing is complete)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">write_page &gt; <span class="hljs-variable">$filename</span></span><br></code></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><h3 id="处理位置参数"><a href="#处理位置参数" class="headerlink" title="处理位置参数"></a>处理位置参数</h3><p>for 命令可以处理命令行参数列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>for i in &quot;$@&quot;; do<br>    echo $i<br>done<br></code></pre></td></tr></table></figure><h3 id="处理文件列表"><a href="#处理文件列表" class="headerlink" title="处理文件列表"></a>处理文件列表</h3><p>比较两个文件夹中的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cmp_dir - program to compare two directories</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Check <span class="hljs-keyword">for</span> required arguments</span><br>if [ $# -ne 2 ]; then<br>    echo &quot;usage: $0 directory_1 directory_2&quot; 1&gt;&amp;2<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Make sure both arguments are directories</span><br>if [ ! -d $1 ]; then<br>    echo &quot;$1 is not a directory!&quot; 1&gt;&amp;2<br>    exit 1<br>fi<br><br>if [ ! -d $2 ]; then<br>    echo &quot;$2 is not a directory!&quot; 1&gt;&amp;2<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Process each file <span class="hljs-keyword">in</span> directory_1, comparing it to directory_2</span><br>missing=0<br>for filename in $1/*; do<br>    fn=$(basename &quot;$filename&quot;)<br>    if [ -f &quot;$filename&quot; ]; then<br>        if [ ! -f &quot;$2/$fn&quot; ]; then<br>            echo &quot;$fn is missing from $2&quot;<br>            missing=$((missing + 1))<br>        fi<br>    fi<br>done<br>echo &quot;$missing files missing&quot;<br></code></pre></td></tr></table></figure><h3 id="home-space"><a href="#home-space" class="headerlink" title="home_space"></a>home_space</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">home_space()<br>&#123;<br>    echo &quot;&lt;h2&gt;Home directory space by user&lt;/h2&gt;&quot;<br>    echo &quot;&lt;pre&gt;&quot;<br>    format=&quot;%8s%10s%10s   %-s\n&quot;<br>    printf &quot;$format&quot; &quot;Dirs&quot; &quot;Files&quot; &quot;Blocks&quot; &quot;Directory&quot;<br>    printf &quot;$format&quot; &quot;----&quot; &quot;-----&quot; &quot;------&quot; &quot;---------&quot;<br>    if [ $(id -u) = &quot;0&quot; ]; then<br>        dir_list=&quot;/home/*&quot;<br>    else<br>        dir_list=$HOME<br>    fi<br>    for home_dir in $dir_list; do<br>        total_dirs=$(find $home_dir -type d | wc -l)<br>        total_files=$(find $home_dir -type f | wc -l)<br>        total_blocks=$(du -s $home_dir)<br>        printf &quot;$format&quot; $total_dirs $total_files $total_blocks<br>    done<br>    echo &quot;&lt;/pre&gt;&quot;<br><br>&#125;   # end of home_space<br></code></pre></td></tr></table></figure><p>使用 printf 格式化输出，参考：</p><ul><li><p><a href="http://www.gnu.org/software/gawk/manual/html_node/Control-Letters.html#Control-Letters">GNU Awk User’s Guide - Control Letters</a></p></li><li><p><a href="http://www.gnu.org/software/gawk/manual/html_node/Format-Modifiers.html#Format-Modifiers">GNU Awk User’s Guide - Format Modifiers</a></p></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h3><p>提高 shell 脚本的鲁棒性，处理 exit status，否则会发生意想不到的事情。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd $some_directory<br>rm *<br></code></pre></td></tr></table></figure><p>若 $some_directory 不存在，进入指定目录失败，则删除当前工作文件夹下的所有文件，-_-</p><h3 id="clean-up-功能"><a href="#clean-up-功能" class="headerlink" title="clean_up 功能"></a>clean_up 功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program to <span class="hljs-built_in">print</span> a text file with headers and footers</span><br><br>TEMP_FILE=/tmp/printfile.txt<br><br>clean_up() &#123;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Perform program <span class="hljs-built_in">exit</span> housekeeping</span><br>rm $TEMP_FILE<br>exit<br>&#125;<br><br>trap clean_up SIGHUP SIGINT SIGTERM<br><br>pr $1 &gt; $TEMP_FILE<br><br>echo -n &quot;Print file? [y/n]: &quot;<br>read<br>if [ &quot;$REPLY&quot; = &quot;y&quot; ]; then<br>lpr $TEMP_FILE<br>fi<br>clean_up<br></code></pre></td></tr></table></figure><p>结束一个脚本时，应清理一些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Program to <span class="hljs-built_in">print</span> a text file with headers and footers</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Usage: printfile file</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Create a temporary file name that gives preference</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">to the user<span class="hljs-string">&#x27;s local tmp directory and has a name</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">that is resistant to &quot;temp race attacks&quot;</span></span><br><br>if [ -d &quot;~/tmp&quot; ]; then<br>TEMP_DIR=~/tmp<br>else<br>TEMP_DIR=/tmp<br>fi<br>TEMP_FILE=$TEMP_DIR/printfile.$$.$RANDOM<br>PROGNAME=$(basename $0)<br><br>usage() &#123;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Display usage message on standard error</span></span><br>echo &quot;Usage: $PROGNAME file&quot; 1&gt;&amp;2<br>&#125;<br><br>clean_up() &#123;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Perform program exit housekeeping</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Optionally accepts an exit status</span></span><br>rm -f $TEMP_FILE<br>exit $1<br>&#125;<br><br>error_exit() &#123;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Display error message and exit</span></span><br>echo &quot;$&#123;PROGNAME&#125;: $&#123;1:-&quot;Unknown Error&quot;&#125;&quot; 1&gt;&amp;2<br>clean_up 1<br>&#125;<br><br>trap clean_up SIGHUP SIGINT SIGTERM<br><br>if [ $# != &quot;1&quot; ]; then<br>usage<br>error_exit &quot;one file to print must be specified&quot;<br>fi<br>if [ ! -f &quot;$1&quot; ]; then<br>error_exit &quot;file $1 cannot be read&quot;<br>fi<br><br>pr $1 &gt; $TEMP_FILE || error_exit &quot;cannot format file&quot;<br><br>echo -n &quot;Print file? [y/n]: &quot;<br>read<br>if [ &quot;$REPLY&quot; = &quot;y&quot; ]; then<br>lpr $TEMP_FILE || error_exit &quot;cannot print file&quot;<br>fi<br>clean_up<br></code></pre></td></tr></table></figure><h3 id="安全的临时文件"><a href="#安全的临时文件" class="headerlink" title="安全的临时文件"></a>安全的临时文件</h3><p><code>/tmp</code> 会有很多程序放置临时文件在里面，文件名重复会覆盖内容（可预测，predictable）；</p><p>建议创建本地临时文件夹 <code>~/tmp</code>，即用户目录下的子目录；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">TEMP_FILE=$TEMP_DIR/printfile.$$.$RANDOM<br></code></pre></td></tr></table></figure><ul><li>$TEMP_DIR 是  <code>/tmp</code> 或 <code>~/tmp</code></li><li>printfile 是应用程序的名字</li><li>$$ 是 shell 变量，将 process id(pid) 嵌入文件名</li><li>$RANDOM 是追加随机数</li></ul><p>这样就生成了唯一且不易重复的文件名，例如 <code>tomcat</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">tomcat.5141431142496395497.9000<br>tomcat.6486338835837423954.9000<br>tomcat.8674130370990688323.9000<br>tomcat-docbase.2197772788338189182.9000<br>tomcat-docbase.30706145223021005.9000<br><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://linuxcommand.org/lc3_writing_shell_scripts.php">http://linuxcommand.org/lc3_writing_shell_scripts.php</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>OPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 主从集群及自启动配置</title>
    <link href="/2020-04-03-redis-cluster-masterandslave/"/>
    <url>/2020-04-03-redis-cluster-masterandslave/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 CentOS 7.6 环境中搭建 Redis 主从集群，并使用 systemctl 配置集群自启动。</p><span id="more"></span><h2 id="Redis-下载安装"><a href="#Redis-下载安装" class="headerlink" title="Redis 下载安装"></a>Redis 下载安装</h2><p>采用源码编译安装的方式，下载源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://download.redis.io/releases/redis-5.0.7.tar.gz -P /usr/local/src<br></code></pre></td></tr></table></figure><p>进入到下载目录，解压下载的源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/local/src/<br>tar -zxvf redis-5.0.7.tar.gz<br></code></pre></td></tr></table></figure><p>安装 gcc 编译器，使用 make 编译安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis-5.0.7<br>yum install gcc-c++<br>make MALLOC=libc install<br></code></pre></td></tr></table></figure><p>完成上面步骤之后，Redis 相关 bin 文件就已经安装到 <code>/usr/bin/local/bin</code> 目录下了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-benchmark<br>redis-check-aof<br>redis-check-rdb<br>redis-cli<br>redis-sentinel -&gt; redis-server<br>redis-server<br></code></pre></td></tr></table></figure><p>启动 Redis 服务器，使用默认的配置文件 <code>/usr/local/src/redis-5.0.7/redis.conf</code>，也可指定配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/redis-server ./redis.conf<br></code></pre></td></tr></table></figure><p>使用客户端连接 Redis Server，测试是否启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/redis-cli -h 127.0.0.1 -p 6379 -a password<br></code></pre></td></tr></table></figure><p>有时候会有中文乱码，要在 redis-cli 后面加上 <code>--raw</code>。</p><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p>在本地启动多个 Redis Server 实例，使用不同的配置文件，占用不同的端口。</p><h3 id="配置多个-Redis-Server-实例"><a href="#配置多个-Redis-Server-实例" class="headerlink" title="配置多个 Redis Server 实例"></a>配置多个 Redis Server 实例</h3><p>在 <code>/usr/local/ </code>下建立 <code>redis-cluster</code> 文件夹，再建子文件夹 <code>7001-7006</code> 以及 <code>700*/data/</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /usr/local/redis-cluster/7000/data \<br>  /usr/local/redis-cluster/7001/data \<br>  /usr/local/redis-cluster/7002/data \<br>  /usr/local/redis-cluster/7003/data \ <br>  /usr/local/redis-cluster/7004/data \ <br>  /usr/local/redis-cluster/7005/data<br></code></pre></td></tr></table></figure><p>在各实例位置中新建 <code>redis.conf</code>，并配置如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata">port 700*<br>bind 0.0.0.0<br><span class="hljs-keyword">dir</span> /usr/<span class="hljs-keyword">local</span>/redis-<span class="hljs-keyword">cluster</span>/700*/data/<br><span class="hljs-keyword">cluster</span>-enabled yes<br><span class="hljs-keyword">cluster</span>-config-<span class="hljs-keyword">file</span> nodes-700*.<span class="hljs-keyword">conf</span><br><span class="hljs-keyword">cluster</span>-node-timeout 5000<br><span class="hljs-keyword">cluster</span>-announce-ip 当前集群IP<br>appendonly yes<br>daemonize yes<br></code></pre></td></tr></table></figure><h3 id="启动-Server-实例"><a href="#启动-Server-实例" class="headerlink" title="启动 Server 实例"></a>启动 Server 实例</h3><p>启动各 Server 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/redis-server /usr/local/redis-cluster/700*/redis.conf<br></code></pre></td></tr></table></figure><p>或使用自定义脚本 <code>/var/tmp/redis-cluster.sh</code>，一次性启动多个实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>/usr/local/bin/redis-server /usr/local/redis-cluster/7000/redis.conf<br>/usr/local/bin/redis-server /usr/local/redis-cluster/7001/redis.conf<br>/usr/local/bin/redis-server /usr/local/redis-cluster/7002/redis.conf<br>/usr/local/bin/redis-server /usr/local/redis-cluster/7003/redis.conf<br>/usr/local/bin/redis-server /usr/local/redis-cluster/7004/redis.conf<br>/usr/local/bin/redis-server /usr/local/redis-cluster/7005/redis.conf<br></code></pre></td></tr></table></figure><p>添加执行权限并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x redis-cluster.sh<br>./redis-cluster.sh<br></code></pre></td></tr></table></figure><p>查看各实例进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@bbc106 redis-cluster]<span class="hljs-comment"># ps -ef | grep redis</span><br>6446     1  0 03:13 /usr/local/bin/redis-server 0.0.0.0:7000 [cluster]<br>6553     1  0 03:14 /usr/local/bin/redis-server 0.0.0.0:7001 [cluster]<br>6577     1  0 03:14 /usr/local/bin/redis-server 0.0.0.0:7002 [cluster]<br>6585     1  0 03:14 /usr/local/bin/redis-server 0.0.0.0:7003 [cluster]<br>6595     1  0 03:14 /usr/local/bin/redis-server 0.0.0.0:7004 [cluster]<br>6605     1  0 03:14 /usr/local/bin/redis-server 0.0.0.0:7005 [cluster]<br></code></pre></td></tr></table></figure><h3 id="建立集群"><a href="#建立集群" class="headerlink" title="建立集群"></a>建立集群</h3><p>使用 <code>/usr/local/bin/redis-cli</code> 建立集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1<br></code></pre></td></tr></table></figure><p>看到如下 log：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; Performing <span class="hljs-built_in">hash</span> slots allocation on 6 nodes...<br>Master[0] -&gt; Slots 0 - 5460<br>Master[1] -&gt; Slots 5461 - 10922<br>Master[2] -&gt; Slots 10923 - 16383<br>...<br>[OK] All 16384 slots covered.<br></code></pre></td></tr></table></figure><h3 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h3><p>客户端连接任一节点，并使用 <code>cluster nodes</code> 或 <code>cluster info</code> 查看集群信息：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[root@bbc106 local]</span># /usr/local/bin/redis-cli -h <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> -p <span class="hljs-number">7000</span><br><span class="hljs-number">127.0.0.1:7000</span>&gt; cluster nodes<br></code></pre></td></tr></table></figure><p>集群信息如下图：</p><p><img src="https://blogres.blackist.org/202004032345_653.png"></p><ul><li>119.3.104.4:7000：节点的 IP 和 Port</li><li>master &#x2F; slave：节点在集群中的角色，主节点 &#x2F; 从节点</li><li>0-5460 &#x2F; 10923-16383：节点分配到的槽数</li></ul><h2 id="集群自启动"><a href="#集群自启动" class="headerlink" title="集群自启动"></a>集群自启动</h2><p>使用 systemd 配置集群自启动，首先添加 systemd unit service 配置文件 <code>/usr/lib/systemd/system/redis-cluster.service</code>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Redis <span class="hljs-number">5.0</span> Cluster Service<br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=forking<br><span class="hljs-attr">ExecStart</span>=/usr/local/redis-cluster/redis-cluster.sh<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=default.target<br></code></pre></td></tr></table></figure><ul><li>Description：描述信息</li><li>After：启动顺序</li><li>Type：进程启动类型</li><li>ExecStart：启动脚本</li></ul><p>其中 Redis 进程启动类型和 redis 服务的启动方式有关：</p><table><thead><tr><th><code>redis.conf</code></th><th><code>redis.service</code></th></tr></thead><tbody><tr><td><code>daemonize no</code> <code>supervised systemd</code></td><td><code>Type=notify</code></td></tr><tr><td><code>daemonize no</code> <code>supervised no</code></td><td><code>Type=exec</code></td></tr><tr><td><code>daemonize yes</code> <code>supervised no</code></td><td><code>Type=forking</code></td></tr></tbody></table><p>配置开机启动，首先在 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 下建立 redis-cluster.service 的软链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s /usr/lib/systemd/system/redis-cluster.service<br></code></pre></td></tr></table></figure><p>重新加载 systemd 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>启动 redis 集群服务并设置 开机启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start redis-cluster<br>sudo systemctl <span class="hljs-built_in">enable</span> redis-cluster<br></code></pre></td></tr></table></figure><p>重启服务器测试集群自启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl reboot<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">https://www.freedesktop.org/software/systemd/man/systemd.service.html</a></p><p><a href="https://gist.github.com/nexdrew/14392032ed6f105474a3">https://gist.github.com/nexdrew/14392032ed6f105474a3</a></p><p><a href="https://gist.github.com/hackedunit/a53f0b5376b3772d278078f686b04d38">https://gist.github.com/hackedunit/a53f0b5376b3772d278078f686b04d38</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring源码（一）导入</title>
    <link href="/2020-02-23-java-spring-code-init/"/>
    <url>/2020-02-23-java-spring-code-init/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>古希腊语言中，学习一词即为闲暇之意，闲下来了就去学习是一种很好的状态。趁着 2020 年春节假期，过一把闻名已久的 Spring 源码之瘾。</p><span id="more"></span><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><h3 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h3><p>阅读源码的关键资料，当然是官方文档和官方源代码：</p><p>Spring Framework 官网文档：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html</a></p><p><img src="https://blogres.blackist.org/202002242323_560.png"></p><p>Spring Framework 开放源代码：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><p><img src="https://blogres.blackist.org/202002242324_759.png"></p><h3 id="下载过程"><a href="#下载过程" class="headerlink" title="下载过程"></a>下载过程</h3><p>Windows 10 安装 Git，从 github 克隆的话比较慢，我借助<a href="https://gitee.com/">码云</a>从 github 导出了一份，再从码云上拉取，速度好极了。码云还提供手动同步 github 源码的功能，我搬运的一份：<a href="https://gitee.com/blackist/spring-framework">https://gitee.com/blackist/spring-framework</a></p><p><img src="https://blogres.blackist.org/202002242326_983.png"></p><p>克隆下来的源码只有 master 分支，为阅读指定版本的源码 5.0.x，需要拉取指定分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin 5.0.x:5.0.x<br></code></pre></td></tr></table></figure><p>即拉取远程的 5.0.x 到本地，然后手动切换至 5.0.x 再导入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout 5.0.x<br></code></pre></td></tr></table></figure><h2 id="源码导入"><a href="#源码导入" class="headerlink" title="源码导入"></a>源码导入</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li>java version “1.8.0_162”</li><li>IntelliJ IDEA 2018.3</li></ul><p>源码工程是基于 Gradle 构建的， gradle 版本由源码配置文件指定。</p><h3 id="IDEA-导入源码"><a href="#IDEA-导入源码" class="headerlink" title="IDEA 导入源码"></a>IDEA 导入源码</h3><p>首先执行 gradlew 编译任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gradlew.bat cleanIdea :spring-oxm:compileTestJava<br></code></pre></td></tr></table></figure><p><img src="https://blogres.blackist.org/202002271544_78.png"></p><p>Import project -&gt; Import project from external model (选择 gradle) -&gt; Next … Finish</p><p>IDEA 会根据 .&#x2F;gradle&#x2F;wrapper&#x2F;gradle-wrapper.properties 中指定版本下载 gradle，gradle 路径为 {user}&#x2F;.gradle&#x2F;wrapper&#x2F;dists，各版本的 gradle 都会在这里（搞安卓开发的小伙伴有没有很熟悉）。</p><p><img src="https://blogres.blackist.org/202002242345_754.png"></p><p>等待 gradle 构建完成。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><h3 id="新建-Gradle-模块"><a href="#新建-Gradle-模块" class="headerlink" title="新建 Gradle 模块"></a>新建 Gradle 模块</h3><p>为进行简洁的测试，新建一个 Gradle 模块，在模块中依赖 spring-beans、spring-aop 等模块，可更直观的阅读源码。</p><p>右键项目 -&gt; New -&gt; Module，</p><p><img src="https://blogres.blackist.org/202002242352_987.png"></p><p>选择 Gradle，</p><p><img src="https://blogres.blackist.org/202002242353_606.png"></p><p>ArtifactId 填写自定义名称 code-quiz 等等，Module Name 也会默认是 code-quiz，Finish。</p><p><img src="https://blogres.blackist.org/202002242356_487.png"></p><p>新建模块的结构如上，这个 build.gradle 就类似 maven 的 pom.xml，是此模块的配置文件。在 dependencies 中依赖 spring-core、spring-beans，就可以实现 IoC了。当然，也可以直接依赖 spring-context 实现 IoC，但我从最基本的模块开始学习。</p><h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><p>新建 java bean，通过 xml 文件配置 bean，并新建工厂获取 bean。</p><p><img src="https://blogres.blackist.org/202002251016_651.png"></p><p>资源文件 quiz-bean.xml 放在 resources 目录下，并配置 QuizBean 的信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;ISO-8859-1&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">                       https://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;quizBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bean.QuizBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建 XmlFactoryBeanTests 进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlBeanFactoryTests</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-type">BeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanFactory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;bean/quiz-beans.xml&quot;</span>));<br><span class="hljs-type">QuizBean</span> <span class="hljs-variable">quizBean</span> <span class="hljs-operator">=</span> (QuizBean) factory.getBean(<span class="hljs-string">&quot;quizBean&quot;</span>);<br>System.out.println(quizBean.getName());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h3><p>运行 XmlBeanFactoryTests 中的 main 函数，会出现如下编译错误：</p><p><img src="https://blogres.blackist.org/202002231936_202.png"></p><p>原因：为了避免第三方 class 冲突，spring 把最新的 cglib 和 objenesis 重新打包 jar 并没有放在源码里。</p><p><img src="https://blogres.blackist.org/202002231410_342.png"></p><p>解决办法：在命令行中执行 gradle 的构建任务 objenesisRepackJar 和 cglibRepackJar。但需要先配置 gradle 环境变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gradle objenesisRepackJar cglibRepackJar<br></code></pre></td></tr></table></figure><h4 id="gradle-配置"><a href="#gradle-配置" class="headerlink" title="gradle 配置"></a>gradle 配置</h4><p>配置 gradle 环境变量类似于 maven，就是将 gradle 的下载路径配置到系统的环境变量，但不同的 gradle 工程往往 gradle 版本不一样，因此配置固定版本的 gradle 到环境变量会给其他项目带来不便。</p><p>gradle 项目构建时，一般会生成一个 gradlew 的 bash 脚本文件，它会根据项目所需的 gradle 去默认目录使用 gradle 命令，因此直接执行如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gradlew objenesisRepackJar cglibRepackJar<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://blogres.blackist.org/202002251030_268.png"></p><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ol><li>执行 gradlew 命令时，提示 ERROR: JAVA_HOME is set to an invalid directory: C:\Program Files\Java\jdk1.8.0_ 131，原因是 JDK 路径确实有问题，我安装过两个 JDK，以前的版本删除了，但环境变量没改，给IU改几颗。</li><li>main 函数中工厂基于 xml 文件构建，代码运行时提示找不到 xml，以为路径问题，反复折腾无效，偶然间重启电脑解决了问题，估计是 idea 工程缓存问题。</li></ol><p>慢慢读源码啦。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/a704397849/article/details/102760379">https://blog.csdn.net/a704397849/article/details/102760379</a></p><p><a href="https://blog.csdn.net/u010999809/article/details/94293328">https://blog.csdn.net/u010999809/article/details/94293328</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>告别 2019 拥抱 2020 - 还愿</title>
    <link href="/2020-01-24-life-new-year-2020/"/>
    <url>/2020-01-24-life-new-year-2020/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>祝每一个人，新年快乐！</p><span id="more"></span><h2 id="新年好"><a href="#新年好" class="headerlink" title="新年好"></a>新年好</h2><p>新年对每个国人来说都是重要的节日，亲人团聚，既是对过去一年辛勤劳动的慰劳，也是对未来一年追梦行动的鼓舞。</p><p>回老家，见亲戚，吃饺子，每一景都带着情，因为无论如何这里都是梦想开始的地方，回到温暖的港湾，休息疲惫的身心，充充电才能继续向前。</p><p><img src="https://blogres.blackist.org/202001241951_702.png"></p><p>在2019年的元旦，我做了2018年终总结，也立下了新年目标 <a href="https://blackist.org/2018/12/31/life-summary-2018/%EF%BC%8C%E6%80%BB%E7%BB%93%E4%B8%8B%E8%BF%87%E5%8E%BB%E4%B8%80%E5%B9%B4%E7%9A%84%E5%8A%AA%E5%8A%9B%E3%80%82">https://blackist.org/2018/12/31/life-summary-2018/，总结下过去一年的努力。</a></p><h2 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h2><p>学硕毕业要求一级期刊，或是发二级期刊加上大论文盲审均分80。为了稳妥，我一直努力发一级期刊，从5月份开始阅读论文（其实比较晚了），6月份动笔，7月份有初稿，8月份投稿。</p><p>在阅读一些文献后，我开始“捏造”创新点，然而好多时候这些惊现出来的创新点都已经存在。一次次挫败后，我脚踏实地开始系统地阅读论文，确定要研究的具体问题，熟知已有的解决方法。与其说这是创新的过程，不如说是学习过程，将学习到的方法应用在自己面对的问题上，感谢对象给我的启发。</p><p>论文的书写就像跳远运动，如果不规范，跳的再远也要走回来重新跳。初稿把论文写的长篇大论，在室友的帮助下，删减修改润色，总之憋论文太难了，谢谢室友的一路匡扶。</p><p>最终，因为自身学术水平欠缺，小论文被一级期刊退稿，遂投了校报期刊。接着就只能期望大论文盲审均分80了，没有提前规划大论文进度，送审前熬夜赶论文熬到肚子难受。在寒假中，收到了两个好消息：</p><ul><li>小论文被校报收录；</li><li>大论文盲审均分85.1；</li></ul><p>这没什么了不起，但这是我的目标呀。</p><p>写论文让我深度学习，那种研究和创造的感觉还是很好的。有一次去有赞的 OpenDay，中台架构师提到，一些负载均衡的算法就是从国外论文中学习的，实现论文中的方法往往可以得到不错的结果。我也暗示自己，系统的研究性学习对个人提升帮助很大。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>一个秋招，诉不完的苦，流不完的泪啊。年终，实验室的小伙伴都找到了不错的工作，但个中辛酸可以写写一本 传记了。</p><p>今年找工作最痛苦的两句话：互联网进入寒冬，算法很重要。第一次电话面试哈啰，一问三不知；最糟糕的是京东现场面试，什么 HTTP 缓存的，当时根本没准备过，却自我感觉无比良好，信了面试官的鬼话，我们会联系你的，然而杳无音讯。吃一堑长一智，认真复习后面试有赞，一上午三面，过了一段时间收到意向书，斩获秋招第一个offer，却没想到也是最后一个中意的offer。</p><p>后来听了一些宣讲会，做了好些笔试，面了好多家公司，但收到面试的没多少，不过一直保持学习的状态也有所收获。</p><p>明年开春就去有赞领薪水了，希望自己成为一个专业而优秀的IT开发人员。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>认识到读书很重要是从学 Java 开始的，秋招之前复习时感觉看网上的博客很难建立知识体系，然后开始有计划地使用书本学习。在京东 618 活动的时候，买了《Java虚拟机》、《多线程编程核心技术》、《设计模式》等等 IT 技术书籍，然后暑假7、8月份的每天都会早起看《Java程序员修炼之道》，看的进度较慢，但每天都有所收获。书上学到的知识几乎时常被用到，室友问问题时也用得上，这种及时的反馈让我动力十足。</p><p>再后来，是白岩松和董卿，我很喜爱的两个主持人。时常在抖音上看到他们，不需要讲道理来说明读书多重要，看他们的谈吐就好了。粗缯大布裹生涯，腹有诗书气自华，那种稳重温和的气质，优雅端庄的举止，足以令人心生敬意。读《人性的弱点》，戴尔·卡耐基让我学习到与人相交很重要的一些东西，反复看反复实践，内化的东西会潜移默化地影响我们的行动。这本书也让我认识到，一些以前自认为是个性的做法，其实真的不对，我确定了，善读书可以医愚。</p><p>然后是博雅教育，下半年开始听吴军老师的《硅谷来信》，他不会教你怎么调试 bug，他会跟我们交流葡萄酒的酿制过程，去阿里斯加时拍照要注意什么，有的地方米其林餐厅提前两个月才能预约上，奢侈品的由来，国民特性…这让我感受到了技术之外，更丰富的生活，让我知道努力学习和工作是为了什么。吴军老师也时常提到博雅教育，我尚不能给出定义，但更倾向于用“通才”来指导自己，引用 Rober Heinlein（罗伯特·海因莱茵）的一句话：</p><blockquote><p>一个人应该能够换尿布，策划战争，杀猪，开船，设计房子，写十四行诗，结算账户，砌墙，接脱臼的骨头，安慰濒死的人，服从命令，发布命令，携手合作，独立行动，解数学方程，分析新问题，铲粪，电脑编程，做出可口的饭，善打架，勇敢地死去。专业是昆虫学。</p></blockquote><p>这些是今年我对读书和学习的思考中的一部分。</p><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p>最重要的莫过于和女朋友发现了一条可以漫步人生的路。</p><p>以前我总沉迷于代码和手头的任务，凡事大抵会用我很忙，在忙正事，等我忙完再来帮你的方式来搪塞她。我总是忙着一个人成长，停不下的脚步让自己时感疲劳，也忽略了她的感受，以为一个人不顾其他，努力进步就是为两个人好。读过一些书，交过一些人，我发现努力拼搏是一个人的事情，不是两个人的事情，互相关爱才是，哪怕只是时常问候一下。</p><p>我学着多花时间陪伴，和她肩并肩面对问题，然后手牵手庆祝每一个值得庆祝的时刻。她也理解我花时间读书，互相交流心得，分享书籍，寒假伊始完成了两本读书笔记。我明确感受到，这是一条共同进步的路，天朗气清。</p><p>感谢相遇的人，感谢读过的书，感谢陪伴。</p><h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><p>感受到父母的需要，亲情中需要关怀，一条围巾，几双洗护手套，一件羽绒马甲。没有天经地义，只有互相珍惜，即使吵吵闹闹，也不离不弃，护你周全，这就是家人之间的爱。大步向前走的时候，回首看得到家的方向，那么向前的脚步就会更坚定，因为它是心底真实的力量。</p><h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><p>收获了一岁，和10斤体重。应该说今年一个苹果开启了我追求健康的信念。</p><p>大概6月份左右，吃苹果牙龈出血，我开始关注牙齿健康。了解到牙结石在作祟，就在美团上找到预约了一家牙医所洗牙。洗牙的时候发现了自己的智齿，而且是需要拔除的那种情况，这让一向自信没有智齿的我有些吃惊。</p><p>洗牙后配合电动牙刷，采用牙医建议的“巴氏刷牙法”，牙龈出血问题得到根治，这可是困扰我多年的问题啊，太厉害了。至于智齿，因为论文和秋招的原因，我迟迟没有去医院，这也导致了后来的牙龈发炎。以前牙龈发炎的时候我以为是普通炎症，这次我明确地认知到这是智齿引起的，所以炎症一好，我毫不犹豫地去口腔医院挂了专家门诊。之后三五天都和豆腐为伴，幸好对象陪着，偶尔可以吃几口荤的。</p><p>这期间还有一个意外惊喜，就是一点皮肤问题，从初中就跟随我，今年我意识到这是一个麻烦的健康问题，特意跑去皮肤医院挂号。没成想医生药到病除，10多年的顽疾，也就2周时间给治愈了。Oh My God！真是萨普赖斯。</p><p>感谢2019年那个为了健康愿意四处奔波的自己，感谢陪我奔波的她，健康最重要嘛。</p><h2 id="新年前两天"><a href="#新年前两天" class="headerlink" title="新年前两天"></a>新年前两天</h2><p>按理说，假期开始的第一天不应该蹦蹦跳跳地回村吗，然后开开心心地过年吗。可曾想我遇到了一些不顺心，为了解决它们，我花了几天时间，直到大年三十下午，依然在奔波。解决了最后一个问题，如释重负，像是还清欠款一般的感觉。</p><p>有些事情虽然可以放到年后解决，但就地解决并送上一份新年祝福，放松了自己，温暖了别人，何乐而不为呢。</p><p>虽然工作由安卓转回了 java 后端，但今年整体上比较满意。</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>年终总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长之路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从楚门世界看人性的弱点</title>
    <link href="/2019-12-12-life-file-%E6%A5%9A%E9%97%A8%E4%B8%96%E7%95%8C/"/>
    <url>/2019-12-12-life-file-%E6%A5%9A%E9%97%A8%E4%B8%96%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在读《人性的弱点》，看了《楚门世界》，说点自己的感悟。</p><span id="more"></span><h2 id="楚门世界"><a href="#楚门世界" class="headerlink" title="楚门世界"></a>楚门世界</h2><p>首先说说楚门，这个小阿仁从出生起，就生活在一个由大导演基斯督虚构的“桃园岛”中。阿仁的生活就是一个旷世的真人秀节目，出生、成长、衣食住行、初吻……全世界持续关注这个小伙子长达 30 年，他的人生看起来一直都是这么“理想”。</p><p><img src="https://blogres.blackist.org/201912121112_115.png"></p><p>基斯督认为这个理想国远远好于现实世界，他高高站在太阴室，想将阿仁禁锢在他的杰作——桃园岛中。当小阿仁想跟哥伦布一样去探索世界的时候，老师拿着世界地图告诉他世界已经没有什么秘密，被恶狗恐吓，父亲“被淹死”，这一切都是为了阻断阿仁对未知世界的向往。</p><p>但是，人生最迷人的地方就在于未知。当施维亚闯进阿仁的世界，她让阿仁知道了什么是爱，施维亚想帮阿仁逃脱这个虚拟的桃源，虽然她最初失败了，被踢出了剧组，但爱的种子已在阿仁心中萌芽。因为爱，阿仁似乎体会到了真挚的感情；因为爱，阿仁心中重新燃起了向往与追求的信念——寻找施维亚。</p><p>阿仁也慢慢发现他的世界总有那么一些不寻常，他一次次验证了他所怀疑的。终于，他在心底默默地做出了逃离的决定。在一个平静的夜晚，他逃出地下室，钻出草坪，跑去一直畏惧的“海洋”，开走一艘帆船，去探索那个儿时向往的未知世界，去寻找他的施维亚。</p><p>艳阳之下，海水之上，阿仁坐在帆船上，他舒心的笑容，和肖申克逃出牢狱坐在车上的笑容一样迷人。这就是人类心底对自由的向往。</p><p>到这里，电影进入高潮，大导演基斯督依然想禁锢阿仁，于是在海洋上“兴风作浪”，但这点风浪是阻挡不住他的。全世界的观众眉头紧皱、双手紧握，祈祷他能离开这里，这里我觉得非常棒，彷佛触及到了全人类的本性——向往自由。当“十级风浪”拍打在阿仁的身体上，他向太阴室宣战，“想要阻止我，kill me！”。</p><p><img src="https://blogres.blackist.org/201912121113_292.png"></p><p>最后，阿仁逃出了桃园，这部旷世的真人秀落下帷幕，人类成功了。</p><p>电影的最后，两个保安看着电视吃着披萨，为楚门的成功欢呼以后，说到“看看还有没有其他节目”。这一幕颇耐人寻味，彷佛楚门的人生，对于旁人真的仅仅只是一部剧而已。就如《人性的弱点》中所讲的，他们关切自己轻微的头痛，只怕比关心你我的死讯还要多。所以，平安快乐的原则之一——<strong>凡事尽力而为，然后撑起伞，避开非难之雨</strong>。</p><h2 id="人性的弱点"><a href="#人性的弱点" class="headerlink" title="人性的弱点"></a>人性的弱点</h2><p>《人性的弱点》这本书总能在不经意间戳中内心，让我认识到生活和交往的本质，给迷茫的内心带来一些指导。我正在实践书中给出的一个方法——操演心灵。分享给你。</p><p>由三方面操演心灵：<strong>默默地为某人做一件好事</strong>。再起码<strong>做两件我不想做的事</strong>，照威廉詹姆斯所说的，只是为了让心灵演练，不致怠惰。</p><p>为他人做一件事，是为了不要把太多注意放在自己身上；做自己不想做的事情，于我而言，是克服拖延症，比如写论文、读书等。操演心灵的方法论有助于主动了解他人、培养勤奋的心态，我采用富兰克林的方法，用四周时间来培养这个习惯，当天做到了就打个勾。</p><p><img src="https://blogres.blackist.org/201912121327_992.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从哥伦布航海，到麦哲伦环球，到阿姆斯特朗登月，再到火星2号探索火星，人类最厉害的就是对未知向往，和那种追求的精神。愿你我心灵不懈怠。</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长之路</tag>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25 岁之前赶走 25 件事情</title>
    <link href="/2019-11-28-life-25thingsToLetGoBefore25/"/>
    <url>/2019-11-28-life-25thingsToLetGoBefore25/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>正是因为不完美，才需要追求完美。即使不完美，也要从自己身上赶走 25 件事情。</p><span id="more"></span><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>一些人，他们让你质疑自己，质疑你的自我价值，质疑你作为一个人的身份。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>一些恐惧，恐惧孤独一生，恐惧难觅真爱，恐惧配不上一个人。</p><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>一些观念，这些东西你本应得，这些事情我不愿做。</p><h2 id="4"><a href="#4" class="headerlink" title="4 ."></a>4 .</h2><p>一些人，他们尚未回报你的爱，尤其是那些永远不会的 。</p><h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><p>一些不愿意，不愿努力提高自己，你内心认为现今已不在大学，成绩并不取决于此。</p><h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><p>一个想法，寻求他人的帮助，这让你变得羸弱。</p><h2 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h2><p>认为自己“不像她那样”，因此把她当了朋友。也许，正是因为不一样才相互吸引吧。</p><h2 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h2><p>同上</p><h2 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h2><p>交浅言深，没有花时间深入了解，就把一个人当密友。</p><h2 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h2><p>对新事物焦虑，因为它们不像你一直以来知道的那样。</p><h2 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h2><p>偏见，无知建立起来的偏见。</p><h2 id="12"><a href="#12" class="headerlink" title="12."></a>12.</h2><p>坏习惯，让你一想到便痛心疾首的坏习惯。</p><h2 id="13"><a href="#13" class="headerlink" title="13."></a>13.</h2><p>无法享受性爱，谈论太多会影响你的享受。</p><h2 id="14"><a href="#14" class="headerlink" title="14."></a>14.</h2><p>一个想法，世界上适合你的人只有一个。</p><h2 id="15"><a href="#15" class="headerlink" title="15."></a>15.</h2><p>最终让你蜕变的地方、人、环境。</p><h2 id="16"><a href="#16" class="headerlink" title="16."></a>16.</h2><p>荣耀，人怕出名猪怕壮。</p><h2 id="17"><a href="#17" class="headerlink" title="17."></a>17.</h2><p>你身上的标签，你不能全部认同。换言之，你命由你不由人。</p><h2 id="18"><a href="#18" class="headerlink" title="18."></a>18.</h2><p>一种想法，认为生活是公平的，更要命的是，你认为自己应得到公平。</p><h2 id="19"><a href="#19" class="headerlink" title="19."></a>19.</h2><p>压力，给自己大力施压，让你自己一直处于压力和紧张的状态。</p><h2 id="20"><a href="#20" class="headerlink" title="20."></a>20.</h2><p>停不下来，永远不让自己休息、停止、喘口气。</p><h2 id="21"><a href="#21" class="headerlink" title="21."></a>21.</h2><p>不爱惜自己，给自己压力让自己看起来很忙，而不是自己的身体。</p><h2 id="22"><a href="#22" class="headerlink" title="22."></a>22.</h2><p>一个想法，当你能够追求想要的，你仅仅等着接受它，却认为别人应先主动。那等待你的多半是错过和悔恨。</p><h2 id="23"><a href="#23" class="headerlink" title="23."></a>23.</h2><p>恐惧失败，你会失败，失败了又能怎样。</p><h2 id="24"><a href="#24" class="headerlink" title="24."></a>24.</h2><p>你学要追求完美，因为你不完美，也永远不会完美。</p><h2 id="25"><a href="#25" class="headerlink" title="25."></a>25.</h2><p>一个想法，20多岁的人总会有一条出路吧。船到桥头，你不捋是不直的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>翻译自 <a href="https://medium.com/@thoughtcatalog/25-toxic-things-you-need-to-let-go-of-by-25-db970d1f0224">Medium</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长之路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019 有赞测试沙龙</title>
    <link href="/2019-11-24-dev-salon-youzantest/"/>
    <url>/2019-11-24-dev-salon-youzantest/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>明年就要毕业了，三月份我会去有赞领薪水，这是职场的第一站。有赞在杭州每年会组织一次测试技术沙龙，今年是第三次，作为准有赞新青年，我去现场支持了一下。</p><span id="more"></span><h2 id="沙龙流程"><a href="#沙龙流程" class="headerlink" title="沙龙流程"></a>沙龙流程</h2><h3 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h3><p>祝幽老师作开场白，一如既往的幽默生动，一些高大上的词汇让我耳目一些【红海蓝海】【全链路压测】【大数据测试】【equals测试】。</p><p><img src="https://blogres.blackist.org/dev-201911241311-544.jpg"></p><p>第一次见祝幽老师是在有赞 OpenDay 的时候，他作为有赞首席架构师为我们简介了有赞的系统架构，让我中台一词多了几分认知。他讲话一直很风趣，讲起东西也是明明白白，看来程序员小哥确实是很好交往的人。</p><h3 id="第一场"><a href="#第一场" class="headerlink" title="第一场"></a>第一场</h3><p>持续交付负责人王娟，在有赞推动 DevOps 平台建设的人，这点我很是佩服，待会儿我讲下我的感悟。</p><p><img src="https://blogres.blackist.org/dev-201911241356-739.jpg"></p><h3 id="第五场"><a href="#第五场" class="headerlink" title="第五场"></a>第五场</h3><p>从个人受影响的角度，第五场分享干货满满，分享人是阿里 CBU 的测开专家靖远（花名）。其团队理念如下：</p><blockquote><p><strong>实时质量</strong> - 运行含测试，实时可反馈。</p></blockquote><p>双十一这种大促场景，促销页面每天会有两三百各版本，如果按照常规移动端测试流程，团队内十分钟左右测试一个页面，这也是很难完成的任务。阿里搭建了内部的基于规则的校验平台，运营人员输入校验规则对新版本页面进行测试，测试秒级完成。当然，这也依赖其团队背后的强大的移动测试软硬件平台。</p><p><img src="https://blogres.blackist.org/dev-201911241714-762.jpg"></p><h3 id="第二场"><a href="#第二场" class="headerlink" title="第二场"></a>第二场</h3><p>有赞的方金和是测试平台开发负责人，他介绍了测试平台工作流引擎、任务调度、与 Jenkins&#x2F;Docker 的集成。</p><p><img src="https://blogres.blackist.org/dev-201911241713-732.jpg"></p><h3 id="第三场"><a href="#第三场" class="headerlink" title="第三场"></a>第三场</h3><p>有赞的测试环境有1000台虚拟机+3000个容器，测试平台的运维也是个挑战，运维负责人王波分享了运维的经验。</p><p><img src="https://blogres.blackist.org/dev-201911241745-875.jpg"></p><h3 id="第四场"><a href="#第四场" class="headerlink" title="第四场"></a>第四场</h3><p>然后，酷家乐测试组风飞介绍了搜索服务和质量体系，让我印比较深刻的是数据订正。为了拿到礼物，我厚着脸皮问了一个问题，说是通过同一个数据的修改发送到同一个线程处理，这个线程是怎么处理的。分享人说是类似将数据 ID 哈希到线程上。</p><p><img src="https://blogres.blackist.org/dev-201911241840-447.jpg"></p><h2 id="我的感受"><a href="#我的感受" class="headerlink" title="我的感受"></a>我的感受</h2><p>主要是对一些概念的了解更充分了，视野被开拓了。</p><h3 id="关于-DevOps"><a href="#关于-DevOps" class="headerlink" title="关于 DevOps"></a>关于 DevOps</h3><p>这个词在网上经常看到，经过王娟的介绍，对 DevOps 在团队中的落地实施有了更充分的认识。再者就是会后和其他两个哥们聊天，探讨了 DevOps 在一个公司落地的难度。最终得到结论，王娟大姐是个“狠人”，哈哈哈哈！！！ 这就是句玩笑话，但也是对团队合作的感叹。</p><p>因为，一个新的开发模式、给合作模式的落地，牵扯到多方团队，共识是这件事情的基础，然后就是推动人要有具体可实施的方案。王娟大姐在公司内部提倡、推广、并最终落地 DevOps 持续交付平台，这其中得付出了多少努力啊！</p><h3 id="关于-实时质量"><a href="#关于-实时质量" class="headerlink" title="关于 实时质量"></a>关于 实时质量</h3><p>阿里的靖远，给我一种沉稳、干练、经验丰富的感觉，基于规则校验的测试平台也是刷新了我的认知。在这个平台里，一切测试皆规则，包括兼容性测试。这说明测试已经被高度抽象，而不仅仅是技术和模式的进步。</p><p>在 Q&amp;A 环节，靖远回答问题更是逻辑清晰、言简意赅，慢慢的干货，这就是我长期努力的榜样啊。</p><h3 id="关于-K8s"><a href="#关于-K8s" class="headerlink" title="关于 K8s"></a>关于 K8s</h3><p>有赞大规模的测试环境，包含 3000 个容器，想必整个测试平台都在 K8s 的笼罩之下了。话说最近在写硕士论文，研究方向就是 K8s 的资源调度负载均衡，之前我没怎么接触过 K8s，其实这也是倒逼自己学习。</p><p>这两年因为客观原因，一直在做安卓开发，在自己喜欢的后台开发方面落下了不少知识。还没熟练掌握 Springboot、Docker、SpringCloud、Dubbox，直接上手 K8s 还是心里虚虚的，不过为了论文还得硬刚，争取入职前把这些补上。</p><h2 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h2><p>这次沙龙的 PPT 我上传了，后台回复 [2019测试沙龙] 获取。</p><p>有赞的 PPT 风格还是挺好看的，靖远的那份干货满满，有需自取。</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>测试</tag>
      
      <tag>沙龙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO - Buffer、Channel 和 Selector</title>
    <link href="/2019-10-09-java-nio-buffer-channel-selector/"/>
    <url>/2019-10-09-java-nio-buffer-channel-selector/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>转载</strong> <a href="https://javadoop.com/post/java-nio">https://javadoop.com/post/java-nio</a></p><p>本文将介绍 Java NIO 中三大组件 <strong>Buffer、Channel、Selector</strong> 的使用。</p><p>本来要一起介绍<strong>非阻塞 IO</strong> 和 JDK7 的<strong>异步 IO</strong> 的，不过因为之前的文章真的太长了，有点影响读者阅读，所以这里将它们放到另一篇文章中进行介绍。</p><span id="more"></span><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。</p><p>java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧。</p><p><img src="https://www.javadoop.com/blogimages/nio/6.png" alt="6"></p><p>其实核心是最后的 <strong>ByteBuffer</strong>，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。</p><p>我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。</p><p>MappedByteBuffer 用于实现内存映射文件，也不是本文关注的重点。</p><p>我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。</p><h3 id="position、limit、capacity"><a href="#position、limit、capacity" class="headerlink" title="position、limit、capacity"></a>position、limit、capacity</h3><p>就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。</p><p><img src="https://www.javadoop.com/blogimages/nio/5.png" alt="5"></p><p>最好理解的当然是 capacity，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 capacity 为 1024 的 IntBuffer，代表其一次可以存放 1024 个 int 类型的值。一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值。</p><p>position 和 limit 是变化的，我们分别看下读和写操作下，它们是如何变化的。</p><p><strong>position</strong> 的初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1，代表下一次的写入位置。读操作的时候也是类似的，每读一个值，position 就自动加 1。</p><p>从写操作模式到读操作模式切换的时候（<strong>flip</strong>），position 都会归零，这样就可以从头开始读写了。</p><p><strong>Limit</strong>：写操作模式下，limit 代表的是最大能写入的数据，这个时候 limit 等于 capacity。写结束后，切换到读模式，此时的 limit 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了。</p><p><img src="https://www.javadoop.com/blogimages/nio/7.png" alt="7"></p><h3 id="初始化-Buffer"><a href="#初始化-Buffer" class="headerlink" title="初始化 Buffer"></a>初始化 Buffer</h3><p>每个 Buffer 实现类都提供了一个静态方法 <code>allocate(int capacity)</code> 帮助我们快速实例化一个 Buffer。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuf</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">1024</span>);<br><span class="hljs-type">LongBuffer</span> <span class="hljs-variable">longBuf</span> <span class="hljs-operator">=</span> LongBuffer.allocate(<span class="hljs-number">1024</span>);<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>另外，我们经常使用 wrap 方法来初始化一个 Buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">wrap</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] array)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="填充-Buffer"><a href="#填充-Buffer" class="headerlink" title="填充 Buffer"></a>填充 Buffer</h3><p>各个 Buffer 类都提供了一些 put 方法用于将数据填充到 Buffer 中，如 ByteBuffer 中的几个 put 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 填充一个 byte 值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">byte</span> b)</span>;<br><span class="hljs-comment">// 在指定位置填充一个 int 值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">byte</span> b)</span>;<br><span class="hljs-comment">// 将一个数组中的值填充进去</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] src)</span> &#123;...&#125;<br><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] src, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><p>上述这些方法需要自己控制 Buffer 大小，不能超过 capacity，超过会抛 java.nio.BufferOverflowException 异常。</p><p>对于 Buffer 来说，另一个常见的操作中就是，我们要将来自 Channel 的数据填充到 Buffer 中，在系统层面上，这个操作我们称为<strong>读操作</strong>，因为数据是从外部（文件或网络等）读到内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> channel.read(buf);<br></code></pre></td></tr></table></figure><p>上述方法会返回从 Channel 中读入到 Buffer 的数据大小。</p><h3 id="提取-Buffer-中的值"><a href="#提取-Buffer-中的值" class="headerlink" title="提取 Buffer 中的值"></a>提取 Buffer 中的值</h3><p>前面介绍了写操作，每写入一个值，position 的值都需要加 1，所以 position 最后会指向最后一次写入的位置的后面一个，如果 Buffer 写满了，那么 position 等于 capacity（position 从 0 开始）。</p><p>如果要读 Buffer 中的值，需要切换模式，从写入模式切换到读出模式。注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。</p><p>调用 Buffer 的 <strong>flip()</strong> 方法，可以从写入模式切换到读取模式。其实这个方法也就是设置了一下 position 和 limit 值罢了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">flip</span><span class="hljs-params">()</span> &#123;<br>    limit = position; <span class="hljs-comment">// 将 limit 设置为实际写入的数据数量</span><br>    position = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置 position 为 0</span><br>    mark = -<span class="hljs-number">1</span>; <span class="hljs-comment">// mark 之后再说</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应写入操作的一系列 put 方法，读操作提供了一系列的 get 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 position 来获取数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 获取指定位置的数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><span class="hljs-comment">// 将 Buffer 中的数据写入到数组中</span><br><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] dst)</span><br></code></pre></td></tr></table></figure><p>附一个经常使用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array()).trim();<br></code></pre></td></tr></table></figure><p>当然了，除了将数据从 Buffer 取出来使用，更常见的操作是将我们写入的数据传输到 Channel 中，如通过 FileChannel 将数据写入到文件中，通过 SocketChannel 将数据写入网络发送到远程机器等。对应的，这种操作，我们称之为<strong>写操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> channel.write(buf);<br></code></pre></td></tr></table></figure><h3 id="mark-amp-reset"><a href="#mark-amp-reset" class="headerlink" title="mark() &amp; reset()"></a>mark() &amp; reset()</h3><p>除了 position、limit、capacity 这三个基本的属性外，还有一个常用的属性就是 mark。</p><p>mark 用于临时保存 position 的值，每次调用 mark() 方法都会将 mark 设值为当前的 position，便于后续需要的时候使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">mark</span><span class="hljs-params">()</span> &#123;<br>    mark = position;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mark;<br>    <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidMarkException</span>();<br>    position = m;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="rewind-amp-clear-amp-compact"><a href="#rewind-amp-clear-amp-compact" class="headerlink" title="rewind() &amp; clear() &amp; compact()"></a>rewind() &amp; clear() &amp; compact()</h3><p>**rewind()**：会重置 position 为 0，通常用于重新从头读写 Buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">rewind</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">0</span>;<br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**clear()**：有点重置 Buffer 的意思，相当于重新实例化了一样。</p><p>通常，我们会先填充 Buffer，然后从 Buffer 读取数据，之后我们再重新往里填充新的数据，我们一般在重新填充之前先调用 clear()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">0</span>;<br>    limit = capacity;<br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**compact()**：和 clear() 一样的是，它们都是在准备往 Buffer 填充新的数据之前调用。</p><p>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只不过后续的写入会覆盖掉原来的数据，也就相当于清空了数据了。</p><p>而 compact() 方法有点不一样，调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>所有的 NIO 操作始于通道，通道是数据来源或数据写入的目的地，主要地，我们将关心 java.nio 包中实现的以下几个 Channel：</p><p><img src="https://www.javadoop.com/blogimages/nio/8.png" alt="8"></p><ul><li>FileChannel：文件通道，用于文件的读和写</li><li>DatagramChannel：用于 UDP 连接的接收和发送</li><li>SocketChannel：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li><li>ServerSocketChannel：TCP 对应的服务端，用于监听某个端口进来的请求</li></ul><p><strong>这里不是很理解这些也没关系，后面介绍了代码之后就清晰了。还有，我们最应该关注，也是后面将会重点介绍的是 SocketChannel 和 ServerSocketChannel。</strong></p><p>Channel 经常翻译为通道，类似 IO 中的流，用于读取和写入。它与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p><p><img src="https://www.javadoop.com/blogimages/nio/9.png" alt="9"></p><p><img src="https://www.javadoop.com/blogimages/nio/10.png" alt="10"></p><p>至少读者应该记住一点，这两个方法都是 channel 实例的方法。</p><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>我想文件操作对于大家来说应该是最熟悉的，不过我们在说 NIO 的时候，其实 FileChannel 并不是关注的重点。而且后面我们说非阻塞的时候会看到，FileChannel 是不支持非阻塞的。</p><p><strong>这里算是简单介绍下常用的操作吧，感兴趣的读者瞄一眼就是了。</strong></p><p><strong>初始化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/data.txt&quot;</span>));<br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> inputStream.getChannel();<br></code></pre></td></tr></table></figure><p>当然了，我们也可以从 RandomAccessFile#getChannel 来得到 FileChannel。</p><p><strong>读取文件内容：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> fileChannel.read(buffer);<br></code></pre></td></tr></table></figure><p>前面我们也说了，所有的 Channel 都是和 Buffer 打交道的。</p><p><strong>写入文件内容：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>buffer.put(<span class="hljs-string">&quot;随机写入一些内容到 Buffer 中&quot;</span>.getBytes());<br><span class="hljs-comment">// Buffer 切换为读模式</span><br>buffer.flip();<br><span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>    <span class="hljs-comment">// 将 Buffer 中的内容写入文件</span><br>    fileChannel.write(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>我们前面说了，我们可以将 SocketChannel 理解成一个 TCP 客户端。虽然这么理解有点狭隘，因为我们在介绍 ServerSocketChannel 的时候会看到另一种使用方式。</p><p>打开一个 TCP 连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;https://www.javadoop.com&quot;</span>, <span class="hljs-number">80</span>));<br></code></pre></td></tr></table></figure><p>当然了，上面的这行代码等价于下面的两行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 打开一个通道</span><br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br><span class="hljs-comment">// 发起连接</span><br>socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;https://www.javadoop.com&quot;</span>, <span class="hljs-number">80</span>));<br></code></pre></td></tr></table></figure><p>SocketChannel 的读写和 FileChannel 没什么区别，就是操作缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取数据</span><br>socketChannel.read(buffer);<br><br><span class="hljs-comment">// 写入数据到网络连接中</span><br><span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>    socketChannel.write(buffer);   <br>&#125;<br></code></pre></td></tr></table></figure><p>不要在这里停留太久，先继续往下走。</p><h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>之前说 SocketChannel 是 TCP 客户端，这里说的 ServerSocketChannel 就是对应的服务端。</p><p>ServerSocketChannel 用于监听机器端口，管理从这个端口进来的 TCP 连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><span class="hljs-comment">// 监听 8080 端口</span><br>serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里我们可以看到 SocketChannel 的第二个实例化方式</p></blockquote><p>到这里，我们应该能理解 SocketChannel 了，它不仅仅是 TCP 客户端，它代表的是一个网络通道，可读可写。</p><p>ServerSocketChannel 不和 Buffer 打交道了，因为它并不实际处理数据，它一旦接收到请求后，实例化 SocketChannel，之后在这个连接通道上的数据传递它就不管了，因为它需要继续监听端口，等待下一个连接。</p><h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>UDP 和 TCP 不一样，DatagramChannel 一个类处理了服务端和客户端。</p><blockquote><p>科普一下，UDP 是面向无连接的，不需要和对方握手，不需要通知对方，就可以直接将数据包投出去，至于能不能送达，它是不知道的</p></blockquote><p><strong>监听端口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> DatagramChannel.open();<br>channel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9090</span>));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">48</span>);<br><br>channel.receive(buf);<br></code></pre></td></tr></table></figure><p><strong>发送数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">newData</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;New String to write to file...&quot;</span><br>                    + System.currentTimeMillis();<br>    <br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">48</span>);<br>buf.put(newData.getBytes());<br>buf.flip();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">bytesSent</span> <span class="hljs-operator">=</span> channel.send(buf, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;jenkov.com&quot;</span>, <span class="hljs-number">80</span>));<br></code></pre></td></tr></table></figure><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>NIO 三大组件就剩 Selector 了，Selector 建立在非阻塞的基础之上，大家经常听到的 <strong>多路复用</strong> 在 Java 世界中指的就是它，用于实现一个线程管理多个 Channel。</p><p>读者在这一节不能消化 Selector 也没关系，因为后续在介绍非阻塞 IO 的时候还得说到这个，这里先介绍一些基本的接口操作。</p><ol><li><p>首先，我们开启一个 Selector。你们爱翻译成<strong>选择器</strong>也好，<strong>多路复用器</strong>也好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure></li><li><p>将 Channel 注册到 Selector 上。前面我们说了，Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式，<strong>FileChannel 不支持非阻塞</strong>，我们这里讨论最常见的 SocketChannel 和 ServerSocketChannel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将通道设置为非阻塞模式，因为默认都是阻塞模式的</span><br>channel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 注册</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> channel.register(selector, SelectionKey.OP_READ);<br></code></pre></td></tr></table></figure><p>register 方法的第二个 int 型参数（使用二进制的标记位）用于表明需要监听哪些感兴趣的事件，共以下四种事件：</p><ul><li><p>SelectionKey.OP_READ</p><blockquote><p>对应 00000001，通道中有数据可以进行读取</p></blockquote></li><li><p>SelectionKey.OP_WRITE</p><blockquote><p>对应 00000100，可以往通道中写入数据</p></blockquote></li><li><p>SelectionKey.OP_CONNECT</p><blockquote><p>对应 00001000，成功建立 TCP 连接</p></blockquote></li><li><p>SelectionKey.OP_ACCEPT</p><blockquote><p>对应 00010000，接受 TCP 连接</p></blockquote></li></ul><p>我们可以同时监听一个 Channel 中的发生的多个事件，比如我们要监听 ACCEPT 和 READ 事件，那么指定参数为二进制的 000<strong>1</strong>000<strong>1</strong> 即十进制数值 17 即可。</p><p>注册方法返回值是 <strong>SelectionKey</strong> 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。</p></li><li><p>调用 select() 方法获取通道信息。用于判断是否有我们感兴趣的事件已经发生了。</p></li></ol><p>Selector 的操作就是以上 3 步，这里来一个简单的示例，大家看一下就好了。之后在介绍非阻塞 IO 的时候，会演示一份可执行的示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>channel.configureBlocking(<span class="hljs-literal">false</span>);<br><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> channel.register(selector, SelectionKey.OP_READ);<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// 判断是否有事件准备好</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">readyChannels</span> <span class="hljs-operator">=</span> selector.select();<br>  <span class="hljs-keyword">if</span>(readyChannels == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>  <span class="hljs-comment">// 遍历</span><br>  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();<br>  <span class="hljs-keyword">while</span>(keyIterator.hasNext()) &#123;<br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br><br>    <span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;<br>        <span class="hljs-comment">// a connection was accepted by a ServerSocketChannel.</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>        <span class="hljs-comment">// a connection was established with a remote server.</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>        <span class="hljs-comment">// a channel is ready for reading</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>        <span class="hljs-comment">// a channel is ready for writing</span><br>    &#125;<br><br>    keyIterator.remove();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 Selector，我们还需要非常熟悉以下几个方法：</p><ol><li><strong>select()</strong></li></ol><p>  调用此方法，会将<strong>上次 select 之后的</strong>准备好的 channel 对应的 SelectionKey 复制到 selected set 中。如果没有任何通道准备好，这个方法会阻塞，直到至少有一个通道准备好。</p><ol start="2"><li><p><strong>selectNow()</strong></p><p>功能和 select 一样，区别在于如果没有准备好的通道，那么此方法会立即返回 0。</p></li><li><p><strong>select(long timeout)</strong></p><p>看了前面两个，这个应该很好理解了，如果没有通道准备好，此方法会等待一会</p></li><li><p><strong>wakeup()</strong></p><p>这个方法是用来唤醒等待在 select() 和 select(timeout) 上的线程的。如果 wakeup() 先被调用，此时没有线程在 select 上阻塞，那么之后的一个 select() 或 select(timeout) 会立即返回，而不会阻塞，当然，它只会作用一次。</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，介绍了 Buffer、Channel 和 Selector 的常见接口。</p><p>Buffer 和数组差不多，它有 position、limit、capacity 几个重要属性。put() 一下数据、flip() 切换到读模式、然后用 get() 获取数据、clear() 一下清空数据、重新回到 put() 写入数据。</p><p>Channel 基本上只和 Buffer 打交道，最重要的接口就是 channel.read(buffer) 和 channel.write(buffer)。</p><p>Selector 用于实现非阻塞 IO，这里仅仅介绍接口使用，后续请关注非阻塞 IO 的介绍。</p><p>（全文完）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</title>
    <link href="/2019-10-05-java-hashmap-concurrenthashmap/"/>
    <url>/2019-10-05-java-hashmap-concurrenthashmap/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>转载</strong> <a href="https://javadoop.com/post/hashmap">https://javadoop.com/post/hashmap</a></p><p>今天发一篇”水文”，可能很多读者都会表示不理解，不过我想把它作为并发序列文章中不可缺少的一块来介绍。本来以为花不了多少时间的，不过最终还是投入了挺多时间来完成这篇文章的。</p><p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p><p>阅读建议：四节基本上可以进行独立阅读，建议初学者可按照 Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap 顺序进行阅读，可适当降低阅读门槛。</p><p>阅读前提：本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p><span id="more"></span><h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p><p>首先，我们用下面这张图来介绍 HashMap 的结构。</p><p><img src="https://blogres.blackist.org/dev-201910011925-789.png"></p><blockquote><p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p></blockquote><p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p><p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p><p>loadFactor：负载因子，默认为 0.75。</p><p>threshold：扩容的阈值，等于 capacity * loadFactor</p><h3 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>还是比较简单的，跟着代码走一遍吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// 当插入第一个元素的时候，需要先初始化数组大小</span><br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>        inflateTable(threshold);<br>    &#125;<br>    <span class="hljs-comment">// 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> putForNullKey(value);<br>    <span class="hljs-comment">// 1. 求 key 的 hash 值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-comment">// 2. 找到对应的数组下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>    <span class="hljs-comment">// 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span><br>    <span class="hljs-comment">//    如果有，直接覆盖，put 方法返回旧值就结束了</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    <span class="hljs-comment">// 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span><br>    addEntry(hash, key, value, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inflateTable</span><span class="hljs-params">(<span class="hljs-type">int</span> toSize)</span> &#123;<br>    <span class="hljs-comment">// 保证数组大小一定是 2 的 n 次方。</span><br>    <span class="hljs-comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> roundUpToPowerOf2(toSize);<br>    <span class="hljs-comment">// 计算扩容阈值：capacity * loadFactor</span><br>    threshold = (<span class="hljs-type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 算是初始化数组吧</span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[capacity];<br>    initHashSeedAsNeeded(capacity); <span class="hljs-comment">//ignore</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p><h4 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h4><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br>    <span class="hljs-keyword">return</span> hash &amp; (length-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p><h4 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h4><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的<strong>表头</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">addEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>    <span class="hljs-comment">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span><br>    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-literal">null</span> != table[bucketIndex])) &#123;<br>        <span class="hljs-comment">// 扩容，后面会介绍一下</span><br>        resize(<span class="hljs-number">2</span> * table.length);<br>        <span class="hljs-comment">// 扩容以后，重新计算 hash 值</span><br>        hash = (<span class="hljs-literal">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 重新计算扩容后的新的下标</span><br>        bucketIndex = indexFor(hash, table.length);<br>    &#125;<br>    <span class="hljs-comment">// 往下看</span><br>    createEntry(hash, key, value, bucketIndex);<br>&#125;<br><span class="hljs-comment">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>    Entry&lt;K,V&gt; e = table[bucketIndex];<br>    table[bucketIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>前面我们看到，在插入新值的时候，如果<strong>当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素</strong>，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;<br>    Entry[] oldTable = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<br>        threshold = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 新的数组</span><br>    Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newCapacity];<br>    <span class="hljs-comment">// 将原来数组中的值迁移到新的更大的数组中</span><br>    transfer(newTable, initHashSeedAsNeeded(newCapacity));<br>    table = newTable;<br>    threshold = (<span class="hljs-type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p><h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 过程，get 过程是非常简单的。</p><ol><li>根据 key 计算 hash 值。</li><li>找到相应的数组下标：hash &amp; (length - 1)。</li><li>遍历该数组位置处的链表，直到找到相等(&#x3D;&#x3D;或equals)的 key。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-comment">// 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> getForNullKey();<br>    <span class="hljs-comment">// </span><br>    Entry&lt;K,V&gt; entry = getEntry(key);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> == entry ? <span class="hljs-literal">null</span> : entry.getValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>getEntry(key):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">getEntry</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : hash(key);<br>    <span class="hljs-comment">// 确定数组下标，然后从头开始遍历链表，直到找到为止</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];<br>         e != <span class="hljs-literal">null</span>;<br>         e = e.next) &#123;<br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了“<strong>槽</strong>”来代表一个 segment。</p><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="https://blogres.blackist.org/dev-201910011926-996.png"></p><p><strong>concurrencyLevel</strong>：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p><p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><br><span class="hljs-params">                         <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)<br>        concurrencyLevel = MAX_SEGMENTS;<br>    <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sshift</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ssize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span><br>    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<br>        ++sshift;<br>        ssize &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span><br>    <span class="hljs-comment">// 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span><br>    <span class="hljs-built_in">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;<br>    <span class="hljs-built_in">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;<br>  <br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>  <br>    <span class="hljs-comment">// initialCapacity 是设置整个 map 初始的大小，</span><br>    <span class="hljs-comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span><br>    <span class="hljs-comment">// 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> initialCapacity / ssize;<br>    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)<br>        ++c;<br>    <span class="hljs-comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span><br>    <span class="hljs-comment">// 插入一个元素不至于扩容，插入第二个的时候才会扩容</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> MIN_SEGMENT_TABLE_CAPACITY; <br>    <span class="hljs-keyword">while</span> (cap &lt; c)<br>        cap &lt;&lt;= <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 创建 Segment 数组，</span><br>    <span class="hljs-comment">// 并创建数组的第一个元素 segment[0]</span><br>    Segment&lt;K,V&gt; s0 =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="hljs-type">int</span>)(cap * loadFactor),<br>                         (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap]);<br>    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>[ssize];<br>    <span class="hljs-comment">// 往数组写入 segment[0]</span><br>    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span><br>    <span class="hljs-built_in">this</span>.segments = ss;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化完成，我们得到了一个 Segment 数组。</p><p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p><ul><li>Segment 数组长度为 16，不可以扩容</li><li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li><li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li><li>当前 segmentShift 的值为 32 - 4 &#x3D; 28，segmentMask 为 16 - 1 &#x3D; 15，姑且把它们简单翻译为<strong>移位数</strong>和<strong>掩码</strong>，这两个值马上就会用到</li></ul><h3 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    Segment&lt;K,V&gt; s;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 1. 计算 key 的 hash 值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-comment">// 2. 根据 hash 值找到 Segment 数组中的位置 j</span><br>    <span class="hljs-comment">//    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，</span><br>    <span class="hljs-comment">//    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br>    <span class="hljs-comment">// 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span><br>    <span class="hljs-comment">// ensureSegment(j) 对 segment[j] 进行初始化</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="hljs-comment">// nonvolatile; recheck</span><br>         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-literal">null</span>) <span class="hljs-comment">//  in ensureSegment</span><br>        s = ensureSegment(j);<br>    <span class="hljs-comment">// 3. 插入新值到 槽 s 中</span><br>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p><p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// 在往该 segment 写入前，需要先获取该 segment 的独占锁</span><br>    <span class="hljs-comment">//    先看主流程，后面还会具体介绍这部分内容</span><br>    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-literal">null</span> :<br>        scanAndLockForPut(key, hash, value);<br>    V oldValue;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 这个是 segment 内部的数组</span><br>        HashEntry&lt;K,V&gt;[] tab = table;<br>        <span class="hljs-comment">// 再利用 hash 值，求应该放置的数组下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (tab.length - <span class="hljs-number">1</span>) &amp; hash;<br>        <span class="hljs-comment">// first 是数组该位置处的链表的表头</span><br>        HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br>        <br>        <span class="hljs-comment">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span><br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                K k;<br>                <span class="hljs-keyword">if</span> ((k = e.key) == key ||<br>                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;<br>                    oldValue = e.value;<br>                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                        <span class="hljs-comment">// 覆盖旧值</span><br>                        e.value = value;<br>                        ++modCount;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 继续顺着链表走</span><br>                e = e.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span><br>                <span class="hljs-comment">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span><br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>                    node.setNext(first);<br>                <span class="hljs-keyword">else</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);<br>                <br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span><br>                <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>                    rehash(node); <span class="hljs-comment">// 扩容后面也会具体分析</span><br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span><br>                    <span class="hljs-comment">// 其实就是将新的节点设置成原链表的表头</span><br>                    setEntryAt(tab, index, node);<br>                ++modCount;<br>                count = c;<br>                oldValue = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p><p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p><h4 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h4><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p><p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Segment&lt;K,V&gt; <span class="hljs-title function_">ensureSegment</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="hljs-built_in">this</span>.segments;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="hljs-comment">// raw offset</span><br>    Segment&lt;K,V&gt; seg;<br>    <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 这里看到为什么之前要初始化 segment[0] 了，</span><br>        <span class="hljs-comment">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span><br>        <span class="hljs-comment">// 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span><br>        Segment&lt;K,V&gt; proto = ss[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> proto.table.length;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> proto.loadFactor;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(cap * lf);<br>        <br>        <span class="hljs-comment">// 初始化 segment[k] 内部的数组</span><br>        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap];<br>        <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>            == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 再次检查一遍该槽是否被其他线程初始化了。</span><br>          <br>            Segment&lt;K,V&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);<br>            <span class="hljs-comment">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span><br>            <span class="hljs-keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                   == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="hljs-literal">null</span>, seg = s))<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> seg;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p><blockquote><p>我没搞懂这里为什么要搞一个 while 循环，CAS 失败不就代表有其他线程成功了吗，为什么要再进行判断？</p><p>感谢评论区的<strong>李子木</strong>，如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p></blockquote><h4 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h4><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用  node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p><p>下面我们来具体分析这个方法中是怎么控制加锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashEntry&lt;K,V&gt; <span class="hljs-title function_">scanAndLockForPut</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value)</span> &#123;<br>    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-built_in">this</span>, hash);<br>    HashEntry&lt;K,V&gt; e = first;<br>    HashEntry&lt;K,V&gt; node = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">retries</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// negative while locating node</span><br>    <br>    <span class="hljs-comment">// 循环获取锁</span><br>    <span class="hljs-keyword">while</span> (!tryLock()) &#123;<br>        HashEntry&lt;K,V&gt; f; <span class="hljs-comment">// to recheck first below</span><br>        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-comment">// speculatively create node</span><br>                    <span class="hljs-comment">// 进到这里说明数组该位置的链表是空的，没有任何元素</span><br>                    <span class="hljs-comment">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>                retries = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.equals(e.key))<br>                retries = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 顺着链表往下走</span><br>                e = e.next;<br>        &#125;<br>        <span class="hljs-comment">// 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁</span><br>        <span class="hljs-comment">//    lock() 是阻塞方法，直到获取锁后返回</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<br>            lock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp;<br>                 <span class="hljs-comment">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span><br>                 <span class="hljs-comment">//     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span><br>                 (f = entryForHash(<span class="hljs-built_in">this</span>, hash)) != first) &#123;<br>            e = first = f; <span class="hljs-comment">// re-traverse if entry changed</span><br>            retries = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p><p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p><h4 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h4><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容，扩容后，容量为原来的 2 倍。</p><p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p><p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">(HashEntry&lt;K,V&gt; node)</span> &#123;<br>    HashEntry&lt;K,V&gt;[] oldTable = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-comment">// 2 倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity &lt;&lt; <span class="hljs-number">1</span>;<br>    threshold = (<span class="hljs-type">int</span>)(newCapacity * loadFactor);<br>    <span class="hljs-comment">// 创建新数组</span><br>    HashEntry&lt;K,V&gt;[] newTable =<br>        (HashEntry&lt;K,V&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[newCapacity];<br>    <span class="hljs-comment">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sizeMask</span> <span class="hljs-operator">=</span> newCapacity - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;<br>        <span class="hljs-comment">// e 是链表的第一个元素</span><br>        HashEntry&lt;K,V&gt; e = oldTable[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            HashEntry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-comment">// 计算应该放置在新数组中的位置，</span><br>            <span class="hljs-comment">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> e.hash &amp; sizeMask;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)   <span class="hljs-comment">// 该位置处只有一个元素，那比较好办</span><br>                newTable[idx] = e;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Reuse consecutive sequence at same slot</span><br>                <span class="hljs-comment">// e 是链表表头</span><br>                HashEntry&lt;K,V&gt; lastRun = e;<br>                <span class="hljs-comment">// idx 是当前链表的头结点 e 的新位置</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">lastIdx</span> <span class="hljs-operator">=</span> idx;<br><br>                <span class="hljs-comment">// 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next;<br>                     last != <span class="hljs-literal">null</span>;<br>                     last = last.next) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> last.hash &amp; sizeMask;<br>                    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;<br>                        lastIdx = k;<br>                        lastRun = last;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span><br>                newTable[lastIdx] = lastRun;<br>                <span class="hljs-comment">// 下面的操作是处理 lastRun 之前的节点，</span><br>                <span class="hljs-comment">//    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span><br>                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;<br>                    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> p.value;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> p.hash;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> h &amp; sizeMask;<br>                    HashEntry&lt;K,V&gt; n = newTable[k];<br>                    newTable[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nodeIndex</span> <span class="hljs-operator">=</span> node.hash &amp; sizeMask; <span class="hljs-comment">// add the new node</span><br>    node.setNext(newTable[nodeIndex]);<br>    newTable[nodeIndex] = node;<br>    table = newTable;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p><p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p><p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1&#x2F;6 的节点需要克隆</strong>。</p><h3 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的不要太简单。</p><ol><li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li><li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li><li>到这里是链表了，顺着链表进行查找即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Segment&lt;K,V&gt; s; <span class="hljs-comment">// manually integrate access methods to reduce overhead</span><br>    HashEntry&lt;K,V&gt;[] tab;<br>    <span class="hljs-comment">// 1. hash 值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br>    <span class="hljs-comment">// 2. 根据 hash 找到对应的 segment</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-literal">null</span> &amp;&amp;<br>        (tab = s.table) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 3. 找到segment 内部数组相应位置的链表，遍历</span><br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br>                 (tab, ((<span class="hljs-type">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>             e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>            K k;<br>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>                <span class="hljs-keyword">return</span> e.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h3><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p><p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p><ol><li><p>put 操作的线程安全性。</p><ol><li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li><li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li><li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li></ol></li><li><p>remove 操作的线程安全性。</p><p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p><p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p><p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p><p>如果 remove 先破坏了一个节点，分两种情况考虑。  1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</p></li></ol><h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 **O(n)**。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 **O(logN)**。</p><p>来一张图简单示意一下吧：</p><p><img src="https://blogres.blackist.org/dev-201910011927-365.png"></p><blockquote><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p></blockquote><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="put-过程分析-2"><a href="#put-过程分析-2" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span><br><span class="hljs-comment">// 第四个参数 evict 我们这里不关心</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span><br>    <span class="hljs-comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>  <br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 数组该位置有数据</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 到这里，说明数组该位置上是一个链表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span><br>                    <span class="hljs-comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span><br>        <span class="hljs-comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><h4 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize() 方法用于<strong>初始化数组</strong>或<strong>数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 对应数组扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 将数组大小扩大一倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-comment">// 将阈值扩大一倍</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br><br>    <span class="hljs-comment">// 用新的数组大小初始化新的数组</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab; <span class="hljs-comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span><br>    <br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 开始遍历原数组，进行数据迁移。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">// 如果是红黑树，具体我们就不展开了</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <br>                    <span class="hljs-comment">// 这块是处理链表的情况，</span><br>                    <span class="hljs-comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span><br>                    <span class="hljs-comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-comment">// 第一条链表</span><br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span><br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="get-过程分析-2"><a href="#get-过程分析-2" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p><ol><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 判断第一个节点是不是就是需要的</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 判断是否是红黑树</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <br>            <span class="hljs-comment">// 链表遍历</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p><p><strong>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</strong></p><p>我们先用一个示意图来描述下其结构：</p><p><img src="https://blogres.blackist.org/dev-201910011927-521.png"></p><p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这构造函数里，什么都不干</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">()</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ?<br>               MAXIMUM_CAPACITY :<br>               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl &#x3D; 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p><p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p><p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p><h3 id="put-过程分析-3"><a href="#put-过程分析-3" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>仔细地一行一行代码看下去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 得到 hash 值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-comment">// 用于记录相应链表的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-comment">// 如果数组&quot;空&quot;，进行数组初始化</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 初始化数组，后面会详细介绍</span><br>            tab = initTable();<br>        <br>        <span class="hljs-comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果数组该位置为空，</span><br>            <span class="hljs-comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span><br>            <span class="hljs-comment">//  如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            <span class="hljs-comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span><br>            tab = helpTransfer(tab, f);<br>        <br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 到这里就是说，f 是该位置的头结点，而且不为空</span><br>            <br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 获取数组该位置的头结点的监视器锁</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 头结点的 hash 值大于 0，说明是链表</span><br>                        <span class="hljs-comment">// 用于累加，记录链表的长度</span><br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-comment">// 遍历链表</span><br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-comment">// 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span><br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            <span class="hljs-comment">// 到了链表的最末端，将这个新值放到链表的最后面</span><br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123; <span class="hljs-comment">// 红黑树</span><br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-comment">// 调用红黑树的插值方法插入新节点</span><br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    <span class="hljs-comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span><br>                    <span class="hljs-comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span><br>                    <span class="hljs-comment">//    具体源码我们就不看了，扩容部分后面说</span><br>                    treeifyBin(tab, i);<br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// </span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p><h4 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h4><p>这个比较简单，主要就是初始化一个<strong>合适大小</strong>的数组，然后会设置 sizeCtl。</p><p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// DEFAULT_CAPACITY 默认初始容量是 16</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br><span class="hljs-comment">// 初始化数组，长度为 16 或初始化时提供的长度</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    <span class="hljs-comment">// 将这个数组赋值给 table，table 是 volatile 的</span><br>                    table = tab = nt;<br>                    <span class="hljs-comment">// 如果 n 为 16 的话，那么这里 sc = 12</span><br>                    <span class="hljs-comment">// 其实就是 0.75 * n</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span><br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h4><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> index)</span> &#123;<br>    Node&lt;K,V&gt; b; <span class="hljs-type">int</span> n, sc;<br>    <span class="hljs-keyword">if</span> (tab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// MIN_TREEIFY_CAPACITY 为 64</span><br>        <span class="hljs-comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span><br>        <span class="hljs-keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>            <span class="hljs-comment">// 后面我们再详细分析这个方法</span><br>            tryPresize(n &lt;&lt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// b 是头结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((b = tabAt(tab, index)) != <span class="hljs-literal">null</span> &amp;&amp; b.hash &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-keyword">synchronized</span> (b) &#123;<br>            <br>                <span class="hljs-keyword">if</span> (tabAt(tab, index) == b) &#123;<br>                    <span class="hljs-comment">// 下面就是遍历链表，建立一颗红黑树</span><br>                    TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>                        TreeNode&lt;K,V&gt; p =<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;(e.hash, e.key, e.val,<br>                                              <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-keyword">if</span> ((p.prev = tl) == <span class="hljs-literal">null</span>)<br>                            hd = p;<br>                        <span class="hljs-keyword">else</span><br>                            tl.next = p;<br>                        tl = p;<br>                    &#125;<br>                    <span class="hljs-comment">// 将红黑树设置到数组相应位置中</span><br>                    setTabAt(tab, index, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(hd));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h3><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p><p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p><p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPresize</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-comment">// c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ? MAXIMUM_CAPACITY :<br>        tableSizeFor(size + (size &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((sc = sizeCtl) &gt;= <span class="hljs-number">0</span>) &#123;<br>        Node&lt;K,V&gt;[] tab = table; <span class="hljs-type">int</span> n;<br>        <br>        <span class="hljs-comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;<br>            n = (sc &gt; c) ? sc : c;<br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (table == tab) &#123;<br>                        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                        table = nt;<br>                        sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// 0.75 * n</span><br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    sizeCtl = sc;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tab == table) &#123;<br>            <span class="hljs-comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(n);<br>            <br>            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br>                Node&lt;K,V&gt;[] nt;<br>                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||<br>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-literal">null</span> ||<br>                    transferIndex &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span><br>                <span class="hljs-comment">//    此时 nextTab 不为 null</span><br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                    transfer(tab, nt);<br>            &#125;<br>            <span class="hljs-comment">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span><br>            <span class="hljs-comment">//     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span><br>            <span class="hljs-comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc,<br>                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>                transfer(tab, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p><p>所以，可能的操作就是执行 **1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。</p><h4 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h4><p>下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p><p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p><p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p><p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是<strong>步长</strong>，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p><p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后<strong>从后往前</strong>的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>    <br>    <span class="hljs-comment">// stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span><br>    <span class="hljs-comment">// stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span><br>    <span class="hljs-comment">//   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span><br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span><br><br>    <span class="hljs-comment">// 如果 nextTab 为 null，先进行一次初始化</span><br>    <span class="hljs-comment">//    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span><br>    <span class="hljs-comment">//   之后参与迁移的线程调用此方法时，nextTab 不会为 null</span><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 容量翻倍</span><br>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span><br>            sizeCtl = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// nextTable 是 ConcurrentHashMap 中的属性</span><br>        nextTable = nextTab;<br>        <span class="hljs-comment">// transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span><br>        transferIndex = n;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br>    <br>    <span class="hljs-comment">// ForwardingNode 翻译过来就是正在被迁移的 Node</span><br>    <span class="hljs-comment">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span><br>    <span class="hljs-comment">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span><br>    <span class="hljs-comment">//    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span><br>    <span class="hljs-comment">//    所以它其实相当于是一个标志。</span><br>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br>    <br><br>    <span class="hljs-comment">// advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">// i 是位置索引，bound 是边界，注意是从后往前</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;<br>        <br>        <span class="hljs-comment">// 下面这个 while 真的是不好理解</span><br>        <span class="hljs-comment">// advance 为 true 表示可以进行下一个位置的迁移了</span><br>        <span class="hljs-comment">//   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span><br>        <span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-type">int</span> nextIndex, nextBound;<br>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                advance = <span class="hljs-literal">false</span>;<br>            <br>            <span class="hljs-comment">// 将 transferIndex 值赋给 nextIndex</span><br>            <span class="hljs-comment">// 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                     (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                      nextBound = (nextIndex &gt; stride ?<br>                                   nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-comment">// 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span><br>                bound = nextBound;<br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>            <span class="hljs-type">int</span> sc;<br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>                <span class="hljs-comment">// 所有的迁移操作已经完成</span><br>                nextTable = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 将新的 nextTab 赋值给 table 属性，完成迁移</span><br>                table = nextTab;<br>                <span class="hljs-comment">// 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span><br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span><br>            <span class="hljs-comment">// 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span><br>            <span class="hljs-comment">// 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">// 任务结束，方法退出</span><br>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                    <span class="hljs-keyword">return</span>;<br>                <br>                <span class="hljs-comment">// 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span><br>                <span class="hljs-comment">// 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span><br>                finishing = advance = <span class="hljs-literal">true</span>;<br>                i = n; <span class="hljs-comment">// recheck before commit</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br>        <span class="hljs-comment">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    Node&lt;K,V&gt; ln, hn;<br>                    <span class="hljs-comment">// 头结点的 hash 大于 0，说明是链表的 Node 节点</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span><br>                        <span class="hljs-comment">// 需要将链表一分为二，</span><br>                        <span class="hljs-comment">//   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span><br>                        <span class="hljs-comment">//   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;<br>                        Node&lt;K,V&gt; lastRun = f;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;<br>                            <span class="hljs-keyword">if</span> (b != runBit) &#123;<br>                                runBit = b;<br>                                lastRun = p;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;<br>                            ln = lastRun;<br>                            hn = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            hn = lastRun;<br>                            ln = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash; <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key; <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;<br>                            <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)<br>                                ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);<br>                            <span class="hljs-keyword">else</span><br>                                hn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);<br>                        &#125;<br>                        <span class="hljs-comment">// 其中的一个链表放在新数组的位置 i</span><br>                        setTabAt(nextTab, i, ln);<br>                        <span class="hljs-comment">// 另一个链表放在新数组的位置 i+n</span><br>                        setTabAt(nextTab, i + n, hn);<br>                        <span class="hljs-comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span><br>                        <span class="hljs-comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span><br>                        setTabAt(tab, i, fwd);<br>                        <span class="hljs-comment">// advance 设置为 true，代表该位置已经迁移完毕</span><br>                        advance = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        <span class="hljs-comment">// 红黑树的迁移</span><br>                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;<br>                        TreeNode&lt;K,V&gt; lo = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                        TreeNode&lt;K,V&gt; hi = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> e.hash;<br>                            TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;<br>                                (h, e.key, e.val, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>                            <span class="hljs-keyword">if</span> ((h &amp; n) == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">if</span> ((p.prev = loTail) == <span class="hljs-literal">null</span>)<br>                                    lo = p;<br>                                <span class="hljs-keyword">else</span><br>                                    loTail.next = p;<br>                                loTail = p;<br>                                ++lc;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">if</span> ((p.prev = hiTail) == <span class="hljs-literal">null</span>)<br>                                    hi = p;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = p;<br>                                hiTail = p;<br>                                ++hc;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span><br>                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :<br>                            (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;<br>                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :<br>                            (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;<br>                        <br>                        <span class="hljs-comment">// 将 ln 放置在新数组的位置 i</span><br>                        setTabAt(nextTab, i, ln);<br>                        <span class="hljs-comment">// 将 hn 放置在新数组的位置 i+n</span><br>                        setTabAt(nextTab, i + n, hn);<br>                        <span class="hljs-comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span><br>                        <span class="hljs-comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span><br>                        setTabAt(tab, i, fwd);<br>                        <span class="hljs-comment">// advance 设置为 true，代表该位置已经迁移完毕</span><br>                        advance = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p><p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p><h3 id="get-过程分析-3"><a href="#get-过程分析-3" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>get 方法从来都是最简单的，这里也不例外：</p><ol><li>计算 hash 值</li><li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li><li>根据该位置处结点性质进行相应查找<ul><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 判断头结点是否就是我们需要的节点</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span><br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-comment">// 遍历链表</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p><p>看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p><p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分。</p><p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~</p><p>（全文完）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式也可以这么简单</title>
    <link href="/2019-10-01-dev-design-pattern/"/>
    <url>/2019-10-01-dev-design-pattern/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>转载</strong> <a href="https://javadoop.com/post/design-pattern">https://javadoop.com/post/design-pattern</a></p><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p><p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p><ol><li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol><p><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong></p><span id="more"></span><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Food <span class="hljs-title function_">makeFood</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;noodle&quot;</span>)) &#123;<br>            <span class="hljs-type">Food</span> <span class="hljs-variable">noodle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LanZhouNoodle</span>();<br>            noodle.addSpicy(<span class="hljs-string">&quot;more&quot;</span>);<br>            <span class="hljs-keyword">return</span> noodle;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;chicken&quot;</span>)) &#123;<br>            <span class="hljs-type">Food</span> <span class="hljs-variable">chicken</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HuangMenChicken</span>();<br>            chicken.addCondiment(<span class="hljs-string">&quot;potato&quot;</span>);<br>            <span class="hljs-keyword">return</span> chicken;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p><p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p><blockquote><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FoodFactory</span> &#123;<br>    Food <span class="hljs-title function_">makeFood</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChineseFoodFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FoodFactory</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Food <span class="hljs-title function_">makeFood</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChineseFoodA</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChineseFoodB</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AmericanFoodFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FoodFactory</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Food <span class="hljs-title function_">makeFood</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmericanFoodA</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmericanFoodB</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">APP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 先选择一个具体的工厂</span><br>        <span class="hljs-type">FoodFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChineseFoodFactory</span>();<br>        <span class="hljs-comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span><br>        <span class="hljs-type">Food</span> <span class="hljs-variable">food</span> <span class="hljs-operator">=</span> factory.makeFood(<span class="hljs-string">&quot;A&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p><p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p><p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p><p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/factory-1.png" alt="factory-1"></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-1.png" alt="factory-1"></p><p>这个时候的客户端调用是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 得到 Intel 的 CPU</span><br><span class="hljs-type">CPUFactory</span> <span class="hljs-variable">cpuFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelCPUFactory</span>();<br><span class="hljs-type">CPU</span> <span class="hljs-variable">cpu</span> <span class="hljs-operator">=</span> intelCPUFactory.makeCPU();<br><br><span class="hljs-comment">// 得到 AMD 的主板</span><br><span class="hljs-type">MainBoardFactory</span> <span class="hljs-variable">mainBoardFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmdMainBoardFactory</span>();<br><span class="hljs-type">MainBoard</span> <span class="hljs-variable">mainBoard</span> <span class="hljs-operator">=</span> mainBoardFactory.make();<br><br><span class="hljs-comment">// 组装 CPU 和主板</span><br><span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>(cpu, mainBoard);<br></code></pre></td></tr></table></figure><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-2.png" alt="abstract-factory-2"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png" alt="abstract-factory-3"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 第一步就要选定一个“大厂”</span><br>    <span class="hljs-type">ComputerFactory</span> <span class="hljs-variable">cf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmdFactory</span>();<br>    <span class="hljs-comment">// 从这个大厂造 CPU</span><br>    <span class="hljs-type">CPU</span> <span class="hljs-variable">cpu</span> <span class="hljs-operator">=</span> cf.makeCPU();<br>    <span class="hljs-comment">// 从这个大厂造主板</span><br>    <span class="hljs-type">MainBoard</span> <span class="hljs-variable">board</span> <span class="hljs-operator">=</span> cf.makeMainBoard();<br>  <span class="hljs-comment">// 从这个大厂造硬盘</span><br>  <span class="hljs-type">HardDisk</span> <span class="hljs-variable">hardDisk</span> <span class="hljs-operator">=</span> cf.makeHardDisk();<br>  <br>    <span class="hljs-comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span><br>    <span class="hljs-type">Computer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>(cpu, board, hardDisk);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p><p>饿汉模式最简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 首先，将 new Singleton() 堵死</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;;<br>    <span class="hljs-comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>    <span class="hljs-comment">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span><br>    <span class="hljs-comment">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title function_">getDate</span><span class="hljs-params">(String mode)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p></blockquote><p>饱汉模式最容易出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 首先，也是先堵死 new Singleton() 这条路</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">// 这一次判断也是必须的，不然会有并发问题</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>双重检查，指的是两次检查 instance 是否为 null。</p><p>volatile 在这里是需要的，希望能引起读者的关注。</p><p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p></blockquote><p>嵌套类最经典，以后大家就用它吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton3</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton3</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton3</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton3</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Holder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p></blockquote><p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p><p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Food</span> <span class="hljs-variable">food</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FoodBuilder</span>().a().b().c().build();<br><span class="hljs-type">Food</span> <span class="hljs-variable">food</span> <span class="hljs-operator">=</span> Food.builder().a().b().c().build();<br></code></pre></td></tr></table></figure><p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p><p>来一个中规中矩的建造者模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">// 下面是“一堆”的属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String nickName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, String password, String nickName, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.password = password;<br>        <span class="hljs-built_in">this</span>.nickName = nickName;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><span class="hljs-comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span><br>    <span class="hljs-comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserBuilder <span class="hljs-title function_">builder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBuilder</span>();<br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBuilder</span> &#123;<br>        <span class="hljs-comment">// 下面是和 User 一模一样的一堆属性</span><br>        <span class="hljs-keyword">private</span> String  name;<br>        <span class="hljs-keyword">private</span> String password;<br>        <span class="hljs-keyword">private</span> String nickName;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">UserBuilder</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br><br>        <span class="hljs-comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span><br>        <span class="hljs-keyword">public</span> UserBuilder <span class="hljs-title function_">name</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> UserBuilder <span class="hljs-title function_">password</span><span class="hljs-params">(String password)</span> &#123;<br>            <span class="hljs-built_in">this</span>.password = password;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> UserBuilder <span class="hljs-title function_">nickName</span><span class="hljs-params">(String nickName)</span> &#123;<br>            <span class="hljs-built_in">this</span>.nickName = nickName;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> UserBuilder <span class="hljs-title function_">age</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span><br>        <span class="hljs-comment">// 当然，可以在 “复制” 之前做点检验</span><br>        <span class="hljs-keyword">public</span> User <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span> || password == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户名和密码必填&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (age &lt;= <span class="hljs-number">0</span> || age &gt;= <span class="hljs-number">150</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;年龄不合法&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 还可以做赋予”默认值“的功能</span><br>          <span class="hljs-keyword">if</span> (nickName == <span class="hljs-literal">null</span>) &#123;<br>                nickName = name;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(name, password, nickName, age);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p><p>看看客户端的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">APP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> User.builder()<br>                .name(<span class="hljs-string">&quot;foo&quot;</span>)<br>                .password(<span class="hljs-string">&quot;pAss12345&quot;</span>)<br>                .age(<span class="hljs-number">25</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p><blockquote><p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Builder</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String  name;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String nickName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>怎么样，省下来的时间是不是又可以干点别的了。</p></blockquote><p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>().setName(<span class="hljs-string">&quot;&quot;</span>).setPassword(<span class="hljs-string">&quot;&quot;</span>).setAge(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><blockquote><p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p></blockquote><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p><p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p><p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><blockquote><p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p></blockquote><p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p><h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p><p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p><blockquote><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FoodService</span> &#123;<br>    Food <span class="hljs-title function_">makeChicken</span><span class="hljs-params">()</span>;<br>    Food <span class="hljs-title function_">makeNoodle</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FoodService</span> &#123;<br>    <span class="hljs-keyword">public</span> Food <span class="hljs-title function_">makeChicken</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Food</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chicken</span>()<br>        f.setChicken(<span class="hljs-string">&quot;1kg&quot;</span>);<br>      f.setSpicy(<span class="hljs-string">&quot;1g&quot;</span>);<br>      f.setSalt(<span class="hljs-string">&quot;3g&quot;</span>);<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Food <span class="hljs-title function_">makeNoodle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Food</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Noodle</span>();<br>        f.setNoodle(<span class="hljs-string">&quot;500g&quot;</span>);<br>        f.setSalt(<span class="hljs-string">&quot;5g&quot;</span>);<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FoodService</span> &#123;<br>  <br>    <span class="hljs-comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">FoodService</span> <span class="hljs-variable">foodService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FoodServiceImpl</span>();<br>    <br>    <span class="hljs-keyword">public</span> Food <span class="hljs-title function_">makeChicken</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我们马上要开始制作鸡肉了&quot;</span>);<br>      <br>        <span class="hljs-comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span><br>        <span class="hljs-comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span><br>        <span class="hljs-type">Food</span> <span class="hljs-variable">food</span> <span class="hljs-operator">=</span> foodService.makeChicken();<br>      <br>        System.out.println(<span class="hljs-string">&quot;鸡肉制作完成啦，加点胡椒粉&quot;</span>); <span class="hljs-comment">// 增强</span><br>      food.addCondiment(<span class="hljs-string">&quot;pepper&quot;</span>);<br>      <br>        <span class="hljs-keyword">return</span> food;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Food <span class="hljs-title function_">makeNoodle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;准备制作拉面~&quot;</span>);<br>        <span class="hljs-type">Food</span> <span class="hljs-variable">food</span> <span class="hljs-operator">=</span> foodService.makeNoodle();<br>        System.out.println(<span class="hljs-string">&quot;制作完成啦&quot;</span>)<br>        <span class="hljs-keyword">return</span> food;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用，注意，我们要用代理来实例化接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里用代理类来实例化</span><br><span class="hljs-type">FoodService</span> <span class="hljs-variable">foodService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FoodServiceProxy</span>();<br>foodService.makeChicken();<br></code></pre></td></tr></table></figure><p><img src="https://www.javadoop.com/blogimages/design-pattern/proxy-1.png" alt="proxy"></p><p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p><p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p><p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p><p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。</p><p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileAlterationListener</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">(<span class="hljs-keyword">final</span> FileAlterationObserver observer)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDirectoryCreate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File directory)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDirectoryChange</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File directory)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDirectoryDelete</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File directory)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFileCreate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File file)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFileChange</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File file)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFileDelete</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File file)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStop</span><span class="hljs-params">(<span class="hljs-keyword">final</span> FileAlterationObserver observer)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p><p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileAlterationListenerAdaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileAlterationListener</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">(<span class="hljs-keyword">final</span> FileAlterationObserver observer)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDirectoryCreate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File directory)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDirectoryChange</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File directory)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDirectoryDelete</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File directory)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFileCreate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File file)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFileChange</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File file)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFileDelete</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File file)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStop</span><span class="hljs-params">(<span class="hljs-keyword">final</span> FileAlterationObserver observer)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileMonitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FileAlterationListenerAdaptor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFileCreate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File file)</span> &#123;<br>        <span class="hljs-comment">// 文件创建</span><br>        doSomething();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFileDelete</span><span class="hljs-params">(<span class="hljs-keyword">final</span> File file)</span> &#123;<br>        <span class="hljs-comment">// 文件删除</span><br>        doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p><h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Duck</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 鸭的呱呱叫</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 飞</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gobble</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 鸡的咕咕叫</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 飞</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WildCock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gobble</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;咕咕叫&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;鸡也会飞哦&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CockAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Duck</span> &#123;<br>  <br>    Cock cock;<br>    <span class="hljs-comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CockAdapter</span><span class="hljs-params">(Cock cock)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cock = cock;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 实现鸭的呱呱叫方法</span><br>    <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 内部其实是一只鸡的咕咕叫</span><br>        cock.gobble();<br>    &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        cock.fly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用很简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 有一只野鸡</span><br>  <span class="hljs-type">Cock</span> <span class="hljs-variable">wildCock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WildCock</span>();<br>  <span class="hljs-comment">// 成功将野鸡适配成鸭</span><br>  <span class="hljs-type">Duck</span> <span class="hljs-variable">duck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CockAdapter</span>(wildCock);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p><p>我们用一个图来简单说明下：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-1.png" alt="adapter-1"></p><p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p><h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-2.png" alt="adapter-1"></p><p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p><h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol><li><p>类适配和对象适配的异同</p><blockquote><p>一个采用继承，一个采用组合；</p><p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p><p>总体来说，对象适配用得比较多。</p></blockquote></li><li><p>适配器模式和代理模式的异同</p><p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-5.png" alt="adapter-5"></p></li></ol><h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p><p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DrawAPI</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是一系列实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedPen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DrawAPI</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="hljs-string">&quot;, x:&quot;</span> + x + <span class="hljs-string">&quot;, y:&quot;</span> + y);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreenPen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DrawAPI</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="hljs-string">&quot;, x:&quot;</span> + x + <span class="hljs-string">&quot;, y:&quot;</span> + y);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BluePen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DrawAPI</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="hljs-string">&quot;, x:&quot;</span> + x + <span class="hljs-string">&quot;, y:&quot;</span> + y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">protected</span> DrawAPI drawAPI;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Shape</span><span class="hljs-params">(DrawAPI drawAPI)</span> &#123;<br>        <span class="hljs-built_in">this</span>.drawAPI = drawAPI;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义抽象类的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 圆形</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> radius;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, DrawAPI drawAPI)</span> &#123;<br>        <span class="hljs-built_in">super</span>(drawAPI);<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        drawAPI.draw(radius, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 长方形</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rectangle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, DrawAPI drawAPI)</span> &#123;<br>        <span class="hljs-built_in">super</span>(drawAPI);<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        drawAPI.draw(<span class="hljs-number">0</span>, x, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们来看客户端演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Shape</span> <span class="hljs-variable">greenCircle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GreenPen</span>());<br>    <span class="hljs-type">Shape</span> <span class="hljs-variable">redRectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedPen</span>());<br>    greenCircle.draw();<br>    redRectangle.draw();<br>&#125;<br></code></pre></td></tr></table></figure><p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p><p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p><blockquote><p>本节引用了<a href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm">这里</a>的例子，并对其进行了修改。</p></blockquote><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p><p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-1.png" alt="decorator-1"></p><p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p><blockquote><p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p></blockquote><p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator</strong>* 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p><blockquote><p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p></blockquote><p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p><p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p><p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p><p>不说废话了，上代码。</p><p>首先，定义饮料抽象基类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Beverage</span> &#123;<br>  <span class="hljs-comment">// 返回描述</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">// 返回价格</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackTea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Beverage</span> &#123;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;红茶&quot;</span>;<br>    &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreenTea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;绿茶&quot;</span>;<br>    &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>    &#125;<br>&#125;<br>...<span class="hljs-comment">// 咖啡省略</span><br></code></pre></td></tr></table></figure><p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调料</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Condiment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Beverage</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lemon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Condiment</span> &#123;<br>    <span class="hljs-keyword">private</span> Beverage bevarage;<br>    <span class="hljs-comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span><br>    <span class="hljs-comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Lemon</span><span class="hljs-params">(Beverage bevarage)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bevarage = bevarage;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 装饰</span><br>        <span class="hljs-keyword">return</span> bevarage.getDescription() + <span class="hljs-string">&quot;, 加柠檬&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 装饰</span><br>        <span class="hljs-keyword">return</span> beverage.cost() + <span class="hljs-number">2</span>; <span class="hljs-comment">// 加柠檬需要 2 元</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mango</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Condiment</span> &#123;<br>    <span class="hljs-keyword">private</span> Beverage bevarage;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mango</span><span class="hljs-params">(Beverage bevarage)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bevarage = bevarage;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> bevarage.getDescription() + <span class="hljs-string">&quot;, 加芒果&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> beverage.cost() + <span class="hljs-number">3</span>; <span class="hljs-comment">// 加芒果需要 3 元</span><br>    &#125;<br>&#125;<br>...<span class="hljs-comment">// 给每一种调料都加一个类</span><br></code></pre></td></tr></table></figure><p>看客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span><br>    <span class="hljs-type">Beverage</span> <span class="hljs-variable">beverage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GreenTea</span>();<br>    <span class="hljs-comment">// 开始装饰</span><br>    beverage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lemon</span>(beverage); <span class="hljs-comment">// 先加一份柠檬</span><br>    beverage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mongo</span>(beverage); <span class="hljs-comment">// 再加一份芒果</span><br><br>    System.out.println(beverage.getDescription() + <span class="hljs-string">&quot; 价格：￥&quot;</span> + beverage.cost());<br>    <span class="hljs-comment">//&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Beverage</span> <span class="hljs-variable">beverage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mongo</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pearl</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Lemon</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Lemon</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackTea</span>()))));<br></code></pre></td></tr></table></figure><p>是不是很变态？</p><p>看看下图可能会清晰一些：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-2.png" alt="decorator-2"></p><p>到这里，大家应该已经清楚装饰模式了吧。</p><p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-3.png" alt="decorator-3"></p><p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p><p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LineNumberInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;&quot;</span>)));<br><br></code></pre></td></tr></table></figure><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p><p>我们应该像下面这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<br>                              <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;&quot;</span>)));<br></code></pre></td></tr></table></figure><blockquote><p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p></blockquote><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p><p>首先，我们定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义几个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;Circle::draw()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;Rectangle::draw()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 画一个圆形</span><br>  <span class="hljs-type">Shape</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br>  circle.draw();<br>  <br>  <span class="hljs-comment">// 画一个长方形</span><br>  <span class="hljs-type">Shape</span> <span class="hljs-variable">rectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>  rectangle.draw();<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p><p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p><p>我们先定义一个门面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeMaker</span> &#123;<br>   <span class="hljs-keyword">private</span> Shape circle;<br>   <span class="hljs-keyword">private</span> Shape rectangle;<br>   <span class="hljs-keyword">private</span> Shape square;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShapeMaker</span><span class="hljs-params">()</span> &#123;<br>      circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br>      rectangle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>      square = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();<br>   &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span><br><span class="hljs-comment">   */</span><br>  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">()</span>&#123;<br>      circle.draw();<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawRectangle</span><span class="hljs-params">()</span>&#123;<br>      rectangle.draw();<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSquare</span><span class="hljs-params">()</span>&#123;<br>      square.draw();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看看现在客户端怎么调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">ShapeMaker</span> <span class="hljs-variable">shapeMaker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShapeMaker</span>();<br><br>  <span class="hljs-comment">// 客户端调用现在更加清晰了</span><br>  shapeMaker.drawCircle();<br>  shapeMaker.drawRectangle();<br>  shapeMaker.drawSquare();<br>&#125;<br></code></pre></td></tr></table></figure><p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p><p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> String dept;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> salary;<br>   <span class="hljs-keyword">private</span> List&lt;Employee&gt; subordinates; <span class="hljs-comment">// 下属</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name,String dept, <span class="hljs-type">int</span> sal)</span> &#123;<br>      <span class="hljs-built_in">this</span>.name = name;<br>      <span class="hljs-built_in">this</span>.dept = dept;<br>      <span class="hljs-built_in">this</span>.salary = sal;<br>      subordinates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Employee&gt;();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Employee e)</span> &#123;<br>      subordinates.add(e);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Employee e)</span> &#123;<br>      subordinates.remove(e);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">getSubordinates</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-keyword">return</span> subordinates;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;Employee :[ Name : &quot;</span> + name + <span class="hljs-string">&quot;, dept : &quot;</span> + dept + <span class="hljs-string">&quot;, salary :&quot;</span> + salary+<span class="hljs-string">&quot; ]&quot;</span>);<br>   &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p><p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p><p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p><p>这种简单的代码我就不演示了。</p><h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p><p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p><p>首先，先定义一个策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们定义具体的几个策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedPen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="hljs-string">&quot;, x:&quot;</span> + x + <span class="hljs-string">&quot;, y:&quot;</span> + y);<br>   &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreenPen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="hljs-string">&quot;, x:&quot;</span> + x + <span class="hljs-string">&quot;, y:&quot;</span> + y);<br>   &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BluePen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="hljs-string">&quot;, x:&quot;</span> + x + <span class="hljs-string">&quot;, y:&quot;</span> + y);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用策略的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>   <span class="hljs-keyword">private</span> Strategy strategy;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(Strategy strategy)</span>&#123;<br>      <span class="hljs-built_in">this</span>.strategy = strategy;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">executeDraw</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>      <span class="hljs-keyword">return</span> strategy.draw(radius, x, y);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BluePen</span>()); <span class="hljs-comment">// 使用绿色笔来画</span><br>  context.executeDraw(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>放到一张图上，让大家看得清晰些：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/strategy-1.png" alt="strategy-1"></p><p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p><p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p><p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> state;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>        <span class="hljs-comment">// 数据已变更，通知观察者们</span><br>        notifyAllObservers();<br>    &#125;<br>    <span class="hljs-comment">// 注册观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.add(observer);<br>    &#125;<br>    <span class="hljs-comment">// 通知观察者们</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAllObservers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>            observer.update();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义观察者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">protected</span> Subject subject;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p><p>我们来定义具体的几个观察者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">// 在构造方法中进行订阅主题</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BinaryObserver</span><span class="hljs-params">(Subject subject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.subject = subject;<br>        <span class="hljs-comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span><br>        <span class="hljs-built_in">this</span>.subject.attach(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">// 该方法由主题类在数据变更的时候进行调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.toBinaryString(subject.getState());<br>        System.out.println(<span class="hljs-string">&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot;</span> + result);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HexaObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HexaObserver</span><span class="hljs-params">(Subject subject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.subject = subject;<br>        <span class="hljs-built_in">this</span>.subject.attach(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.toHexString(subject.getState()).toUpperCase();<br>        System.out.println(<span class="hljs-string">&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端使用也非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 先定义一个主题</span><br>    <span class="hljs-type">Subject</span> <span class="hljs-variable">subject1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();<br>    <span class="hljs-comment">// 定义观察者</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryObserver</span>(subject1);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HexaObserver</span>(subject1);<br>  <br>    <span class="hljs-comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span><br>    subject.setState(<span class="hljs-number">11</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">订阅的数据发生变化，新的数据处理为二进制值为：<span class="hljs-number">1011</span><br>订阅的数据发生变化，新的数据处理为十六进制值为：<span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p><p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p><blockquote><p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p></blockquote><p>首先，我们要定义流程上节点的基类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleHandler</span> &#123;<br>    <span class="hljs-comment">// 后继节点</span><br>    <span class="hljs-keyword">protected</span> RuleHandler successor;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Context context)</span>;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(RuleHandler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> RuleHandler <span class="hljs-title function_">getSuccessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> successor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们需要定义具体的每个节点了。</p><p>校验用户是否是新用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewUserRuleHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuleHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-keyword">if</span> (context.isNewUser()) &#123;<br>            <span class="hljs-comment">// 如果有后继节点的话，传递下去</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getSuccessor() != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.getSuccessor().apply(context);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;该活动仅限新用户参与&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>校验用户所在地区是否可以参与：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocationRuleHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuleHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">allowed</span> <span class="hljs-operator">=</span> activityService.isSupportedLocation(context.getLocation);<br>        <span class="hljs-keyword">if</span> (allowed) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getSuccessor() != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.getSuccessor().apply(context);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;非常抱歉，您所在的地区无法参与本次活动&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>校验奖品是否已领完：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitRuleHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuleHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remainedTimes</span> <span class="hljs-operator">=</span> activityService.queryRemainedTimes(context); <span class="hljs-comment">// 查询剩余奖品</span><br>        <span class="hljs-keyword">if</span> (remainedTimes &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getSuccessor() != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.getSuccessor().apply(userInfo);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;您来得太晚了，奖品被领完了&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">RuleHandler</span> <span class="hljs-variable">newUserHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewUserRuleHandler</span>();<br>    <span class="hljs-type">RuleHandler</span> <span class="hljs-variable">locationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocationRuleHandler</span>();<br>    <span class="hljs-type">RuleHandler</span> <span class="hljs-variable">limitHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LimitRuleHandler</span>();<br>  <br>    <span class="hljs-comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span><br>    locationHandler.setSuccessor(limitHandler);<br>  <br>    locationHandler.apply(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p><p>通常会有一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractTemplate</span> &#123;<br>    <span class="hljs-comment">// 这就是模板方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span> &#123;<br>        init();<br>        apply(); <span class="hljs-comment">// 这个是重点</span><br>        end(); <span class="hljs-comment">// 可以作为钩子方法</span><br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;init 抽象层已经实现，子类也可以选择覆写&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 留给子类实现</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p><p>我们写一个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteTemplate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTemplate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类实现抽象方法 apply&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AbstractTemplate</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteTemplate</span>();<br>    <span class="hljs-comment">// 调用模板方法</span><br>    t.templateMethod();<br>&#125;<br></code></pre></td></tr></table></figure><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p><p>定义状态接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAction</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义减库存的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeductState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAction</span><span class="hljs-params">(Context context)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;商品卖出，准备减库存&quot;</span>);<br>        context.setState(<span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-comment">//... 执行减库存的具体操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Deduct State&quot;</span>;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>定义补库存状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RevertState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">State</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAction</span><span class="hljs-params">(Context context)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;给此商品补库存&quot;</span>);<br>        context.setState(<span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-comment">//... 执行加库存的具体操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Revert State&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-keyword">private</span> State state;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看下客户端调用，大家就一清二楚了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 我们需要操作的是 iPhone X</span><br>    <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-string">&quot;iPhone X&quot;</span>);<br>  <br>    <span class="hljs-comment">// 看看怎么进行补库存操作</span><br>  <span class="hljs-type">State</span> <span class="hljs-variable">revertState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RevertState</span>();<br>  revertState.doAction(context);<br>  <br>    <span class="hljs-comment">// 同样的，减库存操作也非常简单</span><br>  <span class="hljs-type">State</span> <span class="hljs-variable">deductState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeductState</span>();<br>  deductState.doAction(context);<br>  <br>  <span class="hljs-comment">// 如果需要我们可以获取当前的状态</span><br>    <span class="hljs-comment">// context.getState().toString();</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p><p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p><p>（全文完）</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学期总结 2018-2019（二）</title>
    <link href="/2019-09-30-life-semester-summary-2019-2/"/>
    <url>/2019-09-30-life-semester-summary-2019-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>317实验室的学期总结来了，像我这样优秀的人当然是积极参与。</p><span id="more"></span><p>包老师名句镇楼：</p><blockquote><p>努力在于无时无刻，进步在于不知不觉。</p></blockquote><h3 id="学期总结"><a href="#学期总结" class="headerlink" title="学期总结"></a>学期总结</h3><p>转眼间，我们度过了研二下学期，这一学期我遇到了一些困难，经历了一些挫折，挥洒一些汗水，最终还是收获了一些成果。</p><p>新年过后，学期一开始我们便全力投入到智慧校园项目中，在大家的共同努力下克服了所有的开发问题，项目最终能够如期上线。项目部署场景至今历历在目，我看着项目组的设备一个个安装完毕，成功连接到服务器，校园用户一个个排着队录入指纹，然后扫码下载APP，注册、登录、使用、反馈，那是一种紧张又期待的心情。紧张的是产品能否适应现场环境，软件能否正常运行；期待的是用户对产品的认可，产品能够达到预期的设计意图。虽然用户陆续反馈了一些问题，好在我们都能很好地解决这些问题，一遍遍打磨之后让产品更稳定，直到现在可以进行量产。</p><p>回头看看，自己学到的知识和技能可以在实际项目中得以实践，是一件值得庆幸的事情，确实对我有所提升。在项目得到阶段性进展后，我们研二同学开始投入到论文中了，这对于天天敲代码的我们来说，简直是一场锤炼啊！</p><p>开始写论文的时候，自然是一脸，不，是一头雾水，只能循规蹈矩地阅读文献，琢磨为了创新而创新的“创新点”。一次次地创新，一次次地讨论，再一次次地自我否定，最终还是在脑壳上“凿了个洞”，成功地琢磨出了一个创新点。有了idea之后就下手写吧，写了摘要和引言，本来自己还蛮欣赏自己的“才华”，结果包老师说写出来的是科普文，不是论文呀。即便万念俱灰，我也不能放弃，因为我想把该做完的事情做完，然后好好放松下（后来证明放松是不可能的，因为接下来的事情更辛苦）。在包老师和厉害同学的帮助下，我还是打磨出了自己的论文，还给自己的论文起了一个很厉害的名字，这也是我认为本文最亮的创新点，结果证明那名字有点“飞扬跋扈”了，最终还是把名字改得中规中矩的。</p><p>论文投出去还没有结果，在此许下愿望，希望最终可以被录用。前面说了，论文写完也闲不住啊，之后把全部精力放在了找工作上，这又是一场残酷的历练。</p><p>刚开始以为自己有项目经验，用Java有5年了吧，还有博客加特，一线互联网大厂需要我这样的人才啊。不多久，网易的笔试一巴掌把我打醒了，更甚者，投了其它几个公司简历直接进入公海池，然后我发现原来这才是现实啊。灰头土脸的我选择埋头学习，看日常开发技术的基础，学习笔试算法，不断地投简历、笔试、面试，也明白了秋招不是找工作，应该叫求职。讲一点自己的感受，平时学习和做项目，一定要注重积累总结，不能满足于调用API 完成业务逻辑，要了解实现原理，因为面试问的就是原理和基础。还有一点就是，不管能不能面试成功大厂都要投递，因为哪怕是大厂的面试对你也是有提升的。</p><p>这一学期，不管是项目、论文、还是求职，都离不开包老师、包总和同学们的帮助，一起走来两年了，还是要深深地感谢你们。</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长之路</tag>
      
      <tag>学期总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM - 参数配置影响线程数</title>
    <link href="/2019-09-29-java-jvm-thread-params/"/>
    <url>/2019-09-29-java-jvm-thread-params/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道面试</p><p>找工作是个脑力活也是个体力活啊，最近秋招给我累得够呛，昨天面了杭州大华，被一道 JVM 参数的问题难住了。</p><span id="more"></span><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>面试官：说个常用的 JVM 参数</p><p>我：好像有个什么 -Xms，不常用大太熟悉这些参数（语塞中…，本来背了几个，一紧张还是忘了）</p><p>面试官：如果 -Xmx 调大，线程数怎么变化</p><p>我：变小</p><p>面试官：为什么</p><p>我：猜的。。。</p></blockquote><p>虽然最后挨到 HR 面，但还是要把面试题捋一捋的。</p><h2 id="一、题目相关参数"><a href="#一、题目相关参数" class="headerlink" title="一、题目相关参数"></a>一、题目相关参数</h2><h3 id="1-1-三个重要参数"><a href="#1-1-三个重要参数" class="headerlink" title="1.1 三个重要参数"></a>1.1 三个重要参数</h3><ul><li><strong>-Xms</strong> 为 jvm 启动时分配 Heap初始内存(最小内存)，比如<code>-Xms200m</code>，表示分配200M</li><li><strong>-Xmx</strong> 为 jvm 运行过程中分配 Heap最大内存，比如<code>-Xms500m</code>，表示jvm进程最多只能够占用500M内存</li><li>-<strong>Xss</strong> 为 jvm 启动的每个线程分配的内存大小(stack size)，默认JDK1.4中是256K，JDK1.5+中是1M</li></ul><p>通常，<code>-Xms</code> 和 <code>-Xmx</code> 设置成一样的，避免每次垃圾回收完成后JVM重新分配内存。因为当Heap不够用时，发生内存抖动，影响程序运行稳定性。</p><h3 id="1-2-线程数的变动"><a href="#1-2-线程数的变动" class="headerlink" title="1.2 线程数的变动"></a>1.2 线程数的变动</h3><p>准确来说，是 jvm 可生产线程数的数量，由三个方面影响：</p><ul><li>jvm 的堆内存大小</li><li>Thread 的 Stack内存大小</li><li>系统最大可创建的线程数量</li></ul><p>增大堆内存（**-Xms，-Xmx<strong>）会减少可创建的线程数量；增大线程栈内存（</strong>-Xss**，32 位系统中此参数值最小为 60 K）也会减少可创建的线程数量。因此题中， <code>-Xmx</code> 加大，Heap内存增大，jvm 空闲的内存数（java虚拟机栈等）就更少，那么可以创建的线程也就更少。</p><p>系统从以下几个方面影响最大线程数：</p><ul><li>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max，</li><li>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;thread-max，</li><li>max_user_process（ulimit -u），</li><li>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;max_map_count</li></ul><p>具体影响过程参考 <a href="https://blog.csdn.net/moonpure/article/details/80701878">https://blog.csdn.net/moonpure/article/details/80701878</a></p><h3 id="1-3-三个内存方法"><a href="#1-3-三个内存方法" class="headerlink" title="1.3 三个内存方法"></a>1.3 三个内存方法</h3><p>java.lang.Runtime 类中的 freeMemory(), totalMemory(), maxMemory() 这几个方法反映的都是 java 这个进程的内存情况，跟操作系统的内存根本没有关系。</p><h4 id="maxMemory"><a href="#maxMemory" class="headerlink" title="maxMemory()"></a>maxMemory()</h4><p>返回的是<strong>java虚拟机（这个进程）</strong>能构从操作系统那里挖到的最大的内存，以字节为单位，如果在运行 java 程序的时候，没有添加 -Xmx 参数，那么就是 64 M，也就是说 maxMemory() 返回的大约是64<em>1024</em>1024 字节，这是 java 虚拟机默认情况下能从操作系统那里挖到的最大的内存。如果添加了 -Xmx 参数，将以这个参数后面的值为准，例如<code>java -cp you_classpath -Xmx512m your_class</code>，那么最大内存就是 512<em>1024</em>1024 字节。</p><h4 id="totalMemory"><a href="#totalMemory" class="headerlink" title="totalMemory()"></a>totalMemory()</h4><p>返回的是 java 虚拟机现在已经从操作系统那里挖过来的内存大小，也就是java虚拟机这个进程当时所占用的所有内存。如果在运行 java 的时候没有添加 -Xms 参数，那么，在 java 程序运行的过程的，内存总是慢慢的从操作系统那里挖的，基本上是用多少挖多少，直到挖到 maxMemory() 为止，所以totalMemory() 是慢慢增大的。如果用了 -Xms 参数，程序在启动的时候就会无条件的从操作系统中挖 -Xms后面定义的内存数，然后在这些内存用的差不多的时候，再去挖。</p><h4 id="freeMemory"><a href="#freeMemory" class="headerlink" title="freeMemory()"></a>freeMemory()</h4><p>刚才讲到如果在运行java的时候没有添加 -Xms 参数，那么，在 java 程序运行的过程的，内存总是慢慢的从操作系统那里挖的，基本上是用多少挖多少，但是 java 虚拟机100％的情况下是会稍微多挖一点的，这些挖过来而又没有用上的内存，实际上就是 freeMemory()，所以freeMemory()的值一般情况下都是很小的，但是如果你在运行 java 程序的时候使用了 -Xms，这个时候因为程序在启动的时候就会无条件的从操作系统中挖 -Xms 后面定义的内存数，这个时候，挖过来的内存可能大部分没用上，所以这个时候 freeMemory() 可能会有些大。  </p><h2 id="二、常用参数"><a href="#二、常用参数" class="headerlink" title="二、常用参数"></a>二、常用参数</h2><h3 id="2-1-堆设置"><a href="#2-1-堆设置" class="headerlink" title="2.1 堆设置"></a>2.1 堆设置</h3><ul><li>-Xms：初始堆大小</li><li>-Xmx：最大堆大小</li><li>-XX:NewSize&#x3D;n：设置年轻代大小</li><li>-XX:NewRatio&#x3D;n：设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年代年老代和的1&#x2F;4</li><li>-XX:SurvivorRatio&#x3D;n：年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor&#x3D;3：2，一个Survivor区占整个年轻代的1&#x2F;5</li><li>-XX:MaxPermSize&#x3D;n：设置持久代大小</li></ul><p>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k<br>-Xmx3550m <span class="hljs-comment"># 设置JVM最大可用内存为3550M。</span><br>-Xms3550m <span class="hljs-comment"># 设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</span><br>-Xmn2g <span class="hljs-comment"># 设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</span><br>-Xss128k <span class="hljs-comment"># 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</span><br></code></pre></td></tr></table></figure><p>依据的原则是根据Java Performance里面的推荐公式来进行设置。</p><p><img src="https://blogres.blackist.org/dev-201909291451-574.png"></p><p>具体来讲：</p><ul><li>Java整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍</li><li>永久代 PermSize和MaxPermSize设置为老年代存活对象的1.2-1.5倍。</li><li>年轻代Xmn的设置为老年代存活对象的1-1.5倍。</li><li>老年代的内存大小设置为老年代存活对象的2-3倍。</li></ul><p>BTW：</p><p>1、Sun官方建议年轻代的大小为整个堆的3&#x2F;8左右， 所以按照上述设置的方式，基本符合Sun的建议。     </p><p>2、堆大小&#x3D;年轻代大小+年老代大小， 即 xmx&#x3D;xmn+老年代大小 。 Permsize不影响堆大小。</p><p>3、为什么要按照上面的来进行设置呢？ 没有具体的说明，但应该是根据多种调优之后得出的一个结论。</p><p>具体调整策略参考 <a href="https://blog.csdn.net/losetowin/article/details/78569001">https://blog.csdn.net/losetowin/article/details/78569001</a></p><h3 id="2-2-收集器设置"><a href="#2-2-收集器设置" class="headerlink" title="2.2 收集器设置"></a>2.2 收集器设置</h3><ul><li>-XX:+UseSerialGC :设置串行收集器</li><li>-XX:+UseParallelGC :设置并行收集器</li><li>-XX:+UseParalledlOldGC :设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC :设置并发收集器</li></ul><p>JVM给了三种选择：串行收集器、并行收集器、并发收集器 ，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0 以后，JVM会根据当前<a href="http://java.sun.com/j2se/1.5.0/docs/guide/vm/server-class.html">系统配置</a></p><h4 id="吞吐量优先-的并行收集器"><a href="#吞吐量优先-的并行收集器" class="headerlink" title="吞吐量优先 的并行收集器"></a>吞吐量优先 的并行收集器</h4><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。</p><p>典型配置 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20<br>-XX:+UseParallelGC <span class="hljs-comment"># 选择垃圾收集器为并行收集器。 此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</span><br>-XX:ParallelGCThreads=20 <span class="hljs-comment"># 配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</span><br></code></pre></td></tr></table></figure><h4 id="响应时间优先-的并发收集器"><a href="#响应时间优先-的并发收集器" class="headerlink" title="响应时间优先 的并发收集器"></a>响应时间优先 的并发收集器</h4><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。<br>典型配置 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC<br>-XX:+UseConcMarkSweepGC <span class="hljs-comment"># 设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</span><br>-XX:+UseParNewGC <span class="hljs-comment"># 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</span><br></code></pre></td></tr></table></figure><h3 id="2-3-垃圾回收统计信息"><a href="#2-3-垃圾回收统计信息" class="headerlink" title="2.3 垃圾回收统计信息"></a>2.3 垃圾回收统计信息</h3><p>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename</p><h3 id="2-4-并行收集器设置"><a href="#2-4-并行收集器设置" class="headerlink" title="2.4 并行收集器设置"></a>2.4 并行收集器设置</h3><p>-XX:ParallelGCThreads&#x3D;n :设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis&#x3D;n :设置并行收集最大暂停时间<br>-XX:GCTimeRatio&#x3D;n :设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</p><h3 id="2-5-并发收集器设置"><a href="#2-5-并发收集器设置" class="headerlink" title="2.5 并发收集器设置"></a>2.5 并发收集器设置</h3><p>-XX:+CMSIncrementalMode :设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads&#x3D;n :设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ceshi2016/p/8447989.html">https://www.cnblogs.com/ceshi2016/p/8447989.html</a></p><p><a href="https://blog.csdn.net/moonpure/article/details/80701878">https://blog.csdn.net/moonpure/article/details/80701878</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 - PNPoly处理点和多边形</title>
    <link href="/2019-08-28-arithmetic-coordinate-point-segment-dist/"/>
    <url>/2019-08-28-arithmetic-coordinate-point-segment-dist/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近做了一个算法题【盒马配货】：</p><blockquote><p>（题目大意）盒马店的配送范围由一些点组成的多边形确定，给定一个点判断其是否在配送范围内，若在，则此点不需要挪动，打印”no 0”；若不在，则给出此点需要挪动到配送范围的最短距离，打印”yes 距离”。</p></blockquote><span id="more"></span><h2 id="如何求解点到多边形的距离"><a href="#如何求解点到多边形的距离" class="headerlink" title="如何求解点到多边形的距离"></a>如何求解点到多边形的距离</h2><p>此题求解需要解决两个问题：</p><ul><li>点到多边形的边的最短距离。</li><li>点是否包含在多边形内。</li></ul><h2 id="点到边的距离"><a href="#点到边的距离" class="headerlink" title="点到边的距离"></a>点到边的距离</h2><p>计算点到多边形最短距离的基本原理是：依次计算点到多边形每条边的距离，然后筛选出最短距离。</p><p><img src="https://blogres.blackist.org/dev-201908281020-772.png"></p><p>如下图，假设AB为多边形的一条边，现在求点P到AB的距离。</p><p><img src="https://blogres.blackist.org/dev-201908281021-296.png"></p><p>根据向量内积公式(\vec a \cdot \vec b&#x3D;|a||b|\cos\theta)，我们可以推出：</p><p><img src="https://blogres.blackist.org/dev-201908281029-861.png"></p><p>根据以上公式，我们可以求出t，进而求出点D的坐标，最终PD的长度就很容易求得了。</p><p>但是还有一些边界条件需要注意，即最终D点不是落在AB上，有以下三种情况：</p><ul><li>t &lt; 0，D在BA延长线上，此时最短距离取PA；</li><li>0 &lt;&#x3D; t &lt;&#x3D; 1，D在AB上，此时最短距离取PD；</li><li>t &gt; 1，D在AB延长线上，此时最短距离取PB；</li></ul><p><img src="https://blogres.blackist.org/dev-201908281031-290.png"></p><p>Java实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">pointToSegmentDist</span><span class="hljs-params">(<span class="hljs-type">double</span> px, <span class="hljs-type">double</span> py, <span class="hljs-type">double</span> ax, <span class="hljs-type">double</span> ay, <span class="hljs-type">double</span> bx, <span class="hljs-type">double</span> by)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">ABx</span> <span class="hljs-operator">=</span> bx - ax;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">ABy</span> <span class="hljs-operator">=</span> by - ay;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">APx</span> <span class="hljs-operator">=</span> px - ax;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">APy</span> <span class="hljs-operator">=</span> py - ay;<br><br>    <span class="hljs-type">double</span> <span class="hljs-variable">AB_AP</span> <span class="hljs-operator">=</span> ABx * APx + ABy * APy;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">distAB2</span> <span class="hljs-operator">=</span> ABx * ABx + ABy * ABy;<br><br>    <span class="hljs-type">double</span> <span class="hljs-variable">Dx</span> <span class="hljs-operator">=</span> ax, Dy = ay;<br>    <span class="hljs-keyword">if</span> (distAB2 != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> AB_AP / distAB2;<br>        <span class="hljs-keyword">if</span> (t &gt;= <span class="hljs-number">1</span>) &#123;<br>            Dx = bx;<br>            Dy = by;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">0</span>) &#123;<br>            Dx = ax + ABx * t;<br>            Dy = ay + ABy * t;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Dx = ax;<br>            Dy = ay;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">double</span> <span class="hljs-variable">PDx</span> <span class="hljs-operator">=</span> Dx - px, PDy = Dy - py;<br><br>    <span class="hljs-keyword">return</span> Math.sqrt(PDx * PDx + PDy * PDy);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="点是否包含在多边形内"><a href="#点是否包含在多边形内" class="headerlink" title="点是否包含在多边形内"></a>点是否包含在多边形内</h2><p>根据W. Randolph Franklin 提出的<a href="https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html">PNPoly</a>算法，只需区区几行代码就解决了这个问题。</p><p>假设配送范围多边形的点横纵坐标分别存放在两个数组xs、ys里，(x,y)表示配送点的坐标，先贴代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">polygon</span><span class="hljs-params">(<span class="hljs-type">double</span>[] xs, <span class="hljs-type">double</span>[] ys, <span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">contained</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 点是否包含在多边形内</span><br><br>    <span class="hljs-type">double</span> <span class="hljs-variable">xMin</span> <span class="hljs-operator">=</span> Arrays.stream(xs).min().getAsDouble();<br>    <span class="hljs-type">double</span> <span class="hljs-variable">xMax</span> <span class="hljs-operator">=</span> Arrays.stream(xs).max().getAsDouble();<br>    <span class="hljs-type">double</span> <span class="hljs-variable">yMin</span> <span class="hljs-operator">=</span> Arrays.stream(ys).min().getAsDouble();<br>    <span class="hljs-type">double</span> <span class="hljs-variable">yMax</span> <span class="hljs-operator">=</span> Arrays.stream(ys).max().getAsDouble();<br><br>    <span class="hljs-keyword">if</span> (x &gt; xMax || x &lt; xMin || y &gt; yMax || y &lt; yMin) &#123;<br>        contained = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 核心算法部分</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> xs.length;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">dist</span> <span class="hljs-operator">=</span> Double.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = N - <span class="hljs-number">1</span>; i &lt; N; j = i++) &#123;<br>        <span class="hljs-keyword">if</span> (((ys[j] &gt; y) != (ys[i] &gt; y))<br>            &amp;&amp; (x &lt; (xs[j] - xs[i]) * (y - ys[i]) / (ys[j] - ys[i]) + xs[i])) &#123;<br>            contained = !contained;<br>        &#125;<br>        dist = Math.min(dist, pointToSegmentDist(x, y, xs[i], ys[i], xs[j], ys[j]));<br>    &#125;<br>    System.out.println(contained ? <span class="hljs-string">&quot;no 0&quot;</span> : <span class="hljs-string">&quot;yes&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + dist);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，我们需要取得该数组在横坐标和纵坐标的最大值和最小值，根据这四个点算出一个四边型，判断目标坐标点是否在这个四边型之内，如果在这个四边型之外，那可以跳过后面较为复杂的计算，直接返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x &gt; xMax || x &lt; xMin || y &gt; yMax || y &lt; yMin) &#123;<br>    contained = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是核心算法部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = N - <span class="hljs-number">1</span>; i &lt; N; j = i++) &#123;<br>    <span class="hljs-keyword">if</span> (((ys[j] &gt; y) != (ys[i] &gt; y))<br>    &amp;&amp; (x &lt; (xs[j] - xs[i]) * (y - ys[i]) / (ys[j] - ys[i]) + xs[i])) &#123;<br>    contained = !contained;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每次计算都涉及到相邻的两个点和待测试点，然后考虑两个问题：</p><ul><li><p>被测试点的纵坐标testy是否在本次循环所测试的两个相邻点纵坐标范围之内，即</p><p>ys[i] &lt;y &lt; ys[j]</p><p>或者</p><p>ys[j] &lt;y &lt; ys[i]。</p></li><li><p>待测点test是否在i,j两点之间的连线之下（相交判断）。</p></li></ul><p><strong>每次这两个条件同时满足的时候我们把返回的布尔量取反</strong>。</p><p>这个表达式的意思是说，随便画个多边形，随便定一个点，然后通过这个点水平划一条线，先数数看这条横线和多边形的边相交几次（可先排除那些不相交的边，即第一个判断条件），然后再数这条横线穿越多边形的次数是否为奇数，如果是奇数，那么该点在多边形内，如果是偶数，则在多边形外（射线法）。</p><h3 id="点在直线下-相交判断"><a href="#点在直线下-相交判断" class="headerlink" title="点在直线下 - 相交判断"></a>点在直线下 - 相交判断</h3><p>如下图，ab与过p点的水平线相交于c，</p><p><img src="https://blogres.blackist.org/dev-201908281110-490.png"></p><p>则有：</p><p><img src="https://blogres.blackist.org/dev-201908281111-204.png"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (((ys[j] &gt; y) != (ys[i] &gt; y))<br>&amp;&amp; (x &lt; (xs[j] - xs[i]) * (y - ys[i]) / (ys[j] - ys[i]) + xs[i])) &#123;<br>contained = !contained;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="点在多边形内部-射线法"><a href="#点在多边形内部-射线法" class="headerlink" title="点在多边形内部 - 射线法"></a>点在多边形内部 - 射线法</h3><p>判断点是否在多边形内，可以从这个点做一条射线，计算它跟多边形边界的交点个数，如果交点个数为奇数，那么点在多边形内部，否则点在多边形外。参考<a href="https://www.cnblogs.com/anningwang/p/7581545.html">https://www.cnblogs.com/anningwang/p/7581545.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html">https://wrf.ecse.rpi.edu//Research/Short_Notes&#x2F;pnpoly.html</a></p><p><a href="https://www.cnblogs.com/anningwang/p/7581545.html">https://www.cnblogs.com/anningwang/p/7581545.html</a></p><p><a href="https://jingsam.github.io/2016/09/26/polydist.html">https://jingsam.github.io/2016/09/26/polydist.html</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>坐标计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM - 运行时内存区域</title>
    <link href="/2019-07-07-java-jvm-jmm/"/>
    <url>/2019-07-07-java-jvm-jmm/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由<strong>JVM执行引擎</strong>执行。</p><p>那在整个程序执行过程中，JVM中怎么存取数据和相关信息呢？</p><p>事实上在JVM中是用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。</p><span id="more"></span><h2 id="一、运行时数据区域包括哪些"><a href="#一、运行时数据区域包括哪些" class="headerlink" title="一、运行时数据区域包括哪些"></a>一、运行时数据区域包括哪些</h2><p><img src="https://blogres.blackist.org/dev-201907071428-3.png"></p><p>根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：</p><ul><li><p>**程序计数器(Program Counter Register)**：线程私有的，记录当前线程的行号指示器，为线程的切换提供保障；</p></li><li><p>**Java虚拟机栈(Java Vitual Machine Stack)*<em>：线程私有的，主要存放</em>局部变量表*，操作数栈，动态链接和方法出口等；</p></li><li><p><strong>本地方法栈(Native Method Stack)</strong></p></li><li><p><strong>方法区(Method Area)<strong>：线程共享的，主要存储</strong>类信息、常量池、静态变量、JIT编译后的代码</strong>等数据。方法区理论上来说是堆的逻辑组成部分；<strong>运行时常量池</strong>是方法区的一部分，用于存放编译期生成的各种字面量和符号引用；</p></li><li><p><strong>堆(Heap)<strong>：所有线程共享的，主要用来存储对象。其中，堆可分为：</strong>年轻代和老年代</strong>两块区域。使用NewRatio参数来设定比例。对于年轻代，一个Eden区和两个Suvivor区，使用参数SuvivorRatio来设定大小；</p></li></ul><h2 id="二、各个部分存储的信息和负责的职能"><a href="#二、各个部分存储的信息和负责的职能" class="headerlink" title="二、各个部分存储的信息和负责的职能"></a>二、各个部分存储的信息和负责的职能</h2><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><p>这个内存区域是Java虚拟机规范中唯一一个没有规定任何OOM（OutOfMemoryError）情况的区域，这是这个区域最大的特点之一，这是因为程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p><p>这个区域主要是负责记录正在执行的虚拟机字节码指令地址，即当前线程执行的字节码的行号指示器（注意：JVM不是直接执行Java代码，而是执行.class文件，所以只要其他编程语言能翻译成.class文件一样能放入JVM中执行）。 <strong>JVM会给每个线程一个独立的程序计数器</strong>，计数器之间互不影响 ，且通过线程轮流切换并且分配处理器执行时间来实现JVM的多线程。不过当线程执行的是Native方法的时候这个计数器中的值为undefined。</p><h3 id="2、Java虚拟机栈"><a href="#2、Java虚拟机栈" class="headerlink" title="2、Java虚拟机栈"></a>2、Java虚拟机栈</h3><p>和程序计数器一样的是<strong>Java虚拟机栈是线程私有</strong>，生命周期和线程相同。虚拟机栈描述的是<strong>Java方法</strong>执行的内存模型：每个<strong>方法在执行的时候都会创建栈帧</strong>，用来存储局部变量表，操作数栈，动态链接，方法出口等信息，每个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机中入栈到出栈的过程，其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。 这里需要理解一下的就是为什么要用栈这个结构呢，比如A方法中调用了B方法，虚拟机中是先让A方法的栈帧进入虚拟机栈执行，当执行到调用B方法的语句就让B栈帧进入，执行完之后B栈帧就出栈，A栈就继续执行。这里注意的是如果递归的方法递归的太深很容易抛出下面两种异常，所以递归虽然写起来方便，但是性能会有所下降，并且容易抛出异常。</p><p>Java虚拟机规范中，对这个区域规定了两种异常状况</p><p>i. 线程请求栈的深度大于虚拟机所允许栈的深度，将抛出Stack Overflow Error</p><p>ii. 如果虚拟机栈可以动态扩展且扩展时无法申请到足够的内存，会抛出OutOfMemoryError</p><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>与虚拟机栈作用相似，不过是虚拟机栈为虚拟机执行Java方法提供，而本地方法为虚拟机使用到的Native方法服务，Native方法多是用C++写的。抛出的异常和虚拟机栈相同。</p><h3 id="4、Java堆"><a href="#4、Java堆" class="headerlink" title="4、Java堆"></a>4、Java堆</h3><p>Java堆是与前面的区域不同的是：这个区域是 <strong>被所有线程共享</strong> 的一块内存区域，用来<strong>存放对象实例，并为对象实例分配好内存</strong>。Java虚拟机规范中这样描述：所有对象实例以及数组都要在堆上分配。Java堆也是垃圾收集器管理的主要区域，也叫”GC堆“。由于现在的垃圾回收算法多是分代收集，所以Java堆里面又可分为：新生代和老年代。 并且根据Java虚拟机规范的规定：Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。有实例没有被分配，且堆无法再扩展的时候会抛出OutOfMemoryError异常，虚拟机调优其实也主要关注的是这个区域。</p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><p>与Java堆一样，<strong>线程共享</strong>，用来存储被虚拟机加载的<strong>类信息、常量、静态变量</strong>。这个区域Java虚拟机规范对其特别宽松，既可以像Java堆那样不需要连续内存，又可以选择固定大小和可扩展。还可以选择不实现垃圾收集，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="永久代和元空间"><a href="#永久代和元空间" class="headerlink" title="永久代和元空间"></a>永久代和元空间</h4><p>方法区是Java虚拟机规范中的定义，是一种规范，而永久代是HotSpot对方法区的一种实现，一个是标准一个是实现，即<strong>使用永久代来实现方法区</strong>；</p><ul><li>存储位置不同，永久代物理上是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；</li><li>存储内容不同，<strong>元空间(一块区域)存储类的元信息</strong>，<strong>静态变量和常量池等并入堆中</strong>。相当于永久代的数据被分到了堆和元空间中。</li></ul><p>对于Java8， HotSpots取消了永久代， 取代永久代的就是元空间。虚拟机Hotspot已经将这部分存储空间<strong>从使用JVM内存换成使用本地内存</strong>，即这部分不再叫永久代，而是<strong>元空间</strong>。这个元空间实际上是JVM动态规定内存大小。</p><p>这个替换有什么优势呢？因为字符串常量池是存在永久代中，很容易出现性能问题，并且类和方法信息大小难确定，给永久代的的大小指定带来困难，而且GC会对永久代特殊处理，这就增加了GC的复杂性。从JDK1.7开始，<strong>字符串常量池就划分进了堆中</strong>，也使得元空间在内存划分的算法上更趋于合理。</p><h4 id="Class文件常量池"><a href="#Class文件常量池" class="headerlink" title="Class文件常量池"></a><strong>Class文件常量池</strong></h4><p>Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池（Constant Pool Table），用于存放编译期生成的各种<strong>字面量和符号引用</strong>，这部分内容将<strong>在类加载后进入方法区的运行时常量池中存放</strong>。</p><p>这里的字面量是指<strong>字符串字面量和声明为 final 的（基本数据类型）常量值</strong>。</p><ul><li>字符串字面量：除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；</li><li>声明为final的常量值：指的是类的<strong>成员变量</strong>，不包含本地变量，<strong>本地变量是属于方法的</strong>。这些都在常量池的 UTF-8 表中(逻辑上的划分)；</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。<strong>一个类加载到 JVM 中后对应一个运行时常量池</strong>，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间<strong>将符号引用解析为直接引用</strong>。可以说运行时常量池就是用来<strong>索引和查找字段和方法名称和描述符</strong>的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。</p><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池是全局</strong>的，JVM 中独此一份，因此也称为全局字符串常量池。</p><p>运行时常量池中的字符串字面量若是成员的，则在类的加载初始化阶段就使用到了字符串常量池；若是本地的，则在使用到的时候（执行此代码时）才会使用到字符串常量池。其实，“使用常量池”对应的字节码是一个 ldc 指令，在给 String 类型的引用赋值的时候会先执行这个指令，看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用（jdk1.7)。</p><p>常量不一定只有编译期才能产生，运行期间也可以将新的常量放入池中。例如<strong>String的Intern()方法</strong>，同样抛出OutOfMemoryError异常。</p><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>JVM 中除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。其中：</p><ul><li>在 jdk1.6（含）之前也是方法区的一部分，并且其中存放的是字符串的实例；</li><li>在 jdk1.7（含）之后是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中；</li><li>jdk1.8 已移除永久代，字符串常量池是在本地内存当中，存储的也只是引用。</li></ul><h2 id="三、直接内存"><a href="#三、直接内存" class="headerlink" title="三、直接内存"></a>三、直接内存</h2><p>这个区域并不是属于运行时数据区域，但是这个区域也会被频繁使用，并且抛出OOM异常。这个区域主要是由于在JDK1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道与缓冲区的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，通过一个储存在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p><p>这样能避免在Java堆和Native堆中来回复制数据，从而在一些场景中显著提高性能。直接内存分配不会受到Java堆大小的限制，会受到本机总内存大小及处理器寻址空间的限制。会抛出OutOfMemoryError异常</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>只有程序计数器不会报出任何相关OOM异常，而Java虚拟机栈有可能会报出OOM或Stack Overflow异常。<strong>Java虚拟机栈主要是存储方法的一些信息</strong>，能让方法顺利的执行，而<strong>Java堆存储的是对象的信息</strong>。虚拟机的垃圾回收算法主要在这一块，并且平常调优的区域也是在这一块。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xiaotian15/p/6971353.html">https://www.cnblogs.com/xiaotian15/p/6971353.html</a></p><p><a href="https://www.tuicool.com/articles/Av6RZnU">https://www.tuicool.com/articles/Av6RZnU</a></p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM - 类加载过程</title>
    <link href="/2019-07-06-java-jvm-classload-process/"/>
    <url>/2019-07-06-java-jvm-classload-process/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>在聊 Java 类加载机制之前，需要先了解一下 Java 字节码，因为它和类加载机制息息相关。</p><p>计算机只认识 0 和 1，所以任何语言编写的程序都需要编译成机器码才能被计算机理解，然后执行，Java 也不例外。</p><p>Java 在诞生的时候喊出了一个非常牛逼的口号：”Write Once, Run Anywhere”，为了达成这个目的，Sun 公司发布了许多可以在不同平台（Windows、Linux）上运行的 Java 虚拟机（JVM）——负责载入和执行 Java 编译后的字节码。</p><span id="more"></span><p><img src="https://blogres.blackist.org/dev-201907061328-272.png"></p><p>我们借助一段简单的代码来看一看，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.blackist.jvm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JvmDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;董亮亮的开发笔记&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码编译过后，通过十六进制工具 xxd JvmDemo.class命令查看这个字节码文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-number">00000000</span>: cafe babe <span class="hljs-number">0000</span> <span class="hljs-number">0034</span> <span class="hljs-number">0022</span> <span class="hljs-number">0</span>a00 <span class="hljs-number">0600</span> <span class="hljs-number">1409</span>  .......<span class="hljs-number">4</span>.&quot;......<br><span class="hljs-number">00000010</span>: <span class="hljs-number">0015</span> <span class="hljs-number">0016</span> <span class="hljs-number">0800</span> <span class="hljs-number">170</span>a <span class="hljs-number">0018</span> <span class="hljs-number">0019</span> <span class="hljs-number">0700</span> <span class="hljs-number">1</span>a07  ................<br><span class="hljs-number">00000020</span>: <span class="hljs-number">001</span>b <span class="hljs-number">0100</span> <span class="hljs-number">063</span>c <span class="hljs-number">696</span>e <span class="hljs-number">6974</span> <span class="hljs-number">3</span>e01 <span class="hljs-number">0003</span> <span class="hljs-number">2829</span>  .....&lt;init&gt;...()<br><span class="hljs-number">00000030</span>: <span class="hljs-number">5601</span> <span class="hljs-number">0004</span> <span class="hljs-number">436</span>f <span class="hljs-number">6465</span> <span class="hljs-number">0100</span> <span class="hljs-number">0</span>f4c <span class="hljs-number">696</span>e <span class="hljs-number">654</span>e  V...Code...LineN<br><span class="hljs-number">00000040</span>: <span class="hljs-number">756</span>d <span class="hljs-number">6265</span> <span class="hljs-number">7254</span> <span class="hljs-number">6162</span> <span class="hljs-number">6</span>c65 <span class="hljs-number">0100</span> <span class="hljs-number">124</span>c <span class="hljs-number">6</span>f63  umberTable...Loc<br><span class="hljs-number">00000050</span>: <span class="hljs-number">616</span>c <span class="hljs-number">5661</span> <span class="hljs-number">7269</span> <span class="hljs-number">6162</span> <span class="hljs-number">6</span>c65 <span class="hljs-number">5461</span> <span class="hljs-number">626</span>c <span class="hljs-number">6501</span>  alVariableTable.<br></code></pre></td></tr></table></figure><p>这段字节码中的 <code>cafe babe</code> 被称为“魔数”，是 JVM 识别 .class 文件的标志。文件格式的定制者可以自由选择魔数值（只要没用过），比如说 .png 文件的魔数是 <code>89504e47</code>。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>JVM结束生命周期的几种情况：</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序执行过程中遇到异常或错误而异常终止</li><li>操作系统出现错误而导致JVM进程终止</li></ul><p>Java 的<strong>类加载过程</strong>可以分为 5 个阶段：载入、验证、准备、解析和初始化。这 5 个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后。</p><p><img src="https://blogres.blackist.org/dev-201907061107-828.png"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>查找并加载类的二进制数据。</p><p>将类的.class文件中的二进制数据读入到内存，将其放在<strong>运行时数据区的方法区</strong>内，然后在堆去创建java.lang.Class对象，用来封装类在方法区内的数据结构。</p><p><img src="https://blogres.blackist.org/dev-201907061321-381.png"></p><h4 id="加载-class-的方式"><a href="#加载-class-的方式" class="headerlink" title="加载 .class 的方式"></a>加载 .class 的方式</h4><ul><li>从本地加载</li><li>从网络上加载（URLClassLoader(URL[] urls)）</li><li>从 zip, jar 等归档文件中加载 .class 文件</li><li>从专有数据库提取 .class 文件</li><li>将 Java 源文件动态编译成 .class 文件</li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保被加载的类的正确性，符合JVM字节码规范，该阶段是保证 JVM 安全的重要屏障，下面是一些主要的检查：</p><ul><li>确保二进制字节流格式符合预期（比如说是否以 <code>cafe bene</code> 开头）。</li><li>是否所有方法都遵守访问控制关键字的限定。</li><li>方法调用的参数个数和类型是否正确。</li><li>确保变量在使用之前被正确初始化了。</li><li>检查变量是否被赋予恰当类型的值。</li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>JVM 会在该阶段对类变量（也称为静态变量， <code>static</code> 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">blackist</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Blackist&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">note</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Note&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">bnote</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Note-of-Blackist&quot;</span>;<br></code></pre></td></tr></table></figure><p>blackist不会被分配内存，而 note会；但 bnote的初始值不是“王二”而是 <code>null</code>。</p><p>需要注意的是， <code>static final</code> 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 bnote 在准备阶段的值为“沉默王二”而不是 <code>null</code>。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>该阶段将常量池中的符号引用转化为直接引用。</p><p><strong>符号引用</strong>以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。</p><p>在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 <code>org.blackist.Quiz</code> 类引用了 <code>org.blackist.Bnote</code>类，编译时 Quiz类并不知道 Bnote类的实际内存地址，因此只能使用符号 <code>org.blackist.Bnote</code>。</p><p><strong>直接引用</strong>通过对符号引用进行解析，找到引用的实际内存地址。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类变量已经被赋过默认初始值，而在初始化阶段为类的静态变量赋予正确的初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-comment">// 准备阶段默认值为0，初始化阶段赋值3</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 也可写为</span><br>peivate <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> foo;<br><span class="hljs-keyword">static</span> &#123;<br>foo = <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">// 静态代码块从上到下顺序执行，foo最终等于4</span><br><span class="hljs-keyword">static</span> &#123;<br>foo = <span class="hljs-number">4</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>换句话说，初始化阶段是执行类构造器方法的过程。</p><h2 id="Java程序对类的使用"><a href="#Java程序对类的使用" class="headerlink" title="Java程序对类的使用"></a>Java程序对类的使用</h2><h3 id="主动使用（六种）"><a href="#主动使用（六种）" class="headerlink" title="主动使用（六种）"></a>主动使用（六种）</h3><ul><li>创建类的实例（new Test();）</li><li>访问某个类的或接口的静态变量，或对该静态变量赋值（int b &#x3D; Test.a; Test.a &#x3D; b;）</li><li>调用类的静态方法 （Test.foo()）</li><li>反射（ClassForName(“org.blackst.demo.Quiz”)）</li><li>初始化类的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">// 初始化子类，对父类进行了主动使用</span><br>Child.a = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><ul><li>JVM启动时被标为启动类的类（如JavaTest，java  org.blackist.Test）</li></ul><p>所有JVM实现必须在每个类或接口被Java程序 <strong>首次主动使用</strong> 时才初始化。</p><h3 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h3><p>除了主动使用以外的使用，都不会导致类的初始化。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下程序：</p><p><img src="https://blogres.blackist.org/dev-201907061030-765.png"></p><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>0<br></code></pre></td></tr></table></figure><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 - 6大原则</title>
    <link href="/2019-07-02-java-design-patterns-6principles/"/>
    <url>/2019-07-02-java-design-patterns-6principles/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于设计模式的六大设计原则的资料网上很多，但是很多地方解释地都太过于笼统化，我也找了很多资料来看，发现CSDN上有几篇关于设计模式的六大原则讲述的比较通俗易懂，因此转载过来。</p><span id="more"></span><h2 id="一-单一职责原则"><a href="#一-单一职责原则" class="headerlink" title="一.单一职责原则"></a>一.单一职责原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7536542">http://blog.csdn.net/lovelion/article/details/7536542</a></p><p>　　单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下：</p><blockquote><p>单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p></blockquote><p>​      单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p><p>​      单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><p>​      下面通过一个简单实例来进一步分析单一职责原则：</p><p>​      Sunny软件公司开发人员针对某CRM（Customer Relationship  Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：</p><p><img src="https://blogres.blackist.org/dev-201907020942-209.png" alt="图1  初始设计方案结构图"></p><p>​      在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。</p><p>​      在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：</p><p>​      (1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；</p><p>​      (2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；</p><p>​      (3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。</p><p>​      使用单一职责原则重构后的结构如图2所示：</p><p><img src="https://images0.cnblogs.com/i/288799/201408/181908472844755.jpg" alt="img"></p><h2 id="二-开闭原则"><a href="#二-开闭原则" class="headerlink" title="二.开闭原则"></a>二.开闭原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7537584">http://blog.csdn.net/lovelion/article/details/7537584</a></p><p>　　开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则由<strong>Bertrand  Meyer</strong>于1988年提出，其定义如下：</p><blockquote><p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p></blockquote><p>​      在开闭原则的定义中，<strong>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类</strong>。</p><p>​      任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p><p>​      为了满足开闭原则，需要对系统进行抽象化设计，<strong>抽象化是开闭原则的关键</strong>。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p><p>​      Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示：</p><p><img src="https://blogres.blackist.org/dev-201907020944-314.png" alt="图1 初始设计方案结构图"></p><p>​在ChartDisplay类的display()方法中存在如下代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;pie&quot;</span>)) &#123;<br>    <span class="hljs-type">PieChart</span> <span class="hljs-variable">chart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PieChart</span>();<br>    chart.display();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;bar&quot;</span>)) &#123;<br>    <span class="hljs-type">BarChart</span> <span class="hljs-variable">chart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BarChart</span>();<br>    chart.display();<br>&#125;<br></code></pre></td></tr></table></figure><p>​      在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。</p><p>​      在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：</p><p>​      (1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；</p><p>​      (2)  ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。</p><p>​      重构后结构如图2所示：</p><p><img src="https://blogres.blackist.org/dev-201907020952-241.png" alt="图2"></p><p><strong>图2 重构后的结构图</strong></p><p>​      在图2中，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表类进行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在ChartDisplay的display()方法中调用chart对象的display()方法显示图表。如果需要增加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子类，在客户端向ChartDisplay中注入一个LineChart对象即可，无须修改现有类库的源代码。    </p><p>​       注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。</p><h2 id="三-里氏替换原则"><a href="#三-里氏替换原则" class="headerlink" title="三.里氏替换原则"></a>三.里氏替换原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7540445">http://blog.csdn.net/lovelion/article/details/7540445</a></p><p>　　里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士<strong>Barbara Liskov</strong>教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出。其严格表述如下：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。这个定义比较拗口且难以理解，因此我们一般使用它的另一个通俗版定义：</p><blockquote><p>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p></blockquote><p>​      里氏代换原则告诉我们，<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</strong>例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p><p>​      例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。</p><p>​      里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</p><p>​      在使用里氏代换原则时需要注意如下几个问题：</p><p>​      (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</p><p>​      (2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</p><p>​      (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p><p>在Sunny软件公司开发的CRM系统中，客户(Customer)可以分为VIP客户(VIPCustomer)和普通客户(CommonCustomer)两类，系统需要提供一个发送Email的功能，原始设计方案如图1所示：</p><p><img src="https://blogres.blackist.org/dev-201907020953-812.png" alt="图1"></p><p>​无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个send()方法中的代码重复，而且在本系统中还将增加新类型的客户。为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构。</p><p>​      在本实例中，可以考虑增加一个新的抽象客户类Customer，而将CommonCustomer和VIPCustomer类作为其子类，邮件发送类EmailSender类针对抽象客户类Customer编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将EmailSender中的send()方法的参数类型改为Customer，如果需要增加新类型的客户，只需将其作为Customer类的子类即可。重构后的结构如图2所示：</p><p><img src="https://blogres.blackist.org/dev-201907020954-854.png"></p><p><strong>图2  重构后的结构图</strong></p><p>​      <strong>里氏代换原则是实现开闭原则的重要方式之一。</strong>在本实例中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。</p><p>　　另外补充一篇关于里氏替换原则的一篇博文：</p><p>　　<a href="http://blog.csdn.net/zhengzhb/article/details/7281833">http://blog.csdn.net/zhengzhb/article/details/7281833</a></p><h2 id="四-依赖倒置原则"><a href="#四-依赖倒置原则" class="headerlink" title="四.依赖倒置原则"></a>四.依赖倒置原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7562783">http://blog.csdn.net/lovelion/article/details/7562783</a></p><p>　　如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。依赖倒转原则是<strong>Robert C. Martin</strong>在1996年为“C++Reporter”所写的专栏Engineering Notebook的第三篇，后来加入到他在2002年出版的经典著作“<strong>Agile Software Development, Principles, Patterns, and Practices</strong>”一书中。依赖倒转原则定义如下：</p><blockquote><p>依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p></blockquote><p>​      依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p><p>​      在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p>​      在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过<strong>依赖注入(DependencyInjection, DI)<strong>的方式注入到其他对象中，</strong>依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象</strong>。常用的注入方式有三种，分别是：<strong>构造注入，设值注入（Setter注入）和接口注入</strong>。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p><p>​      下面通过一个简单实例来加深对依赖倒转原则的理解：</p><p>​      Sunny软件公司开发人员在开发某CRM系统时发现：该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类中将调用数据格式转换类的方法实现格式转换和数据库插入操作，初始设计方案结构如图1所示：</p><p><img src="https://blogres.blackist.org/dev-201907020956-327.png" alt="图1"></p><p>​            在编码实现图1所示结构时，Sunny软件公司开发人员发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构。</p><p>在本实例中，由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。我们可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图2所示：</p><p><img src="https://blogres.blackist.org/dev-201907020957-332.png" alt="图2"></p><p>​    </p><p>​      在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，<strong>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段</strong>，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。</p><h2 id="五-接口隔离原则"><a href="#五-接口隔离原则" class="headerlink" title="五.接口隔离原则"></a>五.接口隔离原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7562842">http://blog.csdn.net/lovelion/article/details/7562842</a></p><p>　　接口隔离原则定义如下：</p><blockquote><p>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></blockquote><p>​      根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。<strong>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</strong>这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p><p>​      (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“<strong>角色隔离原则</strong>”。</p><p>​      (2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指<strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</strong>。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“<strong>定制服务</strong>”，即为不同的客户端提供宽窄不同的接口。</p><p>​      下面通过一个简单实例来加深对接口隔离原则的理解：</p><p>Sunny软件公司开发人员针对某CRM系统的客户数据显示模块设计了如图1所示接口，其中方法dataRead()用于从文件中读取数据，方法transformToXML()用于将数据转换成XML格式，方法createChart()用于创建图表，方法displayChart()用于显示图表，方法createReport()用于创建文字报表，方法displayReport()用于显示文字报表。</p><p><img src="https://blogres.blackist.org/dev-201907020958-882.png" alt="图1"></p><p>​      在实际使用过程中发现该接口很不灵活，例如如果一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的transformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。</p><p>​      在图1中，由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。因此需要将该接口按照接口隔离原则和单一职责原则进行重构，将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端（如模块或类）所需的方法即可。</p><p>​      通过使用接口隔离原则，本实例重构后的结构如图2所示：</p><p><img src="https://blogres.blackist.org/dev-201907020959-680.png" alt="图2"></p><p>​     <strong>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</strong>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p><h2 id="六-迪米特法则"><a href="#六-迪米特法则" class="headerlink" title="六.迪米特法则"></a>六.迪米特法则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7563445">http://blog.csdn.net/lovelion/article/details/7563445</a></p><p>　　迪米特法则来自于1987年美国东北大学(Northeastern University)一个名为“Demeter”的研究项目。迪米特法则又称为最少知识原则(LeastKnowledge Principle, LKP)，其定义如下：</p><blockquote><p>迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。</p></blockquote><p>​      如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</strong></p><p>​      迪米特法则还有几种定义形式，包括<strong>：****不要和“陌生人”说话</strong>、<strong>只与你的直接朋友通信</strong>等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><p>​      (1) 当前对象本身(this)；</p><p>​     (2) 以参数形式传入到当前对象方法中的对象；</p><p>​      (3) 当前对象的成员对象；</p><p>​      (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</p><p>​      (5) 当前对象所创建的对象。</p><p>​      任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>​      迪米特法则要求我们在设计系统时，<strong>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用</strong>。简言之，就是<strong>通过引入一个合理的第三者来降低现有对象之间的耦合度</strong>。</p><p>​      在将迪米特法则运用到系统设计中时，要注意下面的几点：<strong>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及</strong>；<strong>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限</strong>；<strong>在类的设计上，只要有可能，一个类型应当设计成不变类</strong>；<strong>在对其他类的引用上，一个对象对其他对象的引用应当降到最低</strong>。</p><p>​      下面通过一个简单实例来加深对迪米特法则的理解：</p><p>Sunny软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如图1所示结构：</p><p><img src="https://blogres.blackist.org/dev-201907021001-129.png" alt="图1"></p><p>​      在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，重构后结构如图2所示：</p><p><img src="https://blogres.blackist.org/dev-201907021001-501.png" alt="图2"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/LoveLion/article/category/738450/7">http://blog.csdn.net/LoveLion/article/category/738450/7</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中&#39;==&#39; 和 equals()</title>
    <link href="/2019-06-27-java-oo-equals/"/>
    <url>/2019-06-27-java-oo-equals/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“判断两个事物是否相等”，是编程中最常见的操作之一，在Java中，判断是否相等有两种方法，一种是使用“&#x3D;&#x3D;”判断符，另一种是使用“equals()”方法，你是否曾因混用二者导致不可思议的bug？本篇文章将带你深入二者背后的判断原理。</p><span id="more"></span><h1 id="相等判断符”-x3D-x3D-”"><a href="#相等判断符”-x3D-x3D-”" class="headerlink" title="相等判断符”&#x3D;&#x3D;”"></a>相等判断符”&#x3D;&#x3D;”</h1><blockquote><p>“&#x3D;&#x3D;”相等判断符用于比较基本数据类型和引用类型数据。当比较基本数据类型的时候比较的是数值，当比较引用类型数据时比较的是引用(指针)。</p></blockquote><h2 id="“-x3D-x3D-”判断基本类型数据"><a href="#“-x3D-x3D-”判断基本类型数据" class="headerlink" title="“&#x3D;&#x3D;”判断基本类型数据"></a>“&#x3D;&#x3D;”判断基本类型数据</h2><p>基本数据类型指的是Java中的八大数据类型：byte，short，int，long，float，double，char，boolean。</p><p>这八大基本数据类型有个共同的特点是它们在内存中是有具体值的, 比如说一个 int 类型的数据”2”，它在8位数据总线的机器上保存形式为 0000 0010。（8位机器是假设的）</p><p>当使用 &#x3D;&#x3D; 比较两个基本数据类型的时候, 就是在比较它们各自在内存中的值。</p><p>为了照顾到要刨根问底的同学，再补充一下两个数值是怎么比较的：cpu 在比较的时候会将两个值作差，然后查看标志寄存器。标志寄存器存放的是运算的结果，里面有一个是否为0的标志位，如果该位为1，证明二者之差为0，二者相等。</p><h2 id="“-x3D-x3D-”判断引用类型数据"><a href="#“-x3D-x3D-”判断引用类型数据" class="headerlink" title="“&#x3D;&#x3D;”判断引用类型数据"></a>“&#x3D;&#x3D;”判断引用类型数据</h2><p>引用数据类型在字面上也是很好理解的, 它就是一个引用, 指向堆内存中一个具体的对象。</p><p>比如说<code>Student stu = new Student();</code> 这里的 stu 就是一个引用，它指向的是当前 new 出来的 <strong>Student</strong> 对象. 当我们想要操作这个 <strong>Student</strong> 对象时, 只需要操作引用即可, 比如说<code>int age = stu.getAge();</code>。</p><p>所以用”&#x3D;&#x3D;”判断两个引用数据类型是否相等的时候，实际上是在判断两个引用<strong>是否指向同一个对象</strong>。</p><p>看下面的示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <span class="hljs-title class_">String</span> s1 = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-comment">//s1指向字符串常量池中的&quot;hello&quot;字符串对象</span><br>    <span class="hljs-title class_">String</span> s2 = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-comment">//s2也指向字符串常量池中的&quot;hello&quot;字符串对象</span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s1 == s2);   <span class="hljs-comment">//true</span><br><br>    <span class="hljs-title class_">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">//s3指向的是堆内存中的字符串对象 </span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s1 == s3);    <span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子可以看到，由于引用”s1”和”s2”指向的都是常量池中的”hello”字符串，所以返回true。（后面我会发布一篇详细讲述Java字符串的文章，涉及字符串初始化和字符串常量池等知识）</p><p>而”s3”指向的是新创建字符串对象，因为只要动用了<code>new</code>关键字, 就会在堆内存创建一个新的对象。</p><p>也就是说 s1 和 s3 指向的是不同的字符串对象，所以返回false。</p><h1 id="相等判断方法equals"><a href="#相等判断方法equals" class="headerlink" title="相等判断方法equals()"></a>相等判断方法equals()</h1><blockquote><p>equals()和 &#x3D;&#x3D; 有着本质的区别，&#x3D;&#x3D; 可以看作是对“操作系统比较数据手段”的封装，而equals()则是每个对象自带的比较方法，它是Java自定义的比较规则。</p></blockquote><p>equals()和 &#x3D;&#x3D; 的本质区别更通俗的说法是：&#x3D;&#x3D;的比较规则是定死的，就是比较两个数据的值。</p><p>而 equals() 的比较规则是不固定的，可以由用户自己定义。</p><p>看下面的例子:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <span class="hljs-title class_">String</span> s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-title class_">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);    <br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s1.<span class="hljs-title function_">equals</span>(s3));    <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>回想前面的案例：用 &#x3D;&#x3D; 比较的时候, 上面 s1 和 s3 比较出的结果为false。而当用 equals() 比较的时候，得出的结果为 true。</p><p>想知道原因我们还得看源码，下面是 String 类中的 equals() 方法的源码。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span>(<span class="hljs-built_in">Object</span> anObject) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">this</span> == anObject) &#123;    <span class="hljs-comment">//先比较两个字符串的引用是否相等(是否指向同一个对象), 是直接返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>) &#123;    <span class="hljs-comment">//两个引用不等还会继续比较</span><br>        <span class="hljs-built_in">String</span> anotherString = (<span class="hljs-built_in">String</span>)anObject;<br>        <span class="hljs-type">int</span> n = value.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">if</span> (n == anotherString.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-type">char</span> v1[] = value;    <span class="hljs-comment">//字符串类是用字符数组实现的, 先要拿到两个字符串的字符数组</span><br>            <span class="hljs-type">char</span> v2[] = anotherString.<span class="hljs-property">value</span>;<br>            <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">//然后对两个数组逐个字符地进行比较</span><br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的源码可以看到, 当调用 String 类型数据的 equals() 方法时，首先会判断两个字符串的引用是否相等，也就是说两个字符串引用是否指向同一个对象，是则返回true。</p><p>如果不是指向同一个对象，则把两个字符串中的字符挨个进行比较。由于 s1 和 s3 字符串都是 “hello”，是可以匹配成功的，所以最终返回 true。</p><h3 id="HashMap-lt-String-Object-gt-中containsKey-的实现"><a href="#HashMap-lt-String-Object-gt-中containsKey-的实现" class="headerlink" title="HashMap&lt;String, Object&gt;中containsKey()的实现"></a>HashMap&lt;String, Object&gt;中containsKey()的实现</h3><p>比较的是key的hash code和参数字符串的hash code。</p><h1 id="思考：为什么要设计equals-方法"><a href="#思考：为什么要设计equals-方法" class="headerlink" title="思考：为什么要设计equals()方法?"></a>思考：为什么要设计equals()方法?</h1><p>通过上面的讲解，相信你已经知道 &#x3D;&#x3D; 和 equals() 的区别了：一个的比较规则是定死的，一个是可以由编程人员自己定义的。</p><p>可是为什么会有 equals() 方法, 而且还可以被自由定制呢?</p><p>这个问题要落到Java语言的核心 —— 面向对象思想了。</p><p>Java 不同于面向过程的C语言，Java是一款面向对象的高级语言。如果是面向过程编程，直接操作内存上存储的数据的话，用 &#x3D;&#x3D; 所定义的规则来判断两个数据是否相等已经足够了。</p><p>而Java中万物皆对象，我们经常要面临的问题是这两个对象是否相等，而不是这两串二进制数是否相等，仅有 &#x3D;&#x3D; 是完全不够用的。</p><p>由于Java程序员们会创建各种满足它们业务需求的对象，<strong>系统无法提前知道两个对象在什么条件下算相等，Java干脆把判断对象是否相等的权力交给编程人员</strong>。</p><p>具体的措施是：所有的类都必须继承 Object 类，而 Object 类中写有equals()方法。编程人员可以通过重写 equals() 方法来实现自己的比较策略，也可以不重写，使用Object类的equals()比较策略。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//Object类中的equals()方法源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>从 Object 类的 equals() 源码可以看到，如果编程人员没有显示地重写 equals() 方法，则默认比较两个引用是否指向同一个对象。</p><blockquote><p>补充: 关于基本数据类型包装类的比较</p></blockquote><p>由于 Java 中万物皆对象，就连基本数据类型也有其对应的包装类，那么它们对应的比较策略是什么呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">3</span>;<br>    Integer b = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>);<br>    System.<span class="hljs-keyword">out</span>.println(b.<span class="hljs-keyword">equals</span>(a));    <span class="hljs-comment">//true, 自动装箱</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看到尽管两个引用不同, 但是输出的结果仍为 true, 证明 Integer 包装类重写了 equals() 方法，追踪其源码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//Integer类中的equals方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> obj</span>) &#123;<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Integer</span>) &#123;<br>        <span class="hljs-keyword">return</span> value == ((<span class="hljs-title class_">Integer</span>)obj).<span class="hljs-title function_">intValue</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码看到，基本类型包装类在重写equals()后，比较的还是基本数据类型的值。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>通过探索 &#x3D;&#x3D; 和 equals() 的区别，我们摸清楚了二者别后的比较策略，同时也对 Java 中 equals() 方法的设计进行了思考，相信大家在今后的 Java 编程实战中不会再为相等判断而烦恼了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3NzczMTAzMg==&mid=2247484502&idx=1&sn=3a1c33f1775f8af94edd93c03413f432&chksm=fd0164e1ca76edf75b1aaf63ccfa06ea9d43cb3cb7459227b7add1c25c9966efffde16dc9f45&mpshare=1&scene=1&srcid=&key=f9a007895c9d38fdc97b2511d304b22f97950d025d0ab083a0988ec7cf2b231d0784acf364b69e05d4fe91447ef43637a0cf1b239f86bcb0c8683f102ea13775c7c173047a60c206c8eb92b24c680103&ascene=1&uin=MTM3MzI2NTQzNA==&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=77Xn2iRJGL+q0VUqT2p92TrsIaljOa8bijuNJ33II0J4pt7IRVYbqeUIuau8VVPc"><a href="https://mp.weixin.qq.com/s?__biz=MzU3NzczMTAzMg==&amp;mid=2247484502&amp;idx=1&amp;sn=3a1c33f1775f8af94edd93c03413f432&amp;chksm=fd0164e1ca76edf75b1aaf63ccfa06ea9d43cb3cb7459227b7add1c25c9966efffde16dc9f45&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=f9a007895c9d38fdc97b2511d304b22f97950d025d0ab083a0988ec7cf2b231d0784acf364b69e05d4fe91447ef43637a0cf1b239f86bcb0c8683f102ea13775c7c173047a60c206c8eb92b24c680103&amp;ascene=1&amp;uin=MTM3MzI2NTQzNA==&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=77Xn2iRJGL+q0VUqT2p92TrsIaljOa8bijuNJ33II0J4pt7IRVYbqeUIuau8VVPc">https://mp.weixin.qq.com/s?__biz=MzU3NzczMTAzMg==&amp;mid=2247484502&amp;idx=1&amp;sn=3a1c33f1775f8af94edd93c03413f432&amp;chksm=fd0164e1ca76edf75b1aaf63ccfa06ea9d43cb3cb7459227b7add1c25c9966efffde16dc9f45&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=f9a007895c9d38fdc97b2511d304b22f97950d025d0ab083a0988ec7cf2b231d0784acf364b69e05d4fe91447ef43637a0cf1b239f86bcb0c8683f102ea13775c7c173047a60c206c8eb92b24c680103&amp;ascene=1&amp;uin=MTM3MzI2NTQzNA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=77Xn2iRJGL%2Bq0VUqT2p92TrsIaljOa8bijuNJ33II0J4pt7IRVYbqeUIuau8VVPc</a></a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hash在Java中的应用</title>
    <link href="/2019-06-26-java-hash/"/>
    <url>/2019-06-26-java-hash/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>雅虎的 Chief Scientist ，Udi Manber 曾说过，在 yahoo 所应用的算法中，最重要的三个是：Hash，Hash 和 Hash。其实从上文中所举的git用sha1判断文件更改，密码用MD5生成摘要后加盐等等对Hash的应用可看出，Hash的在计算机世界扮演着多么重要的角色。</p><span id="more"></span><h3 id="1-HashMap的复杂度"><a href="#1-HashMap的复杂度" class="headerlink" title="1 HashMap的复杂度"></a>1 HashMap的复杂度</h3><p>在介绍HashMap的实现之前，先考虑一下，HashMap与ArrayList和LinkedList在数据复杂度上有什么区别。下图是他们的性能对比图：</p><table><thead><tr><th>获取</th><th>查找</th><th>添加&#x2F;删除</th><th>空间</th><th></th></tr></thead><tbody><tr><td>ArrayList</td><td>O(1)</td><td>O(1)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>LinkedList</td><td>O(N)</td><td>O(N)</td><td>O(1)</td><td>O(N)</td></tr><tr><td>HashMap</td><td>O(N&#x2F;Bucket_size)</td><td>O(N&#x2F;Bucket_size)</td><td>O(N&#x2F;Bucket_size)</td><td>O(N)</td></tr></tbody></table><p>可以看出HashMap整体上性能都非常不错，但是不稳定，为O(N&#x2F;Buckets)，N就是以数组中没有发生碰撞的元素，Buckets是因碰撞产生的链表。</p><blockquote><p>注：发生碰撞实际上是非常稀少的，所以N&#x2F;Bucket_size约等于1</p></blockquote><p>HashMap是对Array与Link的折衷处理，Array与Link可以说是两个速度方向的极端，Array注重于数据的获取，而处理修改（添加&#x2F;删除）的效率非常低；Link由于是每个对象都保持着下一个对象的指针，查找某个数据需要遍历之前所有的数据，所以效率比较低，而在修改操作中比较快。</p><h3 id="2-HashMap的实现"><a href="#2-HashMap的实现" class="headerlink" title="2 HashMap的实现"></a>2 HashMap的实现</h3><p>本文以JDK8的API实现进行分析</p><h4 id="2-1-对key进行Hash计算"><a href="#2-1-对key进行Hash计算" class="headerlink" title="2.1 对key进行Hash计算"></a>2.1 对key进行Hash计算</h4><p>在JDK8中，由于使用了红黑树来处理大的链表开销，所以hash这边可以更加省力了，只用计算hashCode并移动到低位就可以了。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">//计算hashCode，并无符号移动到低位</span><br>    <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子: 363771819^(363771819 &gt;&gt;&gt; 16)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">0001 </span><span class="hljs-number">0101 </span><span class="hljs-number">1010 </span><span class="hljs-number">1110 </span><span class="hljs-number">1011 </span><span class="hljs-number">0111 </span><span class="hljs-number">1010 </span><span class="hljs-number">1011</span><span class="hljs-string">(363771819)</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0101 </span><span class="hljs-number">1010 </span><span class="hljs-number">1110</span><span class="hljs-string">(5550)</span> <span class="hljs-string">XOR</span><br><span class="hljs-string">---------------------------------------</span> <span class="hljs-string">=</span><br><span class="hljs-number">0001 </span><span class="hljs-number">0101 </span><span class="hljs-number">1010 </span><span class="hljs-number">1110 </span><span class="hljs-number">1010 </span><span class="hljs-number">0010 </span><span class="hljs-number">0000 </span><span class="hljs-number">0101</span><span class="hljs-string">(363766277)</span><br></code></pre></td></tr></table></figure><p>这样做可以实现了高地位更加均匀地混到一起。</p><p>下面给出在Java中几个常用的哈希码(hashCode)的算法。</p><ol><li>Object类的hashCode. 返回对象的经过处理后的内存地址，由于每个对象的内存地址都不一样，所以哈希码也不一样。这个是native方法，取决于JVM的内部设计，一般是某种C地址的偏移。</li><li>String类的hashCode. 根据String类包含的字符串的内容，根据一种特殊算法返回哈希码，只要字符串的内容相同，返回的哈希码也相同。</li><li>Integer等包装类，返回的哈希码就是Integer对象里所包含的那个整数的数值，例如Integer i1&#x3D;new Integer(100), i1.hashCode的值就是100 。由此可见，2个一样大小的Integer对象，返回的哈希码也一样。</li><li>int，char这样的基础类，它们不需要hashCode，如果需要存储时，将进行自动装箱操作，计算方法同上。</li></ol><h4 id="2-2-获取到数组的index的位置"><a href="#2-2-获取到数组的index的位置" class="headerlink" title="2.2  获取到数组的index的位置"></a>2.2  获取到数组的index的位置</h4><p>计算了Hash，我们现在要把它插入数组中了</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">i = (<span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>；<br></code></pre></td></tr></table></figure><p>通过位运算，确定了当前的位置，因为HashMap数组的大小总是2^n，所以实际的运算就是 (0xfff…ff) &amp; hash ，这里的tab.length-1相当于一个mask，滤掉了大于当前长度位的hash，使每个i都能插入到数组中。</p><h4 id="2-3-生成包装类"><a href="#2-3-生成包装类" class="headerlink" title="2.3 生成包装类"></a>2.3 生成包装类</h4><p>这个对象是一个包装类，Node&lt;K,V&gt;，内部有key,value,hash还有next，可以看出来它是一个链表。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> Map.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; <span class="hljs-keyword">next</span>;<br>        <span class="hljs-comment">//getter and setter .etc.</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-插入包装类到数组"><a href="#2-4-插入包装类到数组" class="headerlink" title="2.4  插入包装类到数组"></a>2.4  插入包装类到数组</h4><p>(1). 如果输入当前的位置是空的，就插进去，如图，左为插入前，右为插入后</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">0</span>           <span class="hljs-number">0</span><br>|           |<br><span class="hljs-number">1</span> -&gt; <span class="hljs-literal">null</span>   <span class="hljs-number">1</span> - &gt; <span class="hljs-literal">null</span><br>|           |<br><span class="hljs-number">2</span> -&gt; <span class="hljs-literal">null</span>   <span class="hljs-number">2</span> - &gt; <span class="hljs-literal">null</span><br>|           | <br>..-&gt; <span class="hljs-literal">null</span>   ..- &gt; <span class="hljs-literal">null</span><br>|           | <br>i -&gt; <span class="hljs-literal">null</span>   i - &gt; <span class="hljs-keyword">new</span> node<br>|           |<br>n -&gt; <span class="hljs-literal">null</span>   n - &gt; <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>(2). 如果当前位置已经有了node，且它们发生了碰撞，则新的放到前面，旧的放到后面，这叫做链地址法处理冲突。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">0</span>           <span class="hljs-number">0</span><br>|           |<br><span class="hljs-number">1</span> -&gt; <span class="hljs-literal">null</span>   <span class="hljs-number">1</span> - &gt; <span class="hljs-literal">null</span><br>|           |<br><span class="hljs-number">2</span> -&gt; <span class="hljs-literal">null</span>   <span class="hljs-number">2</span> - &gt; <span class="hljs-literal">null</span><br>|           | <br>..-&gt; <span class="hljs-literal">null</span>   ..- &gt; <span class="hljs-literal">null</span><br>|           | <br>i -&gt; old    i - &gt; <span class="hljs-keyword">new</span> - &gt; old<br>|           |<br>n -&gt; <span class="hljs-literal">null</span>   n - &gt; <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>我们可以发现，失败的hashCode算法会导致HashMap的性能由数组下降为链表，所以想要避免发生碰撞，就要提高hashCode结果的均匀性。</p><h3 id="3-扩容"><a href="#3-扩容" class="headerlink" title="3 扩容"></a>3 扩容</h3><p>如果当表中的75%已经被占用，即视为需要扩容了</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">(threshold = capacity * load <span class="hljs-built_in">factor</span> ) &lt; <span class="hljs-built_in">size</span><br></code></pre></td></tr></table></figure><p>它主要有两个步骤：</p><h4 id="3-1-容量加倍"><a href="#3-1-容量加倍" class="headerlink" title="3.1 容量加倍"></a>3.1 容量加倍</h4><p>左移1位，就是扩大到两倍，用位运算取代了乘法运算</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">newCap</span> <span class="hljs-operator">=</span> oldCap &lt;&lt; <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">newThr</span> <span class="hljs-operator">=</span> oldThr &lt;&lt; <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="3-2-遍历计算Hash"><a href="#3-2-遍历计算Hash" class="headerlink" title="3.2 遍历计算Hash"></a>3.2 遍历计算Hash</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>        Node&lt;K,V&gt; e;<br>        <span class="hljs-comment">//如果发现当前有Bucket</span><br>        <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>            oldTab[j] = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//如果这里没有碰撞</span><br>            <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//重新计算Hash，分配位置</span><br>                <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>            <span class="hljs-comment">//这个见下面的新特性介绍，如果是树，就填入树</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>            <span class="hljs-comment">//如果是链表，就保留顺序....目前就看懂这点</span><br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                Node&lt;K,V&gt; next;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    next = e.next;<br>                    <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                            loHead = e;<br>                        <span class="hljs-keyword">else</span><br>                            loTail.next = e;<br>                        loTail = e;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                            hiHead = e;<br>                        <span class="hljs-keyword">else</span><br>                            hiTail.next = e;<br>                        hiTail = e;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                    loTail.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                    hiTail.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>由此可以看出扩容需要遍历并重新赋值，成本非常高，所以选择一个好的初始容量非常重要。</p><h3 id="4-扩容如何提升性能？"><a href="#4-扩容如何提升性能？" class="headerlink" title="4 扩容如何提升性能？"></a>4 扩容如何提升性能？</h3><ul><li>解决扩容损失：如果知道大致需要的容量，把初始容量设置好以解决扩容损失；<br> 比如我现在有1000个数据，需要 1000&#x2F;0.75 &#x3D; 1333 个坑位，又 1024 &lt; 1333 &lt; 2048，所以最好使用2048作为初始容量。</li><li>解决碰撞损失：使用高效的HashCode与loadFactor，这个…由于JDK8的高性能出现，这儿问题也不大了。</li></ul><h3 id="5-HashMap与HashTable的主要区别"><a href="#5-HashMap与HashTable的主要区别" class="headerlink" title="5 HashMap与HashTable的主要区别"></a>5 HashMap与HashTable的主要区别</h3><p>在很多的Java基础书上都已经说过了，他们的主要区别其实就是Table全局加了线程同步保护</p><ul><li>HashTable线程更加安全，代价就是因为它粗暴的添加了同步锁，所以会有性能损失。</li><li>其实有更好的concurrentHashMap可以替代HashTable，一个是方法级，一个是Class级。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/bf1d7eee28d0">https://www.jianshu.com/p/bf1d7eee28d0</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>依赖注入</title>
    <link href="/2019-06-13-java-java7-ioc/"/>
    <url>/2019-06-13-java-java7-ioc/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>讲真的，今年就业形势相当不好，对IT从业者的专业能力要求将变得更高。近来一边忙学业，一边学习Java基础和框架源码，为不久之后的招聘做准备。</p><p>打算从Java7、Java8d的版本新特性着手，再深入JVM、并发编程等。Java7中发布了JSR-330标准的DI特性。IoC是控制反转，DI是依赖注入。依赖注入（控制反转的一种形式）是Java开发主流中一个重要的范式。</p><span id="more"></span><h2 id="一、理解IoC和DI"><a href="#一、理解IoC和DI" class="headerlink" title="一、理解IoC和DI"></a>一、理解IoC和DI</h2><p><a name="iGpK3"></a></p><h3 id="IoC-控制反转"><a href="#IoC-控制反转" class="headerlink" title="IoC(控制反转)"></a>IoC(控制反转)</h3><p>非IoC范式编程，“功能中心”控制程序逻辑的流程，调用各个可重用对象中的方法执行特定的功能。<br /><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/204153/1560386178634-f13db507-ef0b-4eb5-be76-f61291a3e741.jpeg#align=left&display=inline&height=254&originHeight=254&originWidth=353&size=0&status=done&width=353"><br />IoC程式编程，调用者的代码来处理程序的执行顺序，而程序逻辑则被封装在接受调用的子流程中。<br /><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/204153/1560386191880-91750474-e215-4608-bf06-53e820c2a180.jpeg#align=left&display=inline&height=421&originHeight=421&originWidth=336&size=0&status=done&width=336"></p><p>IoC也被称为<strong>好莱坞原则</strong>，其思想可以归结为会有另一端代码拥有最初的控制线程（容器&#x2F;工厂），并且有它来调用你的代码（注入&#x2F;实例化对象），而不是由你的代码调用它。</p><blockquote><p>好莱坞原则 – “不要给我们打电话，我们会打给你”<br>好莱坞经纪人总是给人打电话，而不是让别人打给他们！</p></blockquote><p>IoC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：<br /> <br />●<strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。<br /><br><br />●<strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？<strong>依赖对象的获取</strong>被反转了。</p><p><a name="FxilH"></a></p><h3 id="IoC应用"><a href="#IoC应用" class="headerlink" title="IoC应用"></a>IoC应用</h3><p><strong>降低代码间的耦合度</strong>，让代码<strong>更易于测试、更易读、内聚性更强</strong>。</p><p>IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。<br />其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC&#x2F;DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。<br />IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。<br /></p><p><a name="kSWEA"></a></p><h3 id="IoC实现方式"><a href="#IoC实现方式" class="headerlink" title="IoC实现方式"></a>IoC实现方式</h3><p>包括工厂模式，服务器定位模式，依赖注入(DI)。</p><p><a name="LQjDC"></a></p><h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI(依赖注入)"></a>DI(依赖注入)</h3><p>DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。<br /><br><br />DI是IoC的一种特定形态，是指<strong>寻找依赖项的过程（实例化）不在当前执行代码的直接控制之下</strong>。通常使用自带IoC容器的DI框架来实现依赖注入机制，如Guice，Spring。IoC可以看作运行时环境。<br /><br><br />依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。<br /> <br />理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：<br /> <br />●<strong>谁依赖于谁：</strong>当然是应用程序依赖于IoC容器；<br />●<strong>为什么需要依赖：</strong>应用程序需要IoC容器来提供对象需要的外部资源；<br />●<strong>谁注入谁：</strong>很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；<br /><br><br /><strong>●注入了什么：</strong>就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。<br /> <br />IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，<strong>“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</strong></p><p><a name="IB7px"></a></p><h2 id="二、DI实现实例"><a href="#二、DI实现实例" class="headerlink" title="二、DI实现实例"></a>二、DI实现实例</h2><blockquote><p>找出所有对Java开发人员比较友善的好莱坞经纪人</p></blockquote><p>有个AgentFinder接口，及其两个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinder</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> List&lt;String&gt; <span class="hljs-title function_">getAllAgents</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DevAgentFinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AgentFinder</span> &#123;<br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getAllAgents</span><span class="hljs-params">()</span> &#123;...&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAgentFinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AgentFinder</span> &#123;<br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getAllAgents</span><span class="hljs-params">()</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在AgentFinderService中使用AgentFinder查找对Java开发人员友好的经纪人，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getGoodAgents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AgentFinder</span> <span class="hljs-variable">finder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DevAgentFinder</span>();<br>List&lt;String&gt; allAgents = finder.getAllAgents();<br><span class="hljs-keyword">return</span> filterAgents(allAgents);<br>&#125;<br><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">filterAgents</span><span class="hljs-params">(List&lt;String&gt; agents)</span> &#123;<br>List&lt;String&gt; fitAgents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (String agent : agents) &#123;<br><span class="hljs-keyword">if</span> (agent.contains(<span class="hljs-string">&quot;Java&quot;</span>)) &#123;<br>fitAgents.add(agent);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> fitAgents;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，AgentFinderService和DevAgentFinder紧密黏合，使用工厂模式和服务器定位模式可降低耦合，它们都是IoC的一种。</p><p><a name="LtAfb"></a></p><h3 id="使用工厂-x2F-服务器定位模式"><a href="#使用工厂-x2F-服务器定位模式" class="headerlink" title="使用工厂&#x2F;服务器定位模式"></a>使用工厂&#x2F;服务器定位模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getGoodAgents</span><span class="hljs-params">(String agentFinderType)</span> &#123;<br>        <span class="hljs-type">AgentFinderFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> AgentFinderFactory.getInstance();<br>        <span class="hljs-type">AgentFinder</span> <span class="hljs-variable">finder</span> <span class="hljs-operator">=</span> factory.getAgentFinder(agentFinderType);<br>List&lt;String&gt; allAgents = finder.getAllAgents();<br><span class="hljs-keyword">return</span> filterAgents(allAgents);<br>&#125;<br><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">filterAgents</span><span class="hljs-params">(List&lt;String&gt; agents)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AgentFinderFactory根据注入的agentFinderType实例化令人满意的AgentFinder。仍存在问题：</p><ul><li>代码注入agentFinderType作为引用凭据，而没有注入真正的对象。</li><li>getGoodAgents仍存在其他依赖项，达不到只关注自身职能的状态。</li></ul><p><a name="DXp6k"></a></p><h3 id="使用DI"><a href="#使用DI" class="headerlink" title="使用DI"></a>使用DI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getGoodAgents</span><span class="hljs-params">(AgentFinder finder)</span> &#123;<br>List&lt;String&gt; allAgents = finder.getAllAgents();<br><span class="hljs-keyword">return</span> filterAgents(allAgents);<br>&#125;<br><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">filterAgents</span><span class="hljs-params">(List&lt;String&gt; agents)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上AgentFinder被直接注入到getGoodAgents方法中，只专注于纯业务逻辑。存在问题，如何配置AgentFinder具体实现？原本AgentFinderFactory要做的事情只是<strong>换个地方</strong>完成。</p><p><a name="LhmHR"></a></p><h3 id="使用JSR-330-DI"><a href="#使用JSR-330-DI" class="headerlink" title="使用JSR-330 DI"></a>使用JSR-330 DI</h3><p>使用框架执行DI操作，DI框架用标准的JSR-330<a href="#">@Inject</a>注解将依赖项注入到getGoodAgents方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br><span class="hljs-meta">@Inject</span> <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getGoodAgents</span><span class="hljs-params">(AgentFinder finder)</span> &#123;<br>List&lt;String&gt; allAgents = finder.getAllAgents();<br><span class="hljs-keyword">return</span> filterAgents(allAgents);<br>&#125;<br><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">filterAgents</span><span class="hljs-params">(List&lt;String&gt; agents)</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，AgentFinder的某个具体实现类的实例由支持JSR-330@inject注解的DI框架在运行时注入。</p><blockquote><p>JSR 企业应用标准：<br>JSR-330: Dependency Injection for Java 1.0<br>JSR-330统一DI体系，对大多数Java DI框架的核心功能做了很好的汇总</p></blockquote><p>从以上改造来温故依赖注入对我们的帮助：</p><ul><li>松耦合</li><li>可测性</li><li>更强的内聚性</li><li>可重用组件</li><li>更轻盈的代码</li></ul><p><a name="FAjHO"></a></p><h2 id="三、Java中标准化DI"><a href="#三、Java中标准化DI" class="headerlink" title="三、Java中标准化DI"></a>三、Java中标准化DI</h2><p>DI新标准中，javax.inject包只是提供一个接口和几个注解类型，这些都会被遵循JSR-330标准的各种DI框架实现。</p><p><a name="eSefj"></a></p><h3 id="理解DI工作原来"><a href="#理解DI工作原来" class="headerlink" title="理解DI工作原来"></a>理解DI工作原来</h3><p>优秀的Java开发人员不能只满足于使用类库和框架，要明白内部基本工作原理。在DI领域，会面临各种问题，如依赖项配置错误、依赖项诡异地超出作用域、依赖项在不该共享时被共享、分布调试离奇宕机等。</p><p>理解javax.inject包：</p><blockquote><p>javax.inject包<br>这个包指明了获取对象的一种方式，与传统的构造方法、工厂模式、服务器定位模式（如JNDI）等相比，这种方式的可重用性、可测试性、可维护性都有极大提升。这种方式成为依赖注入。</p></blockquote><p>javax.inject包中包括一个Provider<T>接口和5个注解类型（@inject、@Qualifier、@Named、@Scope、@Singleton）。</p><p><a name="M5vYz"></a></p><h3 id="Inject-注解"><a href="#Inject-注解" class="headerlink" title="@Inject 注解"></a>@Inject 注解</h3><p>@Inject注解可以出现在三种类成员之前，表示该成员需要依赖注入。按运行时处理顺序：</p><ol><li>构造器</li><li>方法</li><li>属性</li></ol><p><a name="kECuT"></a></p><h4 id="构造器上使用-Inject"><a href="#构造器上使用-Inject" class="headerlink" title="构造器上使用@Inject"></a>构造器上使用@Inject</h4><p>在构造器上使用@Inject时，其参数在运行时由配置好的IoC容器提供。比如在下面的代码中，运行时调用AgentFinderService的构造器时，IoC容器会注入其参数AgentFinder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AgentFinder finder;<br><span class="hljs-meta">@Inject</span> <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgentFinderService</span><span class="hljs-params">(AgentFinder finder)</span> &#123;<br><span class="hljs-built_in">this</span>.finder = finder;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>因为JRE无法决定构造器注入的优先级，所以规范中规定类中<strong>只能有一个构造器带@Inject注解</strong></p><p><a name="zlKd3"></a></p><h4 id="方法上使用-Inject"><a href="#方法上使用-Inject" class="headerlink" title="方法上使用@Inject"></a>方法上使用@Inject</h4><p>运行时可注入的参数可以是多个也可以是0个，使用参数注入的方法不能声明为抽象方法，也不能声明其自身的类型参数。下面这段代码在set方法前使用@Inject，这是注入可选属性的常用技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Inject</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(Content contnet)</span> &#123;<br>    <span class="hljs-built_in">this</span>.content = content;<br>&#125;<br></code></pre></td></tr></table></figure><p>向方法中注入参数技术对于服务类方法来说非常有用，其所需的资源可以作为参数注入，比如向查询数据库的服务方法中注入数据访问对象（DAO）。</p><blockquote><p>向构造器注入的通常是类中必需的依赖项，而对于非必需的依赖项，通常是在set方法上注入。比如已经给出了默认的属性就是非必需的依赖项。</p></blockquote><p><a name="nxUoc"></a></p><h4 id="属性上使用-Inject"><a href="#属性上使用-Inject" class="headerlink" title="属性上使用@Inject"></a>属性上使用@Inject</h4><p>简单直接，但最好不要用。因为这样可能会使单元测试更加困难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br>    <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AgentFinder finder;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="QyP4w"></a></p><h3 id="Qualifier-注解"><a href="#Qualifier-注解" class="headerlink" title="@Qualifier 注解"></a>@Qualifier 注解</h3><p>JSR-330规范使用@Qualifier限定（标识）要注入的对象，比如IoC容器有两个类型相同的对象，当把他们注入到你的代码中时，要把他们区分开来。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/204153/1560392266590-a5a9c420-3145-49f5-a196-b1d91d6ff87a.png#align=left&display=inline&height=399&name=image.png&originHeight=399&originWidth=689&size=18655&status=done&width=689" alt="image.png"><br />创建一个@Qualifier实现必须遵循如下规则：</p><ul><li>必须标记为@Qualifier和@Retention（RUNTIME），以确保该限定注解在运行时一直有效。</li><li>通常还要加上@Documented注解，这样该实现就能加到API的公共JavaDoc中了。</li><li>可以有属性。</li><li>@Target注解可以限定其使用范围。</li></ul><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention</span><br><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MusicGenre &#123;<br>    Genre <span class="hljs-title function_">genre</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Genre.TRANCE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">GENRE</span> &#123; CLASSICAL, METAL, ROCK, TRANCE &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="Evb8J"></a></p><h3 id="Named-注解"><a href="#Named-注解" class="headerlink" title="@Named 注解"></a>@Named 注解</h3><p><a href="#">@amed</a>@Named是一个特别的@Qualifier注解，借助@Named可以用名字注明要注入的对象。将@Named和@Inject一起使用，符合指定名称并且类型正确的对象会被注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br>    <span class="hljs-meta">@Inject</span> <span class="hljs-meta">@Named(&quot;devFinder&quot;)</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AgentFinder devFinder;<br>    <span class="hljs-meta">@Inject</span> <span class="hljs-meta">@Named(&quot;bankFinder&quot;)</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AgentFinder bankFinder;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="J6Xx8"></a></p><h3 id="Scoped-注解"><a href="#Scoped-注解" class="headerlink" title="@Scoped 注解"></a>@Scoped 注解</h3><p>@Scoped注解用于自定义注解器（IoC容器）对注入对象的重用方式。JSR-330默认了如下几种默认行为：</p><ul><li>如果未声明任何@Scope注解接口的实现，注入器应创建注入对象并且仅使用该对象一次。</li><li>如果声明了@Scoped注解接口，注入对象的声明周期由所声明的@Scoped注解实现决定。</li><li>如果注入对象在@Scoped实现中要由多个线程使用，则需保证注入对象的线程安全性。</li><li>如果某个类上声明了多个@Scoped注解，或声明了不受支持的@Scoped注解，IoC容器应该抛出异常。</li></ul><p>公认的通用@Scoped实现只有@Singleton一个，JSR-330只确定了这么一个标准的生命周期注解。</p><p><a name="NWSe0"></a></p><h3 id="Singleton-注解"><a href="#Singleton-注解" class="headerlink" title="@Singleton 注解"></a>@Singleton 注解</h3><p>@Singleton注解接口在DI框架中应用广泛，需要注入一个不会改变的对象时，就要用@Singleton。大多数DI框架都将@Singleton作为注入对象的默认声明周期，无需显式发明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br>    <span class="hljs-meta">@Inject</span> <span class="hljs-meta">@Singleton</span> <span class="hljs-keyword">private</span> AgentFinder devFinder;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="y22MA"></a></p><h3 id="接口Provider"><a href="#接口Provider" class="headerlink" title="接口Provider"></a>接口Provider<T></h3><p>当DI框架的标准注解不能满足你的需求，你想对DI框架注入代码中的对象拥有更多的控制权，可以要求DI框架将Provider<T>接口实现注入对象。</p><ul><li>可以获取该对象的多个实例。</li><li>可以延迟加载对象。</li><li>可以打破循环依赖。</li><li>可以定义作用域，能在比整个被加载的应用小的作用域中查找对象。</li></ul><p>该接口仅有一个T get()方法，这个方法会返回一个构造好的注入对象（T）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br><span class="hljs-meta">@Inject</span> <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgentFinderService</span><span class="hljs-params">(AgentFinderProvider provider)</span> &#123;<br><span class="hljs-type">AgentFinder</span> <span class="hljs-variable">finder</span> <span class="hljs-operator">=</span> provider.get();<br>        <span class="hljs-keyword">if</span> (condition) &#123; <span class="hljs-comment">// 延迟加载</span><br>            <span class="hljs-type">AgentFinder</span> <span class="hljs-variable">finder2</span> <span class="hljs-operator">=</span> provider.get(); <span class="hljs-comment">// 多个实例对象</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="sa2Mm"></a></p><h2 id="四、DI参考实现：Guice3"><a href="#四、DI参考实现：Guice3" class="headerlink" title="四、DI参考实现：Guice3"></a>四、DI参考实现：Guice3</h2><p>Guice3是JSR-330规范的完整参考实现，可以配置、绑定、注入依赖项。</p><p><a name="aA1Cw"></a></p><h3 id="实现DI"><a href="#实现DI" class="headerlink" title="实现DI"></a>实现DI</h3><p><a name="Ra3KF"></a></p><h4 id="创建绑定关系"><a href="#创建绑定关系" class="headerlink" title="创建绑定关系"></a>创建绑定关系</h4><p>先创建绑定关系AgentFinderModule，重写configure()声明绑定关系，当AgentFinderService要求@Inject一个AgentFinder时，就会绑定DevAgentFinder作为注入对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractModule</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">()</span> &#123;<br>bind(AgentFinder.class).to(DevAgentFinder.class);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AgentFinder finder;<br><span class="hljs-meta">@Inject</span> <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgentFinderService</span><span class="hljs-params">(AgentFinder finder)</span> &#123;<br><span class="hljs-built_in">this</span>.finder = finder;<br>&#125;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getGoodAgents</span><span class="hljs-params">()</span> &#123;<br>List&lt;String&gt; allAgents = finder.getAllAgents();<br><span class="hljs-keyword">return</span> filterAgents(allAgents);<br>&#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>代码4-1</p><p><a name="WQnho"></a></p><h4 id="构建Guice对象关系图"><a href="#构建Guice对象关系图" class="headerlink" title="构建Guice对象关系图"></a>构建Guice对象关系图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Injector</span> <span class="hljs-variable">injector</span> <span class="hljs-operator">=</span> Guice.createInjector(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AgentFinderModule</span>());<br><span class="hljs-type">AgentFinderService</span> <span class="hljs-variable">hollywoodService</span> <span class="hljs-operator">=</span> injector.getInstance(AgentFinderService.class);<br>List&lt;String&gt; agents = hollywoodService.getGoodAgents();<br>System.out.println(agents);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码4-2<br><a name="m1R8M"></a></p><h3 id="Guice的各种绑定"><a href="#Guice的各种绑定" class="headerlink" title="Guice的各种绑定"></a>Guice的各种绑定</h3><p>Guice提供多种绑定方式：</p><ul><li>链接绑定</li><li>绑定注解</li><li>实例绑定</li><li>@Provides方法</li><li>Provider绑定</li><li>无目标绑定</li><li>内置绑定</li><li>及时绑定</li></ul><p>最常用的包括链接绑定、绑定注解、@Provides方法、Provider<T>绑定。<br><a name="DPOM8"></a></p><h4 id="链接绑定"><a href="#链接绑定" class="headerlink" title="链接绑定"></a>链接绑定</h4><p>代码4-1中AgentFinderModule即为链接绑定，是最简单的绑定方式，只是告诉注入器运行时应该注入实现类或扩展类（可以直接注入子类）。</p><p><a name="4nYv7"></a></p><h4 id="绑定注解"><a href="#绑定注解" class="headerlink" title="绑定注解"></a>绑定注解</h4><p>将注入类的类型和额外的标识符组合起来，以标识恰当的注入对象。使用JSR-330标准注解@Named，注入特定名称的AgentFinder，在AgentFinderModule中配置@Named绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractModule</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">()</span> &#123;<br>bind(AgentFinder.class)<br>            .annotatedWith(Names.named(<span class="hljs-string">&quot;primary&quot;</span>))<br>            .to(DevAgentFinder.class);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderService</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AgentFinder finder;<br><span class="hljs-meta">@Inject</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AgentFinderService</span><span class="hljs-params">(<span class="hljs-meta">@Named(&quot;primary&quot;)</span> AgentFinder finder)</span> &#123;<br><span class="hljs-built_in">this</span>.finder = finder;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="cMKDQ"></a></p><h4 id="Provides和Provider：提供完全定制的对象"><a href="#Provides和Provider：提供完全定制的对象" class="headerlink" title="@Provides和Provider：提供完全定制的对象"></a>@Provides和Provider：提供完全定制的对象</h4><p>需要注入特别的AgentFinder，使用@Provides注解或在configure()方法中绑定，注入器会查看左右标记了@Provides注解方法的返回类型，决定 注入哪个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractModule</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">()</span> &#123;...&#125;<br><span class="hljs-meta">@Provides</span><br>AgentFinder <span class="hljs-title function_">provideAgentFinder</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 返回注入器需要的类型</span><br><span class="hljs-type">DevAgentFinder</span> <span class="hljs-variable">finder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DevAgentFinder</span>(); <span class="hljs-comment">// 创建实例并定制</span><br>finder.setName(<span class="hljs-string">&quot;JavaFind&quot;</span>);<br><span class="hljs-keyword">return</span> finder;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Provides方法会变得越来越大，为简化Module，需要把定制化代码拆分出去。使用toProvider方法绑定到Provider类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Provider</span>&lt;AgentFinder&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> AgentFinder <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">DevAgentFinder</span> <span class="hljs-variable">finder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DevAgentFinder</span>(); <span class="hljs-comment">// 创建实例并定制</span><br>finder.setName(<span class="hljs-string">&quot;JavaFind&quot;</span>);<br><span class="hljs-keyword">return</span> finder;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentFinderModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractModule</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">()</span> &#123;<br>bind(AgentFinder.class)<br>            .toProvider(AgentFinderProvider.class);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="MLwOI"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jinnianshilongnian.iteye.com/blog/1413846">https://jinnianshilongnian.iteye.com/blog/1413846</a><br />《Java程序员修炼之道 Benjamin J.Evans》第3章</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>java7</tag>
      
      <tag>IoC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式-开启SpringBoot微服务之旅</title>
    <link href="/2019-05-22-distributed-outline/"/>
    <url>/2019-05-22-distributed-outline/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>分布式架构可以降低程序错误给整体系统带来的风险，也可以通过不断扩张主机的数量以实现横向水平的性能扩展，因此我们需要分布式架构。</p><span id="more"></span><h2 id="微服务架构及容器技术"><a href="#微服务架构及容器技术" class="headerlink" title="微服务架构及容器技术"></a>微服务架构及容器技术</h2><p>微服务这个词近几年很火，微服务架构（Microservices Architecture，MSA）是分布式架构的一种，它的产生主要依赖以下方面的内容：</p><ul><li>领域驱动设计：分析并模型化复杂业务。</li><li>敏捷方法论：快速发布，形成有效反馈。</li><li>持续交付：更快、可靠、频繁地部署和交付。</li><li>虚拟化和基础设施自动化：Docker等容器技术简化安装部署环境。</li><li>DevOps：开发、测试、运维整合。</li></ul><p>MSA把小的服务开发成单一应用的形式，每个服务运行在单独的进程中并采用轻量级的机制通信（HTTP等）。这些服务围绕业务构建，自动化部署，可以使用不同的编程语言和存储技术，并保持最小化集中管理。</p><h3 id="如何构建微服务"><a href="#如何构建微服务" class="headerlink" title="如何构建微服务"></a>如何构建微服务</h3><p>ZooKeeper、Dubbo、Jersey、SpringBoot、SpringColud等都可以实现微服务。我决定围绕SpringBoot、SpringCloud展开微服务架构学习。</p><h2 id="SpringBoot微服务架构基础"><a href="#SpringBoot微服务架构基础" class="headerlink" title="SpringBoot微服务架构基础"></a>SpringBoot微服务架构基础</h2><p>SpringBoot简化企业级应用开发地复杂性，提供很多开箱即用的Starter，通过少量代码创建一个独立的、产品级Spring应用。</p><p>我学习的步骤如下：</p><ul><li>SpringBoot引入Web创建RESTful API和单元测试</li><li>使用Swagger2构建API文档</li><li>统一处理异常</li><li>SpringData JPA</li><li>SpringSecurity和JWT</li><li>事务管理</li><li>集中式缓存Redis</li><li>日志系统 本地日志和MongoDB</li><li>消息服务RabbitMQ</li><li>邮件系统</li></ul><h2 id="微服务架构设计原则"><a href="#微服务架构设计原则" class="headerlink" title="微服务架构设计原则"></a>微服务架构设计原则</h2><ul><li>拆分足够微：足够小即可，不要过小。小团队两周内开发完且能够维护。</li><li>轻量级通信：服务跨进程或跨主机，服务间通信采用采用轻量级通信协议，同步的REST（HTTP:XML&#x2F;JSON），异步的AMQP、MQTT、STOMP。</li><li>领域驱动原则：基于领域驱动设计（Domain-Driven Design，DDD）开发一个微服务，一个服务反应某个业务的领域模型，理清领域边界逻辑和上下文边界。</li><li>单一职责原则：高内聚，低耦合。密切相关的多个功能应尽量包含在同一个服务中以降低服务间的干扰；通过接口（API、事件）进行通信以降低对其它服务的依赖。</li><li>DevOps及两个披萨：开发人员具备用户界面、业务逻辑、持久化存储、独立运维的全栈能力，降低沟通成本，防止项目陷入停顿。人数不多过两个披萨不够吃。</li><li>不限于技术栈：根据场景（计算密集型[CPU&#x2F;内存]、非结构化存储[NoSQL]）进行技术选型，但不滥用技术，以安全稳定的Java等为主。</li><li>可独立部署：微服务独立部署使得开发者不再需要协调其它服务部署对本服务的影响；Docker容器技术使得服务能够在构建镜像中所期望的环境中运行。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.didispace.com/spring-boot-learning-1x/">http://blog.didispace.com/spring-boot-learning-1x/</a></p><p>《SpringCloud微服务架构 杨伟卫著》第1章 微服务概述</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker入门</title>
    <link href="/2019-05-03-ops-docker-basic/"/>
    <url>/2019-05-03-ops-docker-basic/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux Containers Linux容器 缩写LXC，其对进程进行隔离，而非一个完整的操作系统。Docker属于LXC的一种封装，提供简单易用的容器使用接口。Docker主要用于提供一次性环境、提供 弹性的云服务、组件微服务架构。</p><span id="more"></span><h2 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h2><h3 id="1-1-Docker安装"><a href="#1-1-Docker安装" class="headerlink" title="1.1 Docker安装"></a>1.1 Docker安装</h3><p>Docker是一个开源的开品，有两个版本：CE（Community Edition）和EE（Enterprise Edition）。企业版包含一些收费服务，社区版适合个人开发者。</p><ul><li><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/ubuntu/">Ubuntu</a></li><li><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/">CentOS</a></li><li><a href="https://docs.docker-cn.com/docker-for-mac/install/">Mac</a></li></ul><p>安装完成后，使用如下命令验证是否安装成功：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>Docker需要用户具有sudo权限，为了避免每次输入sudo以及用户不具有sudo权限，请先使用管理员用户将特定的用户添加到Docker用户组：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> usermod -a -G docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><p>Docker 是服务器—-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 启动Docker服务</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">service</span> <span class="hljs-string">docker</span> <span class="hljs-string">start</span><br><span class="hljs-comment"># 设置开启自己懂</span><br><span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> <span class="hljs-string">docker</span>.<span class="hljs-string">service</span><br><span class="hljs-comment"># 检查开机自启动设置成功没</span><br><span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files</span> |<span class="hljs-string">grep</span> <span class="hljs-string">docker</span><br><br><span class="hljs-string">docker</span>.<span class="hljs-string">service</span>                             <span class="hljs-string">enabled</span> <br><span class="hljs-string">docker</span>.<span class="hljs-string">socket</span>                              <span class="hljs-string">enabled</span> <br></code></pre></td></tr></table></figure><h3 id="1-2-Docker镜像文件image"><a href="#1-2-Docker镜像文件image" class="headerlink" title="1.2 Docker镜像文件image"></a>1.2 Docker镜像文件image</h3><p>Docker将应用程序及其依赖打包在镜像（image）文件里，通常一个image会继承自另一个image，开发者在其中加入个性化的配置，从而形成定制化的镜像文件。</p><p>Docker通过image来生成并运行虚拟容器。比如说我们的网站程序打包成image文件并拷贝在一个服务器上，通过docker根据此image文件在服务器上生成并运行多个相同的网站程序。</p><p>通过Docker管理image文件：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel"># 列出本机的<span class="hljs-keyword">image</span>文件<br>docker <span class="hljs-keyword">image</span> <span class="hljs-keyword">ls</span><br><br># 删除本机<span class="hljs-keyword">image</span>文件<br>docker <span class="hljs-keyword">image</span> rm $image_name<br></code></pre></td></tr></table></figure><p>image具备复用性，通常我们可以使用别人制作好的Image文件，这些共享镜像通常来自于<a href="https://hub.docker.com/">Docker Hub</a>。</p><h3 id="1-3-Docker镜像实例"><a href="#1-3-Docker镜像实例" class="headerlink" title="1.3 Docker镜像实例"></a>1.3 Docker镜像实例</h3><p>我们可以从Docker官方镜像仓库&#x2F;第三方仓库拉取image文件并运行。</p><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h4><p>从官方拉取hello-world镜像来感受下Docker：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image pull library/hello-world<br></code></pre></td></tr></table></figure><ul><li>docker image pull：拉取镜像的命令</li><li>library：镜像文件所在组</li><li>hello-world：镜像文件的名字</li></ul><p>Docker官方提供的镜像文件都在library下，因此library是默认镜像组，可省略不写：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image pull hello-world<br></code></pre></td></tr></table></figure><h3 id="1-4-Docker运行容器实例"><a href="#1-4-Docker运行容器实例" class="headerlink" title="1.4 Docker运行容器实例"></a>1.4 Docker运行容器实例</h3><p>基于image文件生成并运行容器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker container <span class="hljs-built_in">run</span> hello-world<br><br><br>Hello <span class="hljs-keyword">from</span> Docker!<br>This message shows <span class="hljs-keyword">that</span> your installation appears <span class="hljs-keyword">to</span> be working correctly.<br>...<br></code></pre></td></tr></table></figure><p>输出一段话后，hello-world容器自动终止。</p><p>有些容器不会自动终止，因为它们提供的是服务例如网站容器和虚拟操作系统容器，运行ubuntu的容器，docker会从镜像仓库下载ubuntu的镜像，下载完成后直接从ubuntu镜像运行容器实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker container <span class="hljs-built_in">run</span> -it ubuntu bash<br><br>Unable <span class="hljs-keyword">to</span> <span class="hljs-built_in">find</span> image <span class="hljs-string">&#x27;ubuntu:latest&#x27;</span> locally<br>latest: Pulling <span class="hljs-keyword">from</span> library/ubuntu<br>f476d66f5408: Pull complete<br><span class="hljs-built_in">..</span>.<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:latest<br>root@341a7595b69e:<br></code></pre></td></tr></table></figure><ul><li>-t: flag assigns a pseudo-tty or terminal inside the new container.</li><li>-i: flag allows you to make an interactive connection by grabbing the standard in (STDIN) of the container.</li><li>-it：Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器</li><li>bash: launches a Bash shell inside our container.</li></ul><p>输入exit或按Ctrl+D可退出此ubuntu容器实例进程，此种方式依赖命令行运行，命令行退出则容器进程终止（使用Ctrl+P+Q也可退出容器且不关闭容器）。使用ps命令查看docker进程，可见ubuntu的进程已退出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> ps -a<br><br><span class="hljs-attribute">CONTAINER</span> ID        IMAGE               COMMAND             CREATED       STATUS    <br><span class="hljs-attribute">341a7595b69e</span>        ubuntu              <span class="hljs-string">&quot;bash&quot;</span>              <span class="hljs-number">2</span> minutes ago       Exited <br><br><span class="hljs-attribute">44a7468dabfd</span>        hello-world         <span class="hljs-string">&quot;/hello&quot;</span>            <span class="hljs-number">23</span> minutes ago      Exited <br></code></pre></td></tr></table></figure><p>也可以将将容器作为后台进程运行，再使用attach命令进入在后台运行的容器：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> container run -itd ubuntu<br><span class="hljs-attribute">1f7b446e9a8f6a9e9ec8066526f055222c9cfb6bf75f5389a8a9163428d53272</span><br><br><span class="hljs-attribute">docker</span> ps -a <br><br><span class="hljs-attribute">CONTAINER</span> ID        IMAGE               COMMAND             CREATED       STATUS<br><span class="hljs-attribute">1f7b446e9a8f</span>        ubuntu              <span class="hljs-string">&quot;bash&quot;</span>              <span class="hljs-number">13</span> seconds ago      Up <span class="hljs-number">11</span> seconds<br><br><span class="hljs-attribute">341a7595b69e</span>        ubuntu              <span class="hljs-string">&quot;bash&quot;</span>              <span class="hljs-number">2</span> minutes ago       Exited <br><br><span class="hljs-attribute">44a7468dabfd</span>        hello-world         <span class="hljs-string">&quot;/hello&quot;</span>            <span class="hljs-number">23</span> minutes ago      Exited <br></code></pre></td></tr></table></figure><p>容器在后台运行成功，使用attach&#x2F;exec命令进入后台进程的ubuntu容器：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># docker attach [OPTIONS] CONTAINER</span><br><span class="hljs-attribute">docker</span> attach <span class="hljs-number">1</span>f7b446e9a8f<br><br><span class="hljs-comment"># docker exec [OPTIONS] CONTAINER COMMAND [PARAMS]</span><br><span class="hljs-attribute">docker</span> exec <span class="hljs-number">1</span>f7b446e9a8f bash<br><br><span class="hljs-attribute">root</span>@<span class="hljs-number">1</span>f7b446e9a8f:/#<br><br></code></pre></td></tr></table></figure><p>容器进程退出，但容器文件依然存在，因此关闭容器不会删除容器文件。一些container常用命令：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 启动容器</span><br>docker <span class="hljs-built_in">start</span> CONTAINER<br><span class="hljs-comment"># 50s内停止容器，否则强制停止</span><br>docker <span class="hljs-built_in">stop</span> -t <span class="hljs-number">50</span> CONTAINER<br><span class="hljs-comment"># 强制停止容器</span><br>docker <span class="hljs-built_in">kill</span> CONTAINER<br><span class="hljs-comment"># 重启容器</span><br>docker restart CONTAINER<br><span class="hljs-comment"># 删除容器文件</span><br>docker rm CONTAINER<br></code></pre></td></tr></table></figure><h2 id="二、自定义容器"><a href="#二、自定义容器" class="headerlink" title="二、自定义容器"></a>二、自定义容器</h2><p>使用Dockerfile来定制image，适应我们自己的需要。Dockerfile是一个文本配置文件，docker将根据它生成我们需要的image。</p><h3 id="2-1-准备镜像所需的工程代码或文件"><a href="#2-1-准备镜像所需的工程代码或文件" class="headerlink" title="2.1 准备镜像所需的工程代码或文件"></a>2.1 准备镜像所需的工程代码或文件</h3><p>拉取测试代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/blackist/m</span>aven-quiz.git<br></code></pre></td></tr></table></figure><p>在本地编译maven项目，mvn clean package编译出需要的war包。</p><blockquote><p>也可基于maven镜像，在容器内构建maven项目，但需要令行配置</p></blockquote><h3 id="2-2-编写Docker配置文件"><a href="#2-2-编写Docker配置文件" class="headerlink" title="2.2 编写Docker配置文件"></a>2.2 编写Docker配置文件</h3><p>在此项目基础上构建Dockerfile项目，新建Dockerfile配置文件，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> ./target/maven-quiz.jar /app.jar</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8000</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nohup&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-Dserver.port=8000&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app.jar&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="FROM-openjdk-8"><a href="#FROM-openjdk-8" class="headerlink" title="FROM openjdk:8"></a>FROM openjdk:8</h4><p>基于openjdk8镜像编译自定义镜像</p><h4 id="VOLUME-x2F-tmp"><a href="#VOLUME-x2F-tmp" class="headerlink" title="VOLUME &#x2F;tmp"></a>VOLUME &#x2F;tmp</h4><p>将本地文件夹挂载到当前容器</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p> ADD .&#x2F;target&#x2F;maven-quiz.jar &#x2F;app.jar 是拷贝war文件到容器</p><h4 id="EXPOSE-8000"><a href="#EXPOSE-8000" class="headerlink" title="EXPOSE 8000"></a>EXPOSE 8000</h4><p>开放8000端口</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>ENTRYPOINT [“nohup”, “java”, “-Dserver.port&#x3D;8000”, “-jar”, “&#x2F;app.jar”, “&amp;”]<br>配置容器启动后执行的命令，使用nohup使得java程序运行于后台，不至于命令行退出java程序终止。</p><ul><li>ENTRYPOINT，表示镜像在初始化时需要执行的命令，不可被重写覆盖，需谨记</li><li>CMD，表示镜像运行默认参数，可被重写覆盖</li><li>ENTRYPOINT&#x2F;CMD都只能在文件中存在一次，并且最后一个生效 多个存在，只有最后一个生效，其它无效！</li><li>需要初始化运行多个命令，彼此之间可以使用 &amp;&amp; 隔开，但最后一个须要为无限运行的命令，需切记！</li></ul><p>ENTRYPOINT&#x2F;CMD，一般两者可以配合使用，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/usr/sbin/sshd&quot;</span>]</span> <br>CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;-D&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="2-3-编译Docker镜像"><a href="#2-3-编译Docker镜像" class="headerlink" title="2.3 编译Docker镜像"></a>2.3 编译Docker镜像</h2><p>编译命令如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">docker build -t maven-quiz .<br></code></pre></td></tr></table></figure><ul><li>docker build 或 docker image build：编译命令</li><li>-t：指定镜像的name，maven-quiz为镜像名，其后可加:来指定标签，默认为lastest</li><li>.：指定Dockerfile配置文件所在路径，.即是当前路径</li></ul><p>编译过程如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ada">Sending build context to Docker daemon  <span class="hljs-number">16.87</span>MB<br>Step <span class="hljs-number">1</span>/<span class="hljs-number">5</span> : <span class="hljs-type">FROM</span> openjdk:<span class="hljs-number">8</span><br> <span class="hljs-comment">---&gt; b8d3f94869bb</span><br>Step <span class="hljs-number">2</span>/<span class="hljs-number">5</span> : <span class="hljs-type">VOLUME</span> /tmp<br> <span class="hljs-comment">---&gt; Running in dd6790b892cc</span><br>Removing intermediate container dd6790b892cc<br> <span class="hljs-comment">---&gt; c22a0db1f2e0</span><br>Step <span class="hljs-number">3</span>/<span class="hljs-number">5</span> : <span class="hljs-type">ADD</span> ./target/maven-quiz.jar /app.jar<br> <span class="hljs-comment">---&gt; 3a7eb1b80968</span><br>Step <span class="hljs-number">4</span>/<span class="hljs-number">5</span> : <span class="hljs-type">EXPOSE</span> <span class="hljs-number">8000</span><br> <span class="hljs-comment">---&gt; Running in 95ea426741b7</span><br>Removing intermediate container <span class="hljs-number">95</span>ea426741b7<br> <span class="hljs-comment">---&gt; b472a3d4e0d5</span><br>Step <span class="hljs-number">5</span>/<span class="hljs-number">5</span> : <span class="hljs-type">ENTRYPOINT</span> [<span class="hljs-string">&quot;nohup&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-Dserver.port=8000&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app.jar&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>]<br> <span class="hljs-comment">---&gt; Running in c95c9393b88f</span><br>Removing intermediate container c95c9393b88f<br> <span class="hljs-comment">---&gt; 48aa6f27aecf</span><br>Successfully built <span class="hljs-number">48</span>aa6f27aecf<br>Successfully <span class="hljs-keyword">tagged</span> maven-quiz:latest<br></code></pre></td></tr></table></figure><h3 id="2-4-运行容器"><a href="#2-4-运行容器" class="headerlink" title="2.4 运行容器"></a>2.4 运行容器</h3><p>运行命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8000</span>:<span class="hljs-number">8000</span> -itd maven-quiz<br></code></pre></td></tr></table></figure><p>-docker run：运行容器</p><ul><li>-p：指定本地：容器端口映射</li><li>-itd：容器在后台运行</li><li>maven-quiz：指定镜像，:后加标签，默认为lastest</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p><p><a href="https://blog.csdn.net/zhezhebie/article/details/75501149">https://blog.csdn.net/zhezhebie/article/details/75501149</a></p><p><a href="http://book.itmuch.com/3%20%E4%BD%BF%E7%94%A8Docker%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1/3.6%20%E4%BD%BF%E7%94%A8Dockerfile%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F.html">http://book.itmuch.com/3%20%E4%BD%BF%E7%94%A8Docker%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1/3.6%20%E4%BD%BF%E7%94%A8Dockerfile%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F.html</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>OPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>OPS</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android组件化-MVP设计模式</title>
    <link href="/2019-03-31-android-modulize-mvp/"/>
    <url>/2019-03-31-android-modulize-mvp/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Anroid MVP是安卓开发中一个经典的话题，当项目较大、参与的开发人员较多，MVP的优势就体现出来了。</p><span id="more"></span><blockquote><p><strong>系列文章</strong></p><p><a href="/2018/10/18/android-modulize-common/">Android组件化-基础框架搭建</a></p><p><a href="/2018/10/23/android-modulize-router/">Android组件化-组件间通信BRouter</a></p><p><a href="/2019/03/21/android-modulize-ui-theme/">Android组件化-风格统一&amp;主题变色</a></p><p><a href="/2019/03/31/android-modulize-mvp/">Android组件化-MVP设计模式</a></p></blockquote><h2 id="一、经典的MVP"><a href="#一、经典的MVP" class="headerlink" title="一、经典的MVP"></a>一、经典的MVP</h2><blockquote><p>经典的意思，就是又老又香 ^-^</p></blockquote><h3 id="1-1-一句话MVP"><a href="#1-1-一句话MVP" class="headerlink" title="1.1 一句话MVP"></a>1.1 一句话MVP</h3><p>提到Android MVP（Model-View-Presenter）就会想到MVC（Model-View-Controller），C就是Web开发中经常提到的Controller，P则是Android中用来分离Activity逻辑与界面的Presenter。</p><p>MVP核心思想：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口，<span class="hljs-keyword">Model</span>类还是原来的<span class="hljs-keyword">Model</span>。<br><br></code></pre></td></tr></table></figure><h3 id="1-2-MVP图解"><a href="#1-2-MVP图解" class="headerlink" title="1.2 MVP图解"></a>1.2 MVP图解</h3><p>一图胜千言：</p><p><img src="https://blogres.blackist.org/android-modulize-mvp-struc.png" alt="MVP模型图"></p><ul><li>视图View：Activity和Fragment</li><li>逻辑Presenter：业务逻辑和业务管理类等</li><li>模型Model：SharedPreferences、数据库访问（Dao）和网络交互（Api）</li></ul><h2 id="二、Modulize使用MVP"><a href="#二、Modulize使用MVP" class="headerlink" title="二、Modulize使用MVP"></a>二、Modulize使用MVP</h2><p><a href="https://github.com/blackist/modulize">Modulize项目</a>使用MVP作为基本的开发框架（以登录为例）。</p><h3 id="2-1-Model层的设计"><a href="#2-1-Model层的设计" class="headerlink" title="2.1 Model层的设计"></a>2.1 Model层的设计</h3><p>Model层负责数据交互，包括网络交互、本地数据库交互以及SharedPreferences数据存取。在lib-common中添加抽象类BaseModel，LoginModel等业务模块继承自BaseModel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseModel</span> &#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="网络交互-okHttp-Retrofit-Rxjava"><a href="#网络交互-okHttp-Retrofit-Rxjava" class="headerlink" title="网络交互 - okHttp+Retrofit+Rxjava"></a>网络交互 - okHttp+Retrofit+Rxjava</h4><p>网络访问使用无话可说的okHttp，结合优雅的Retrofit，加以RxJava，真香！</p><p>使用okHttpClient实例管理全局http访问：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttp3Util</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> OkHttpClient mOkHttpClient;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取OkHttpClient对象实例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> OkHttpClient getOkHttpClient() &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == mOkHttpClient) &#123;<br><br>            <span class="hljs-comment">// build design mode</span><br>            mOkHttpClient = <span class="hljs-keyword">new</span> <span class="hljs-type">OkHttpClient</span>.Builder()<br>                    <span class="hljs-comment">// cookie manager</span><br>                    .cookieJar(<span class="hljs-keyword">new</span> <span class="hljs-type">CookiesManager</span>())<br>                    <span class="hljs-comment">// 网络请求日志</span><br>                    .addInterceptor(loggingInterceptor)<br>                    <span class="hljs-comment">// 自定义拦截器</span><br>                    .addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-type">CommonIntercepter</span>())<br>                    <span class="hljs-comment">// set timeout of connection, reading and writing</span><br>                    .connectTimeout(<span class="hljs-number">10</span>, TimeUnit.SECONDS)<br>                    .writeTimeout(<span class="hljs-number">30</span>, TimeUnit.SECONDS)<br>                    .readTimeout(<span class="hljs-number">20</span>, TimeUnit.SECONDS)<br>                    .cache(cache)<br>                    .build();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> mOkHttpClient;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在lib-common中新建ServiceGenerate类管理、创建Retrofit接口访问实例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceGenerator</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">API_SERVICE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://xxxx:8080/api/&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在gson中加入时间格式化，DateDeserializer\DateSerializer为自定义转换类.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonBuilder</span>()<br>            .registerTypeAdapter(java.util.Date.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateDeserializer</span>()).setDateFormat(DateFormat.LONG)<br>            .registerTypeAdapter(java.util.Date.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateSerializer</span>()).setDateFormat(DateFormat.LONG)<br>            .create();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * API Retrofit.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Retrofit</span> <span class="hljs-variable">apiGenerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>.Builder()<br>            .baseUrl(API_SERVICE)<br>            <span class="hljs-comment">// 自定义转换器一定要在gsonConverter前面,否则gson会拦截所有的解析方式</span><br>            .addConverterFactory(CustomConverterFactory.create())<br>            <span class="hljs-comment">// Gson Converter</span><br>            .addConverterFactory(GsonConverterFactory.create(gson))<br>            <span class="hljs-comment">// Callback Handler RxJava</span><br>            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())<br>            .client(OkHttp3Util.getOkHttpClient())<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>为了统一处理Http接口返回，创建Response响应类，应当和后台接口保持一致的gson格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Response</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> code;<br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-keyword">private</span> T data;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>基于Retrofit的登录Api如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">LoginApi</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * user login</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param username username</span><br><span class="hljs-comment">     * @param password password</span><br><span class="hljs-comment">     * @return user info</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">@FormUrlEncoded</span><br>    <span class="hljs-variable">@POST</span>(<span class="hljs-string">&quot;login&quot;</span>)<br>    Observable&lt;Response&lt;User&gt;&gt; <span class="hljs-built_in">loginStu</span>(<span class="hljs-variable">@Field</span>(<span class="hljs-string">&quot;username&quot;</span>) String username, <span class="hljs-variable">@Field</span>(<span class="hljs-string">&quot;password&quot;</span>) String password);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据库交互-GreenDao"><a href="#数据库交互-GreenDao" class="headerlink" title="数据库交互 - GreenDao"></a>数据库交互 - GreenDao</h4><p>使用J神家的的GreenDao，这个移动端ORM框架还是需要好好学习下的，本文仅介绍GrrenDao在MVP中的使用。在lib-db中创建DBHelper用于管理数据库连接和数据访问对象（Dao）实例：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">public class DBHelper &#123;<br><br><span class="hljs-keyword">    .</span>..<span class="hljs-built_in"> instance </span>init<br><br>   <span class="hljs-keyword"> public</span> &lt;T&gt; AbstractDao getDao(Class&lt;T&gt; clazz) &#123;<br>       <span class="hljs-built_in"> return </span>session.getDao(clazz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h4><p>使用SP存储用户偏好设置或登录认证数据等碎片数据。</p><h4 id="LoginModel"><a href="#LoginModel" class="headerlink" title="LoginModel"></a>LoginModel</h4><p>Model中持有Retrofit实例（api）、数据库访问对象（Dao）以及SP等本地存储对象：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> LoginModel extends BaseModel &#123;<br><br>    <span class="hljs-keyword">private</span> static final String TAG = <span class="hljs-string">&quot;LoginModel&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> LoginApi api;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <span class="hljs-keyword">private</span> SharedPreferences userPreference;<br><br>    public <span class="hljs-constructor">LoginModel()</span> &#123;<br>        <span class="hljs-comment">// 使用ServiceGenerator生成api访问类</span><br>        api = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceGenerator</span>.</span></span>create<span class="hljs-constructor">APIService(LoginApi.<span class="hljs-params">class</span>)</span>;<br>        <span class="hljs-comment">// 获取数据库访问对象</span><br>        userDao = (UserDao) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DBHelper</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.get<span class="hljs-constructor">Dao(User.<span class="hljs-params">class</span>)</span>;<br>        userPreference = context.get<span class="hljs-constructor">SharedPreferences(<span class="hljs-string">&quot;user&quot;</span>, Context.MODE_PRIVATE)</span>;<br>    &#125;<br><br>    public void set<span class="hljs-constructor">User(User <span class="hljs-params">user</span>)</span> &#123;<br>        userPreference.put(<span class="hljs-string">&quot;user&quot;</span>, user.get<span class="hljs-constructor">Name()</span>);<br>        userDao.insert(user);<br>    &#125;<br><br>    public void login(String username, String password, Observer&lt;Response&lt;User&gt;&gt; observer) &#123;<br>        rx<span class="hljs-constructor">Subscribe(<span class="hljs-params">api</span>.<span class="hljs-params">login</span>(<span class="hljs-params">username</span>, <span class="hljs-params">password</span>)</span>, observer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Presenter调用LoginModel方法时传递接口参数和Observer，LoginModel接口请求响应后回调Observer，rxSubscribe()定义在BaseModel中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseModel</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">rxSubscribe</span><span class="hljs-params">(Observable&lt;T&gt; observable, Observer&lt;T&gt; observer)</span> &#123;<br>        observable.subscribeOn(Schedulers.io())<br>                .subscribeOn(Schedulers.newThread())<span class="hljs-comment">//子线程访问网络</span><br>                .observeOn(AndroidSchedulers.mainThread())<span class="hljs-comment">//回调到主线程</span><br>                .subscribe(observer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Presenter层的设计"><a href="#2-2-Presenter层的设计" class="headerlink" title="2.2 Presenter层的设计"></a>2.2 Presenter层的设计</h3><p>Presenter持有Model实例，Presenter初始化时实例化Model，在lib-common中加入BasePresenter：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePresenter&lt;TView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseView</span>, <span class="hljs-title">TModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseModel&gt;</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">TView</span> mView;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">TModel</span> mModel;<br><br>    public <span class="hljs-type">BasePresenter</span>(<span class="hljs-type">TView</span> view) &#123;<br>        <span class="hljs-keyword">this</span>.mView = view;<br>        <span class="hljs-keyword">this</span>.mModel = <span class="hljs-keyword">this</span>.getModel();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">TModel</span> getModel();<br><br>    public void detach() &#123;<br>        <span class="hljs-keyword">this</span>.mView = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>LoginPresenter集成BasePresenter，实例化LoginModel：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginPresenter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BasePresenter</span>&lt;<span class="hljs-title class_">BaseActivity</span>, <span class="hljs-title class_">LoginModel</span>&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">LoginPresenter</span>(<span class="hljs-title class_">BaseActivity</span> activity) &#123;<br>        <span class="hljs-variable language_">super</span>(activity);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">LoginModel</span> <span class="hljs-title function_">getModel</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginModel</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">login</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> username, <span class="hljs-built_in">String</span> password</span>) &#123;<br>        <span class="hljs-comment">// 请求前 加载等待框</span><br>        mView.<span class="hljs-title function_">loadHud</span>();<br>        mModel.<span class="hljs-title function_">loginStudent</span>(username, password, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;<span class="hljs-title class_">Response</span>&lt;<span class="hljs-title class_">User</span>&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onCompleted</span>(<span class="hljs-params"></span>) &#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onError</span>(<span class="hljs-params">Throwable e</span>) &#123;<br>                e.<span class="hljs-title function_">printStackTrace</span>();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onNext</span>(<span class="hljs-params">Response&lt;User&gt; response</span>) &#123;<br>                <span class="hljs-comment">// 加载完成  取消等待框</span><br>                mView.<span class="hljs-title function_">cancelHud</span>();<br><br>                <span class="hljs-keyword">if</span> (response.<span class="hljs-title function_">OK</span>()) &#123;<br>                    <span class="hljs-comment">// 请求成功 回调VIew层进行页面刷新</span><br>            mView.<span class="hljs-title function_">onViewEvent</span>(<span class="hljs-title class_">BaseView</span>.<span class="hljs-property">VIEW_LOADED</span>, response.<span class="hljs-title function_">getData</span>());<br>                    <span class="hljs-comment">// 把用户信息保存在本地</span><br>                    mModel.<span class="hljs-title function_">setUser</span>(user);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 请求失败 回调View层报错</span><br>            mView.<span class="hljs-title function_">onViewEvent</span>(<span class="hljs-title class_">LoginActivity</span>.<span class="hljs-property">ERROR</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本项目在MVP中未使用接口的方式，在View中实现接口，在Presenter中持有实例并进行接口调用，因为使用接口则每个页面都需要新建一个接口类，较为繁琐。</p><p>本项目MVP使用BaseView中的抽象方法onViewEvent()，每个View继承BaseView后实现onViewEvent(int code, Object param)，Presenter层Attach BaseView后通过mView.onViewEvent()对View进行界面回调处理，View中根据事件code和参数param进行视图处理。</p><blockquote><p>一个Presenter可持有多个Model，定义多个Model对象并在Presenter构造函数中初始化。</p></blockquote><h3 id="2-3-View层的设计"><a href="#2-3-View层的设计" class="headerlink" title="2.3 View层的设计"></a>2.3 View层的设计</h3><p>在lib-common中定义BaseView，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">toast</span><span class="hljs-params">(<span class="hljs-meta">@StringRes</span> <span class="hljs-type">int</span> resId)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于Presenter中吐司提示</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">toast</span><span class="hljs-params">(String res)</span>;<br><br>    &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span>&gt; T <span class="hljs-title function_">findViewById</span><span class="hljs-params">(<span class="hljs-meta">@IdRes</span> <span class="hljs-type">int</span> resId)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于Presenter回调界面操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onViewEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> code, Object param)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在界面中统一处理数据、网络异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onViewState</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onViewState</span><span class="hljs-params">(Response response)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加载、取消Dialog</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadHud</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelHud</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>toast（）：Toast封装，用于在Activity、Fragment或Presenter中弹出用户提示</li><li>findViewById()：主要用于fragment中获取元素使用（组件化开发使用ButterKnife较为繁琐，不建议使用）</li><li>onViewEvent()：View层的回调，用于Presenter网络请求响应后通知View层</li><li>onViewState()：View层的回调。当Presenter层发生错误时统一处理View（网络异常、Http请求错误等）</li><li>loadHud()&#x2F;cancelHud()：加载ProgressDialog，Presenter发请网络请求时、请求结束后，在Presenter层弹出ProgressDialog</li></ul><h4 id="BaseActivity"><a href="#BaseActivity" class="headerlink" title="BaseActivity"></a>BaseActivity</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseActivity</span>&lt;<span class="hljs-title class_">TPresenter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasePresenter</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BaseView</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">Handler</span> mUIHandler;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">TPresenter</span> mPresenter;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">KProgressHUD</span> mHud;<br>    <br>    <span class="hljs-comment">// 获取界面layout资源文件</span><br>    <span class="hljs-meta">@LayoutRes</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> int <span class="hljs-title function_">getLayoutResId</span>();<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">initViewAndData</span>(<span class="hljs-meta">@Nullable</span> <span class="hljs-title class_">Bundle</span> savedInstanceState);<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title class_">TPresenter</span> <span class="hljs-title function_">getPresenter</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onCreate</span>(<span class="hljs-params"><span class="hljs-meta">@Nullable</span> Bundle savedInstanceState</span>) &#123;<br>        <span class="hljs-title function_">beforeCreate</span>();<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onCreate</span>(savedInstanceState);<br>        <span class="hljs-title function_">beforeSetContentView</span>();<br>        <span class="hljs-title function_">setContentView</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getLayoutResId</span>());<br>        <span class="hljs-comment">// init</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initViewAndData</span>(savedInstanceState);<br><br>        <span class="hljs-comment">// EventBus</span><br>        <span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">getDefault</span>().<span class="hljs-title function_">register</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * before set contentView</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">beforeSetContentView</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// NoTitle</span><br>        <span class="hljs-title function_">requestWindowFeature</span>(<span class="hljs-title class_">Window</span>.<span class="hljs-property">FEATURE_NO_TITLE</span>);<br>        <span class="hljs-comment">// ScreenPortrait</span><br>        <span class="hljs-title function_">setRequestedOrientation</span>(<span class="hljs-title class_">ActivityInfo</span>.<span class="hljs-property">SCREEN_ORIENTATION_PORTRAIT</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * before create</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 统一设置主题</span><br>        <span class="hljs-title function_">setTheme</span>(<span class="hljs-title class_">UIConfig</span>.<span class="hljs-title function_">getInstance</span>(<span class="hljs-title function_">getApplicationContext</span>()).<span class="hljs-title function_">getThemeId</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Subscribe</span>(threadMode = <span class="hljs-title class_">ThreadMode</span>.<span class="hljs-property">MAIN</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onEventMainThread</span>(<span class="hljs-params">CommonEvent event</span>) &#123;<br>        <span class="hljs-comment">// EventBus统一处理全局异常</span><br>        <span class="hljs-title class_">BLog</span>.<span class="hljs-title function_">e</span>(<span class="hljs-string">&quot;[Event]: &quot;</span> + event.<span class="hljs-property">code</span>);<br>        <span class="hljs-keyword">if</span> (event.<span class="hljs-property">code</span> == <span class="hljs-title class_">CommonEvent</span>.<span class="hljs-property">Type</span>.<span class="hljs-property">NETWORK_ERROR</span>) &#123;<br>            <span class="hljs-title function_">onViewState</span>(<span class="hljs-title class_">UIConstants</span>.<span class="hljs-property">ViewState</span>.<span class="hljs-property">NETWORK_DISCONNECTED</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">mCommonEvent</span> != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">mCommonEvent</span>.<span class="hljs-title function_">onCommonEvent</span>(event.<span class="hljs-property">code</span>, event.<span class="hljs-property">param</span>);<br>            &#125;<br>            <span class="hljs-comment">// cancel loading hud</span><br>            <span class="hljs-title function_">cancelHud</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * init view, e.g commonTitleBar.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// view init</span><br>        ...<br><br>        <span class="hljs-comment">// 从子类拿到Presenter实例</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">mPresenter</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPresenter</span>();<br>        <span class="hljs-comment">// 使用第三方库作为Loading Dialog</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">mHud</span> = <span class="hljs-title class_">KProgressHUD</span>.<span class="hljs-title function_">create</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onViewState</span>(<span class="hljs-params">int state</span>) &#123;<br>        <span class="hljs-comment">// 全局异常处理</span><br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onViewState</span>(<span class="hljs-params">Response response</span>) &#123;<br>        <span class="hljs-comment">// 根据Response处理服务器http响应</span><br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onDestroy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onDestroy</span>();<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">mUIHandler</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// Unregister EventBus</span><br>        <span class="hljs-title class_">EventBus</span>.<span class="hljs-title function_">getDefault</span>().<span class="hljs-title function_">unregister</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span>&gt; T <span class="hljs-title function_">findViewById</span>(<span class="hljs-params">int resId</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">findViewById</span>(resId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">toast</span>(<span class="hljs-params"><span class="hljs-meta">@StringRes</span> final int resId</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mUIHandler == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mUIHandler.<span class="hljs-title function_">post</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title class_">Toast</span>.<span class="hljs-title function_">makeText</span>(<br>                        <span class="hljs-title function_">getApplicationContext</span>(),<br>                        resId,<br>                        <span class="hljs-title class_">Toast</span>.<span class="hljs-property">LENGTH_SHORT</span>).<span class="hljs-title function_">show</span>();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">toast</span>(<span class="hljs-params">final <span class="hljs-built_in">String</span> res</span>) &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">loadHud</span>(<span class="hljs-params">int resId</span>) &#123;<br>        <span class="hljs-comment">// 加载等待Dialog</span><br>        <span class="hljs-keyword">if</span> (mHud == <span class="hljs-literal">null</span>) &#123;<br>            mHud = <span class="hljs-title class_">KProgressHUD</span>.<span class="hljs-title function_">create</span>(<span class="hljs-variable language_">this</span>);<br>        &#125;<br>        mHud.<span class="hljs-title function_">setStyle</span>(<span class="hljs-title class_">KProgressHUD</span>.<span class="hljs-property">Style</span>.<span class="hljs-property">SPIN_INDETERMINATE</span>)<br>                .<span class="hljs-title function_">setCancellable</span>(<span class="hljs-literal">true</span>)<br>                .<span class="hljs-title function_">setLabel</span>(resId == <span class="hljs-number">0</span> ? <span class="hljs-title function_">getString</span>(R.<span class="hljs-property">string</span>.<span class="hljs-property">opt_loading</span>) : <span class="hljs-title function_">getString</span>(resId))<br>                .<span class="hljs-title function_">setAnimationSpeed</span>(<span class="hljs-number">1</span>)<br>                .<span class="hljs-title function_">setDimAmount</span>(<span class="hljs-number">0.</span>5f)<br>                .<span class="hljs-title function_">show</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">cancelHud</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (mHud != <span class="hljs-literal">null</span>) &#123;<br>            mHud.<span class="hljs-title function_">dismiss</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>loadHud()：参考第三方库<a href="https://github.com/Kaopiz/KProgressHUD">https://github.com/Kaopiz/KProgressHUD</a></li></ul><h4 id="BaseFragment"><a href="#BaseFragment" class="headerlink" title="BaseFragment"></a>BaseFragment</h4><p>类似BaseActivity，加入一些对宿主Activity的回调。</p><p>参考<a href="https://github.com/blackist/modulize/blob/8478eb2a4bdaf7b9f9e2022be0e9462ea82b3eeb/lib-common/src/main/java/org/blackist/common/base/BaseFragment.java">https://github.com/blackist/modulize/blob/8478eb2a4bdaf7b9f9e2022be0e9462ea82b3eeb/lib-common/src/main/java/org/blackist/common/base/BaseFragment.java</a></p><h4 id="LoginActivity"><a href="#LoginActivity" class="headerlink" title="LoginActivity"></a>LoginActivity</h4><p>LoginActivity继承自BaseActivity，实例化LoginPresenter，实现onViewEvent()回调函数：</p><pre><code class="hljs">public class LoginActivity extends BaseActivity&lt;LoginPresenter&gt; implements View.OnClickListener &#123;    private static final String TAG = &quot;LoginActivity&quot;;    public static final int ERROR = 1000;    @Override    protected int getLayoutResId() &#123;        return R.layout.main_login_activity;    &#125;    @Override    protected void initViewAndData(@Nullable Bundle savedInstanceState) &#123;        initView();        ...    &#125;    @Override    protected LoginPresenter getPresenter() &#123;        return new LoginPresenter(this);    &#125;    @Override    public void onClick(View v) &#123;        ...    &#125;    @Override    public void onViewEvent(int code, Object param) &#123;        switch (code) &#123;            case VIEW_LOADED: &#123;                // 登录成功处理                ...                startActivity(new Intent(this, MainActivity.class));                finish();            &#125;            break;            case ERROR: &#123;                toast(R.string.main_login_error);            &#125;            break;            default:        &#125;    &#125;&#125;</code></pre><blockquote><p>通常情况下一个View对应一个Presenter，也可在View中定义多个Presenter对象并在initViewAndData()中初始化</p></blockquote><p>至此，实现了精简版的Android MVP，本人用在项目开发中问题不大。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000003927200">https://segmentfault.com/a/1190000003927200</a></p><p><a href="https://juejin.im/post/5a61559051882573351a5fb6">https://juejin.im/post/5a61559051882573351a5fb6</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>组件化</tag>
      
      <tag>MVP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android组件化-UI统一&amp;主题变色</title>
    <link href="/2019-03-21-android-modulize-ui-theme/"/>
    <url>/2019-03-21-android-modulize-ui-theme/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>客户端开发中UI设计极其重要，直接影响用户体验和App的品质；其次UI设计应做到样式、排版统一，简化布局文件，方便全局修改和维护。</p><span id="more"></span><blockquote><p><strong>系列文章</strong></p><p><a href="/2018/10/18/android-modulize-common/">Android组件化-基础框架搭建</a></p><p><a href="/2018/10/23/android-modulize-router/">Android组件化-组件间通信BRouter</a></p><p><a href="/2019/03/21/android-modulize-ui-theme/">Android组件化-风格统一&amp;主题变色</a></p><p><a href="/2019/03/31/android-modulize-mvp/">Android组件化-MVP设计模式</a></p></blockquote><h2 id="一、样式排版统一"><a href="#一、样式排版统一" class="headerlink" title="一、样式排版统一"></a>一、样式排版统一</h2><h3 id="1-1-共用style"><a href="#1-1-共用style" class="headerlink" title="1.1 共用style"></a>1.1 共用style</h3><h4 id="基础颜色表"><a href="#基础颜色表" class="headerlink" title="基础颜色表"></a>基础颜色表</h4><p>在values资源文件夹下添加文件colors.xml，加入常用的基础颜色值，使全局组件色调保持一致：</p><p><img src="https://blogres.blackist.org/android-modulize-ui-common-style-color.png" alt="颜色表参考 https://stackoverflow.com/a/7323234/8945448"></p><p>除基础颜色，还可添加App主题色调，使得ActionBar、Tab等组件颜色和主题色保持一致：</p><p><img src="https://blogres.blackist.org/android-modulize-ui-color-theme.png" alt="ActionBar TabBar等组件颜色"></p><p><img src="https://blogres.blackist.org/android-modulize-ui-style-action-bar.png" alt="ActionBar TabBar"></p><h4 id="统一布局尺寸和文字大小"><a href="#统一布局尺寸和文字大小" class="headerlink" title="统一布局尺寸和文字大小"></a>统一布局尺寸和文字大小</h4><p>Android界面设计需要统一排版，如图标边距、文字大小、ListItem间隔等，在values资源文件夹下添加文件dimen.xml，添加统一的布局距离和文字大小：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;font_larger&quot;</span>&gt;</span>22sp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;font_large&quot;</span>&gt;</span>18sp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;font_normal&quot;</span>&gt;</span>16sp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;font_small&quot;</span>&gt;</span>14sp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;font_smaller&quot;</span>&gt;</span>12sp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;font_smallest&quot;</span>&gt;</span>10sp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_huge&quot;</span>&gt;</span>40dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_larger&quot;</span>&gt;</span>34dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_large&quot;</span>&gt;</span>24dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_biger&quot;</span>&gt;</span>20dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_big&quot;</span>&gt;</span>18dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_normal&quot;</span>&gt;</span>14dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_small&quot;</span>&gt;</span>12dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_smaller&quot;</span>&gt;</span>10dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_smallest&quot;</span>&gt;</span>8dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_tiny&quot;</span>&gt;</span>6dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_tinyer&quot;</span>&gt;</span>4dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_tinyest&quot;</span>&gt;</span>2dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing_border&quot;</span>&gt;</span>12dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>界面排版等的尺寸可以参考如下布局，</p><ul><li>菜单选项内边距、字体颜色、选中颜色、背景色、上线分割线</li><li>ListView中Item的外边距、图标尺寸、图标和内容的间距、内容区标题和内容的文字尺寸颜色、Item分割线</li><li>Tab菜单选项图标尺寸、文字尺寸、Item间隔、Item选中样式</li></ul><p><img src="https://blogres.blackist.org/android-modulize-ui-layout-size.png" alt="布局尺寸"></p><h4 id="统一样式"><a href="#统一样式" class="headerlink" title="统一样式"></a>统一样式</h4><p>应用内组件的样式应保持统一，比如按钮、弹窗、菜单列表等，在values资源文件夹下定义styles.xml（或新建文件把样式分离出来，如style-btn.xml），方便全局修改。</p><p>如下在布局文件中添加几个按钮，无任何样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_mine&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Mine&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_message&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Message&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_theme&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ButtonTheme&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Theme&quot;</span> /&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="https://blogres.blackist.org/android-modulize-ui-common-style-button-normal.png"></p><p>现加入按钮字体、内边距、背景等样式，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_mine&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/theme_button_selector&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:paddingBottom</span>=<span class="hljs-string">&quot;@dimen/spacing_smallest&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:paddingTop</span>=<span class="hljs-string">&quot;@dimen/spacing_smallest&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Mine&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/white&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;@dimen/font_normal&quot;</span> /&gt;</span><br><br>...<br><br>...<br><br></code></pre></td></tr></table></figure><p>theme-button-selector.xml如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_pressed</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;3dip&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1dip&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">gradient</span> <span class="hljs-attr">android:angle</span>=<span class="hljs-string">&quot;-90&quot;</span> <span class="hljs-attr">android:endColor</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span> <span class="hljs-attr">android:startColor</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_focused</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;3dip&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1dip&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">solid</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;@color/colorPrimaryDark&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;3dip&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1dip&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">gradient</span> <span class="hljs-attr">android:angle</span>=<span class="hljs-string">&quot;-90&quot;</span> <span class="hljs-attr">android:endColor</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span> <span class="hljs-attr">android:startColor</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>加入统一的样式后，三个按钮好看些了^-^：</p><p><img src="https://blogres.blackist.org/android-modulize-ui-common-style-button.png"></p><p>但布局文件也变得格外冗长，为减少重复的布局代码，抽离通用样式，在styles.xml添加如下元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ButtonTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;@android:style/Widget.Button&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textSize&quot;</span>&gt;</span>@dimen/font_normal<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textColor&quot;</span>&gt;</span>@color/white<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_height&quot;</span>&gt;</span>wrap_content<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_width&quot;</span>&gt;</span>match_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_margin&quot;</span>&gt;</span>@dimen/spacing_tiny<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingTop&quot;</span>&gt;</span>@dimen/spacing_smallest<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingBottom&quot;</span>&gt;</span>@dimen/spacing_smallest<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@drawable/theme_button_selector<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>重新修改布局文件，三个按钮使用通用样式，代码简化了很多：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_mine&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ButtonTheme&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Mine&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_message&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ButtonTheme&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Message&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_theme&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/ButtonTheme&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Theme&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="布局重用"><a href="#布局重用" class="headerlink" title="布局重用"></a>布局重用</h4><p>有些布局组件可在全局复用，例如自定义TitleBar、ActionBar，本项目<a href="https://github.com/blackist/modulize">Modulize</a>使用<a href="https://github.com/wuhenzhizao/android-titlebar">第三方库CommonTitleBar</a>作为标题栏布局，在layout资源文件夹中定义common_titlebar.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">merge</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.wuhenzhizao.titlebar.widget.CommonTitleBar</span> <span class="hljs-attr">xmlns:titlebar</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/titlebar&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:centerTextColor</span>=<span class="hljs-string">&quot;@color/white&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:centerTextSize</span>=<span class="hljs-string">&quot;@dimen/font_normal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:centerType</span>=<span class="hljs-string">&quot;textView&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:fillStatusBar</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:leftImageResource</span>=<span class="hljs-string">&quot;@drawable/common_transparent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:leftType</span>=<span class="hljs-string">&quot;imageButton&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:rightType</span>=<span class="hljs-string">&quot;imageButton&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:showBottomLine</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:statusBarColor</span>=<span class="hljs-string">&quot;?attr/colorPrimaryDark&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">titlebar:titleBarColor</span>=<span class="hljs-string">&quot;?attr/colorPrimary&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">merge</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>在activity布局文件中使用include引入此布局，merge标签为了减少视图层级（详细使用参考<a href="https://blog.csdn.net/xyz_lmn/article/details/14524567">Android抽象布局</a>）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/common_titlebar&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_mine&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;?android:attr/buttonStyle&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Mine&quot;</span> /&gt;</span><br><br></code></pre></td></tr></table></figure><p>布局复用可以有效地统一标题栏风格，每个页面设置不同的标题和图标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">commonTitleBar = findViewById(R.id.common_titlebar);<br>commonTitleBar.getCenterTextView().setText(<span class="hljs-string">&quot;标题栏&quot;</span>);<br>commonTitleBar.getRightImageButton().setImageResource(R.drawable.main_action_icon_user);<br><br></code></pre></td></tr></table></figure><p><img src="https://blogres.blackist.org/android-modulize-ui-common-style-actionbar.png" alt="ActionBar"></p><h3 id="1-2-UI模块lib-ui"><a href="#1-2-UI模块lib-ui" class="headerlink" title="1.2 UI模块lib-ui"></a>1.2 UI模块lib-ui</h3><p>模块化开发应用模块之间不直接相互依赖，各模块之间内的样式不可直接被其他模块调用，因此有必要创建UI基础库，将公共样式放在UI库中。</p><p>按照<a href="/2018/10/18/android-modulize-common/">Android组件化-基础框架搭建</a>中基础库搭建方法，新建lib-ui存放公共样式和资源文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cmd">├─res<br>|  ├─values<br>|  |   ├─colors.xml<br>|  |   ├─dimens.xml<br>|  |   ├─strings.xml<br>|  |   ├─styles.xml<br>|  |   └theme.xml<br>|  ├─layout<br>|  |   └common_titlebar.xml<br>|  ├─drawable-xxxhdpi<br>|  |        ├─action_bar_add.png<br>|  ├─drawable-xxhdpi<br>|  |        ├─action_bar_add.png<br>|  ├─drawable-xhdpi<br>|  |       ├─action_bar_add.png<br>|  ├─drawable-mdpi<br>|  |       ├─action_bar_add.png<br>|  ├─drawable-hdpi<br>|  |       ├─action_bar_add.png<br>|  ├─drawable<br>|  |    ├─common_transparent.xml<br>|  |    └theme_button_selector.xml<br><br></code></pre></td></tr></table></figure><p>使lib-common依赖lib-ui，因此各应用模块就可以使用lib-ui中的公共样式。</p><h2 id="二、主题切换"><a href="#二、主题切换" class="headerlink" title="二、主题切换"></a>二、主题切换</h2><p>主题切换功能开发思路如下：</p><ul><li>根据上述布局风格统一原则配置两套主题</li><li>在Activity中为App设置主题</li><li>动态设置主题，主题设置立即生效</li><li>复杂的View组件随主题动态变化</li></ul><h3 id="2-1-主题配置"><a href="#2-1-主题配置" class="headerlink" title="2.1 主题配置"></a>2.1 主题配置</h3><h4 id="配置至少两个主题"><a href="#配置至少两个主题" class="headerlink" title="配置至少两个主题"></a>配置至少两个主题</h4><p>在lib-ui\src\main\res下添加两个资源文件theme-default.xml、theme-dark.xml，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">├─values<br>|   ├─theme-dark.xml<br>|   ├─theme-default.xml<br>|   └theme.xml<br></code></pre></td></tr></table></figure><p>在theme.xml添加主题父类，theme-default和theme-dark中分别定义两个主题继承theme中的父主题：</p><p>theme.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  Base application theme. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppBaseTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--&lt;item name=&quot;android:background&quot;&gt;@drawable/main_background&lt;/item&gt;--&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>theme-default.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Default application theme. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;AppBaseTheme&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- Customize your theme here. --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowBackground&quot;</span>&gt;</span>@color/light_gray<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:buttonStyle&quot;</span>&gt;</span>@style/ButtonTheme<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>#289ff4<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>#0b79b7<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/white<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ButtonTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;@android:style/Widget.Button&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textSize&quot;</span>&gt;</span>@dimen/font_normal<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textColor&quot;</span>&gt;</span>@color/white<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_height&quot;</span>&gt;</span>wrap_content<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_width&quot;</span>&gt;</span>match_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_margin&quot;</span>&gt;</span>@dimen/spacing_tiny<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingTop&quot;</span>&gt;</span>@dimen/spacing_smallest<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingBottom&quot;</span>&gt;</span>@dimen/spacing_smallest<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@drawable/theme_button_selector<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>theme-dark.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Dark application theme. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppDarkTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;AppBaseTheme&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- Customize your theme here. --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorDarkPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorDarkPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorDarkAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowBackground&quot;</span>&gt;</span>@color/colorDarkPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:buttonStyle&quot;</span>&gt;</span>@style/DarkButtonTheme<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorDarkPrimary&quot;</span>&gt;</span>#222222<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorDarkPrimaryDark&quot;</span>&gt;</span>#333333<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorDarkAccent&quot;</span>&gt;</span>#333333<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DarkButtonTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;@android:style/Widget.Button&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textSize&quot;</span>&gt;</span>@dimen/font_normal<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textColor&quot;</span>&gt;</span>@color/white<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_height&quot;</span>&gt;</span>wrap_content<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_width&quot;</span>&gt;</span>match_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_margin&quot;</span>&gt;</span>@dimen/spacing_tiny<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingTop&quot;</span>&gt;</span>@dimen/spacing_smallest<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingBottom&quot;</span>&gt;</span>@dimen/spacing_smallest<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@drawable/theme_button_selector<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="配置的内容"><a href="#配置的内容" class="headerlink" title="配置的内容"></a>配置的内容</h4><p>主题配置中重要的配置项，参见Material Design的<a href="https://material.io/design/color/#color-theme-creation">The Color System</a>：</p><ul><li>colorPrimary：基色，跨域整个App各个页面和组件最常用的颜色，常用于应用栏（Appbar）</li><li>colorPrimaryDark：重基色，一般为状态栏（Sytembar）的颜色，与应用栏形成对比色</li><li>colorAccent:着重色，各View被选中或突出显示时的颜色；Item或CardView的背景色</li><li>android:windowBackground：界面背景色</li><li>android:buttonStyle：按钮样式；其他组件样式也可全局定义</li></ul><p><img src="https://blogres.blackist.org/android-modulize-ui-theme-color-system.png" alt="颜色系统"></p><p>各样式和value在activity布局文件中使用如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;?android:windowBackground&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;org.blackist.modulize.main.view.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/common_titlebar&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_mine&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;?android:attr/buttonStyle&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Mine&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_message&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;?android:attr/buttonStyle&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Message&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_module_theme&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;?android:attr/buttonStyle&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Theme&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.CardView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_margin</span>=<span class="hljs-string">&quot;@dimen/spacing_tiny&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;?attr/colorAccent&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;@dimen/spacing_tiny&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;?attr/colorAccent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Use colorAccent \nAs \nItem Backgroud&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.v7.widget.CardView</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><p>为页面设置背景色，使用 <strong>background&#x3D;”?android:windowBackground”</strong> 属性;</p><p>colorAccent用作List Item布局 或 局部布局的背景，当主题切换时Item背景随之切换，使用方式 **background&#x3D;”?attr&#x2F;colorAccent”**；</p><p>Button等组件的样式使用 **style&#x3D;”?android:attr&#x2F;buttonStyle”**设置；</p><p>本项目文字颜色自适应，即根据当前主题，安卓系统会自动设置字黑色或白色；</p><p>从 <strong>?android:windowBackground</strong> 和 <strong>?colorAccent</strong> 中可以看出，根据如下主题配置项配置方式，决定布局文件中使用这些属性的方式：</p><p><img src="https://blogres.blackist.org/android-modulize-ui-theme-item.png" alt="主题配置项配置方式"></p><h3 id="2-2-主题切换"><a href="#2-2-主题切换" class="headerlink" title="2.2 主题切换"></a>2.2 主题切换</h3><p>使用SDK中的setTheme方法设置主题，设置主题需要在setContentView()之前调用：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Override</span><br>public void <span class="hljs-built_in">onCreate</span>(<span class="hljs-variable">@Nullable</span> Bundle savedInstanceState) &#123;<br>    <span class="hljs-selector-tag">super</span><span class="hljs-selector-class">.onCreate</span>(savedInstanceState);<br>    <span class="hljs-comment">// before set ContentView</span><br>    <span class="hljs-selector-tag">setTheme</span>(mThemeDefault ? R.style.<span class="hljs-attribute">setTheme </span>: R.style.AppTheme);<br>    <span class="hljs-selector-tag">setContentView</span>(R.layout.main_activity);<br>&#125;<br></code></pre></td></tr></table></figure><p>mThemeDefault为boolean类型的值，存储在SharedPreference中，App启动时读取其值使得App记住用户偏好。</p><p>切换后的主题如下：                    </p><p><img src="https://blogres.blackist.org/android-modulize-ui-theme-dark_.jpg"></p><h4 id="2-3-主题动态切换"><a href="#2-3-主题动态切换" class="headerlink" title="2.3 主题动态切换"></a>2.3 主题动态切换</h4><p>当使用按钮或Switch触发主题设置后，视图已经创建，设置不能立即生效，需要重启App才能看到效果。想要立即生效则需要重建当前栈中所有activity，因此需要获取到所有已加载activity，使用lib-apptools下的AppManager工具类，在Activity的onCreate()中将自身加入Activity栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">AppManager.getInstance().addActivity(<span class="hljs-built_in">this</span>);<br><br></code></pre></td></tr></table></figure><p>在onDestory()中使activity出栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">AppManager.getInstance().removeActivity(<span class="hljs-built_in">this</span>);<br><br></code></pre></td></tr></table></figure><p>调用AppManager.getInstance().recreateAllActivity()方法重建栈中Activity，使得主题切换立即生效。</p><h2 id="三、组件主题"><a href="#三、组件主题" class="headerlink" title="三、组件主题"></a>三、组件主题</h2><p>配置某些组件跟随主题变换颜色等样式。</p><h3 id="3-1-AlertDialog"><a href="#3-1-AlertDialog" class="headerlink" title="3.1 AlertDialog"></a>3.1 AlertDialog</h3><p>配置Dialog的默认样式类似于Button的全局样式，但稍加复杂一些。</p><p>在theme-default.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Default application theme. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;AppBaseTheme&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;alertDialogTheme&quot;</span>&gt;</span>@style/AlertDialog<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AlertDialog&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.Light.Dialog.Alert&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowTitleStyle&quot;</span>&gt;</span>@style/AlertDialogTitle<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AlertDialogTitle&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textAppearance&quot;</span>&gt;</span>@style/AlertDialogTitleStyle<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AlertDialogTitleStyle&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;@android:style/TextAppearance.Holo.DialogWindowTitle&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textSize&quot;</span>&gt;</span>@dimen/font_normal<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textColor&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>theme-dark.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Dark application theme. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppDarkTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;AppBaseTheme&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;alertDialogTheme&quot;</span>&gt;</span>@style/DarkAlertDialog<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DarkAlertDialog&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.Light.Dialog.Alert&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowTitleStyle&quot;</span>&gt;</span>@style/DarkAlertDialogTitle<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/text_hint<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@color/colorDarkAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DarkAlertDialogTitle&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textAppearance&quot;</span>&gt;</span>@style/DarkAlertDialogTitleStyle<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DarkAlertDialogTitleStyle&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;@android:style/TextAppearance.Holo.DialogWindowTitle&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textSize&quot;</span>&gt;</span>@dimen/font_normal<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:textColor&quot;</span>&gt;</span>@color/text_hint<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>在Activity中new AlertDialog即可，无需多余的样式设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">mTypeDialog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.Builder(MainActivity.<span class="hljs-built_in">this</span>)<br>    .setIcon(R.mipmap.ic_launcher_round)<br>    .setTitle(<span class="hljs-string">&quot;AlertDialog Theme&quot;</span>)<br>    .setNegativeButton(<span class="hljs-string">&quot;Cancel&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.OnClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(DialogInterface dialog, <span class="hljs-type">int</span> which)</span> &#123;<br>            dialog.dismiss();<br>        &#125;<br>    &#125;)<br>    .setPositiveButton(<span class="hljs-string">&quot;Confirm&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.OnClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(DialogInterface dialog, <span class="hljs-type">int</span> which)</span> &#123;<br>            dialog.dismiss();<br>        &#125;<br>    &#125;).create();<br>mTypeDialog.show();<br><br></code></pre></td></tr></table></figure><p><img src="https://blogres.blackist.org/android-modulize-ui-theme-alertdialog-nal.png"></p><p>切换主题后，AlertDialog样式随之变化：</p><p><img src="https://blogres.blackist.org/android-modulize-ui-theme-alertdialog.png"></p><h3 id="3-2-获取当前主题属性"><a href="#3-2-获取当前主题属性" class="headerlink" title="3.2 获取当前主题属性"></a>3.2 获取当前主题属性</h3><p>在某些自定义组件中需要获取App主题色，比如在AlertDialog中添加一个轮滑选择器，自定义组件Whiew（在lib-ui\src\main\java\org\blackist\modulize\ui\widget\whiew下），当设置文本时需要获取当前主题的相关属性来设置样式。</p><h4 id="获取Color"><a href="#获取Color" class="headerlink" title="获取Color"></a>获取Color</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">TypedValue typedValue = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TypedValue()</span>;<br>Theme theme = context.get<span class="hljs-constructor">Theme()</span>;<br>theme.resolve<span class="hljs-constructor">Attribute(R.<span class="hljs-params">attr</span>.<span class="hljs-params">colorPrimary</span>, <span class="hljs-params">typedValue</span>, <span class="hljs-params">true</span>)</span>;<br>@ColorInt <span class="hljs-built_in">int</span> color = typedValue.data;<span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span><br></code></pre></td></tr></table></figure><h4 id="获取Dimen"><a href="#获取Dimen" class="headerlink" title="获取Dimen"></a>获取Dimen</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">tv.set<span class="hljs-constructor">TextSize(TypedValue.COMPLEX_UNIT_PX, <span class="hljs-params">context</span>.<span class="hljs-params">getResources</span>()</span>.get<span class="hljs-constructor">DimensionPixelSize(R.<span class="hljs-params">dimen</span>.<span class="hljs-params">font_normal</span>)</span>);<br><br></code></pre></td></tr></table></figure><p><img src="https://blogres.blackist.org/android-modulize-ui-theme-prop.png"></p><hr><p>项目Github地址：<a href="https://github.com/blackist/modulize">https://github.com/blackist/modulize</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.25xt.com/android">https://www.25xt.com/android</a></p><p><a href="https://blog.csdn.net/xyz_lmn/article/details/14524567">https://blog.csdn.net/xyz_lmn&#x2F;article&#x2F;details&#x2F;14524567</a></p><p><a href="https://material.io/design/color/#color-theme-creation">https://material.io/design/color/#color-theme-creation</a></p><p><a href="https://stackoverflow.com/questions/29797134/how-to-use-and-style-new-alertdialog-from-appcompat-22-1-and-above">https://stackoverflow.com/questions/29797134/how-to-use-and-style-new-alertdialog-from-appcompat-22-1-and-above</a></p><p><a href="https://stackoverflow.com/questions/17277618/get-color-value-programmatically-when-its-a-reference-theme">https://stackoverflow.com/questions/17277618/get-color-value-programmatically-when-its-a-reference-theme</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>校友录-网站样式设计</title>
    <link href="/2019-03-14-javaweb-ar-style/"/>
    <url>/2019-03-14-javaweb-ar-style/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/blackist/ar">校友录</a>项目网站样式设计简要说明。</p><span id="more"></span><h2 id="一、门户网站"><a href="#一、门户网站" class="headerlink" title="一、门户网站"></a>一、门户网站</h2><h3 id="1-1-首页轮播图"><a href="#1-1-首页轮播图" class="headerlink" title="1.1 首页轮播图"></a>1.1 首页轮播图</h3><p>在 ar-parent\ar-portal\src\main\webapp\WEB-INF\views\portal-main\index.jsp 中有如下代码：</p><p><img src="https://blogres.blackist.org/spring-ar-style-portal-index.png"></p><p>div.carousel中即使首页的轮播图，图片暂不支持后台手动设置，需要存放在 assets&#x2F;images&#x2F;school&#x2F; 下或assets其它文件夹下面。</p><p>图片尺寸建议采用2600x720的。</p><h3 id="1-2-导航栏样式"><a href="#1-2-导航栏样式" class="headerlink" title="1.2 导航栏样式"></a>1.2 导航栏样式</h3><p>导航栏由两部分组成：</p><p><img src="https://blogres.blackist.org/spring-ar-style-portal-index-header.png"></p><p>上面的header，下面的是导航菜单(nav)，这两部分在index.jsp中通过include引入，分别位于 WEB-INF&#x2F;views&#x2F;portal-common&#x2F;header.jsp 和 WEB-INF&#x2F;views&#x2F;portal-common&#x2F;navmenu.jsp。门户网站主要样式在 assets&#x2F;css&#x2F;style.css 中定义。</p><h4 id="Header样式"><a href="#Header样式" class="headerlink" title="Header样式"></a>Header样式</h4><p>在style.css中搜索 .top_bg，找到如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*-- header_top --*/</span><br><span class="hljs-selector-class">.top_bg</span> &#123;<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#666666</span>;<br><span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>background就是header的背景色。</p><h4 id="Nav样式"><a href="#Nav样式" class="headerlink" title="Nav样式"></a>Nav样式</h4><p>在style.css中搜索 .mega_nav，找到如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.mega_nav</span> &#123;<br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;<br><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">6px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#CCCBCB</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改background改变Nav整个背景色。Nav中菜单项的颜色在 assets&#x2F;css&#x2F;megamenu.css 中定义，找到如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.skyblue</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.color1</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br><span class="hljs-attribute">background</span>:<span class="hljs-number">#204056</span>;<br><span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即可修改菜单项hover的样式，菜单项背景色等可以自行探索。</p><p>修改后导航栏后整体样式如下（一不小心破相了~）：</p><p><img src="https://blogres.blackist.org/spring-ar-style-portal-index-style.png"></p><h3 id="1-3-表单样式"><a href="#1-3-表单样式" class="headerlink" title="1.3 表单样式"></a>1.3 表单样式</h3><p>门户网站表单组件绝大部分使用bootstrap样式：</p><p><img src="https://blogres.blackist.org/spring-ar-style-portal-profile.png"></p><p>可根据bootstrap修改按钮等组件样式，本项目参考了一份模板进行设计，整个模板素材存在 ar\ar-tools\model-portal\Bracket1.5\ 下。</p><p>表单样式：</p><p><img src="https://blogres.blackist.org/spring-ar-style-portal-bootstrap.png"></p><p>按钮样式：</p><p><img src="https://blogres.blackist.org/spring-ar-style-portal-bootstrap-button.png"></p><p>表格及分页器：</p><p><img src="https://blogres.blackist.org/spring-ar-style-portal-bootstrap-pager.png"></p><p>门户网站风格和此模板素材基本保持一致，可参考修改。</p><h2 id="二、后台管理"><a href="#二、后台管理" class="headerlink" title="二、后台管理"></a>二、后台管理</h2><p>后台管理网站样式主要定义在 ar-manage\src\main\webapp\assets\css\admin.css 下。</p><h3 id="1-1-首页样式"><a href="#1-1-首页样式" class="headerlink" title="1.1 首页样式"></a>1.1 首页样式</h3><h4 id="管理页主题title"><a href="#管理页主题title" class="headerlink" title="管理页主题title"></a>管理页主题title</h4><p><img src="https://blogres.blackist.org/spring-ar-style-manage-index-header.png"></p><p>在 WEB-INF&#x2F;views&#x2F;main&#x2F;index.jsp 中搜索如下代码，修改此处即可：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;!-- 导航 --&gt;<br>&lt;div class=<span class="hljs-string">&quot;am-topbar-brand&quot;</span>&gt;<br>    &lt;strong&gt;信电校友录&lt;/strong&gt;<br>    &lt;small&gt;后台管理&lt;/small&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h4 id="页脚"><a href="#页脚" class="headerlink" title="页脚"></a>页脚</h4><p><img src="https://blogres.blackist.org/spring-ar-style-manage-index-footer.png"></p><p>在 WEB-INF&#x2F;views&#x2F;global&#x2F;footer.jsp 中修改即可：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;footer&gt;<br>&lt;hr&gt;<br>&lt;p class=<span class="hljs-string">&quot;am-padding-left&quot;</span>&gt;<br>CopyRight © <span class="hljs-number">2015</span> . &lt;a href=<span class="hljs-string">&quot;#&quot;</span> target=<span class="hljs-string">&quot;_blank&quot;</span>&gt;徐州工程学院信电学院&lt;/a&gt;<br>&lt;/p&gt;<br>&lt;/footer&gt;<br></code></pre></td></tr></table></figure><h4 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h4><p><img src="https://blogres.blackist.org/spring-ar-style-manage-index-sidebar.png"></p><p>在 WEB-INF&#x2F;views&#x2F;global&#x2F;sidebar.jsp 中修改即可：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;!-- 公告 bookmark --&gt;<br>&lt;div class=<span class="hljs-string">&quot;am-panel am-panel-default admin-sidebar-panel&quot;</span>&gt;<br>    &lt;div class=<span class="hljs-string">&quot;am-panel-bd&quot;</span>&gt;<br>        &lt;p&gt;<br>            &lt;span class=<span class="hljs-string">&quot;am-icon-bookmark&quot;</span>&gt;&lt;/span&gt; 公告<br>        &lt;/p&gt;<br>        &lt;p&gt;时光静好，与君语；细水流年，与君同。—— 信电校友录&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;<br><br><br>&lt;!-- 社群 wiki --&gt;<br>&lt;div class=<span class="hljs-string">&quot;am-panel am-panel-default admin-sidebar-panel&quot;</span>&gt;<br>    &lt;div class=<span class="hljs-string">&quot;am-panel-bd&quot;</span>&gt;<br>        &lt;p&gt;<br>            &lt;span class=<span class="hljs-string">&quot;am-icon-tag&quot;</span>&gt;&lt;/span&gt; 社群<br>        &lt;/p&gt;<br>        &lt;p&gt;欢迎来到信电校友录后台管理!&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h3 id="1-2-表单样式等"><a href="#1-2-表单样式等" class="headerlink" title="1.2 表单样式等"></a>1.2 表单样式等</h3><p>后台管理网站整站风格参考一套AmazeUI素材，素材存在 ar\ar-tools\model-admin\ 下，</p><p><img src="https://blogres.blackist.org/spring-ar-style-manage-amazeui.png"></p><p><img src="https://blogres.blackist.org/spring-ar-style-manage-amazeui-form.png"></p><p>按钮等组件样式可参考<a href="http://amazeui.org/">Amaze官网</a>：</p><p><img src="https://blogres.blackist.org/spring-ar-style-manage-amazeui-website.png"></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaweb</tag>
      
      <tag>开源</tag>
      
      <tag>校友录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android测试-Monkey Test</title>
    <link href="/2019-03-13-android-test-monkey-test/"/>
    <url>/2019-03-13-android-test-monkey-test/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>APP开发过程中，开人员往往自己做一些功能测试和稳定性测试，使用MonkeyTest做<strong>压力测试</strong>是常用方法，及时修复ANR、CRASH提高项目组整体的开发效率。</p><span id="more"></span><h2 id="一、Monkey简介"><a href="#一、Monkey简介" class="headerlink" title="一、Monkey简介"></a>一、Monkey简介</h2><p>Monkey是一种命令行工具，向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，这个工具存在于Android系统&#x2F;system&#x2F;framework&#x2F;monkey.jar，Android设备&#x2F;模拟器连接到PC后通过adb shell使用此工具，monkey测试流程如下。</p><p><img src="https://blogres.blackist.org/android-test-monkey-framework.png" alt="monkey架构"></p><p>因此两种方式使用monkey，第一种在PC端直接运行命令行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">adb shell monkey --[params]<br></code></pre></td></tr></table></figure><p>第二种进入shell中使用：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">adb shell<br><br>&gt; shell@android: monkey --[params]<br></code></pre></td></tr></table></figure><h2 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h2><p>使用如下命令进行monkey测试：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">adb shell monkey -p org.blackist.modulize --throttle <span class="hljs-number">100</span> -v -v <span class="hljs-number">100</span> &gt; test.log<br><br></code></pre></td></tr></table></figure><ul><li>-p org.blackist.modulize：测试包名为org.blackist.modulize</li><li>–throttle 100：每100ms发送一次事件</li><li>-v -v：指定日志级别</li><li>&gt; test.log：输出日志到文件</li></ul><p>如下是monkey日志中测试到的ANR和CRASH：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs awk">Sleeping <span class="hljs-keyword">for</span> <span class="hljs-number">100</span> milliseconds<br>:Sending Key (ACTION_DOWN): <span class="hljs-number">23</span>    <span class="hljs-regexp">//</span> KEYCODE_DPAD_CENTER<br><span class="hljs-regexp">//</span> CRASH: cn.edu.zstu.sdmp (pid <span class="hljs-number">17698</span>)<br><span class="hljs-regexp">//</span> Short Msg: java.lang.NullPointerException<br><span class="hljs-regexp">//</span> Long Msg: java.lang.NullPointerException: Attempt to invoke virtual method <span class="hljs-string">&#x27;com.wuhenzhizao.titlebar.widget.CommonTitleBar cn.edu.zstu.sdmp.manage.view.ManageActivity.getCommonTitle()&#x27;</span> on a null object reference<br><span class="hljs-regexp">//</span> Build Label: vivo<span class="hljs-regexp">/PD1603/</span>PD1603:<span class="hljs-number">5.1</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/LMY47V/</span>compiler07131528:user/release-keys<br><span class="hljs-regexp">//</span> Build Changelist: eng.compiler.<span class="hljs-number">20180713.152451</span><br><span class="hljs-regexp">//</span> Build Time: <span class="hljs-number">1531466945000</span><br><span class="hljs-regexp">//</span> java.lang.NullPointerException: Attempt to invoke virtual method <span class="hljs-string">&#x27;com.wuhenzhizao.titlebar.widget.CommonTitleBar cn.edu.zstu.sdmp.manage.view.ManageActivity.getCommonTitle()&#x27;</span> on a null object reference<br><span class="hljs-regexp">//</span>      at cn.edu.zstu.sdmp.manage.view.repair.RepairDetailFragment.initView(RepairDetailFragment.java:<span class="hljs-number">153</span>)<br><span class="hljs-regexp">//</span>      at cn.edu.zstu.sdmp.manage.view.repair.RepairDetailFragment.initViewAndData(RepairDetailFragment.java:<span class="hljs-number">113</span>)<br><span class="hljs-regexp">//</span>      at cn.edu.zstu.sdmp.common.base.BaseFragment.onCreateView(BaseFragment.java:<span class="hljs-number">135</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.Fragment.performCreateView(Fragment.java:<span class="hljs-number">2354</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:<span class="hljs-number">1419</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.FragmentManagerImpl.moveFragmentToExpectedState(FragmentManager.java:<span class="hljs-number">1740</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:<span class="hljs-number">1809</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.BackStackRecord.executeOps(BackStackRecord.java:<span class="hljs-number">799</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.FragmentManagerImpl.executeOps(FragmentManager.java:<span class="hljs-number">2580</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.FragmentManagerImpl.executeOpsTogether(FragmentManager.java:<span class="hljs-number">2367</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.FragmentManagerImpl.removeRedundantOperationsAndExecute(FragmentManager.java:<span class="hljs-number">2322</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:<span class="hljs-number">2229</span>)<br><span class="hljs-regexp">//</span>      at android.support.v4.app.FragmentManagerImpl<span class="hljs-variable">$1</span>.run(FragmentManager.java:<span class="hljs-number">700</span>)<br><span class="hljs-regexp">//</span>      at android.os.Handler.handleCallback(Handler.java:<span class="hljs-number">739</span>)<br><span class="hljs-regexp">//</span>      at android.os.Handler.dispatchMessage(Handler.java:<span class="hljs-number">95</span>)<br><span class="hljs-regexp">//</span>      at android.os.Looper.loop(Looper.java:<span class="hljs-number">135</span>)<br><span class="hljs-regexp">//</span>      at android.app.ActivityThread.main(ActivityThread.java:<span class="hljs-number">5418</span>)<br><span class="hljs-regexp">//</span>      at java.lang.reflect.Method.invoke(Native Method)<br><span class="hljs-regexp">//</span>      at java.lang.reflect.Method.invoke(Method.java:<span class="hljs-number">372</span>)<br><span class="hljs-regexp">//</span>      at com.android.internal.os.ZygoteInit<span class="hljs-variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:<span class="hljs-number">1037</span>)<br><span class="hljs-regexp">//</span>      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="hljs-number">832</span>)<br><span class="hljs-regexp">//</span><br><span class="hljs-regexp">//</span> NOT RESPONDING: cn.edu.zstu.sdmp (pid <span class="hljs-number">17698</span>)<br>ANR <span class="hljs-keyword">in</span> cn.edu.zstu.sdmp (cn.edu.zstu.sdmp/.manage.view.ManageActivity)<br>PID: <span class="hljs-number">17698</span><br>Reason: Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: <span class="hljs-number">0</span>.  Wait queue length: <span class="hljs-number">1</span>.)<br><br></code></pre></td></tr></table></figure><p>可以清楚分析出错误所在的地方，所以monkey是个物美价廉的测试工具啊~</p><h2 id="三、参数说明"><a href="#三、参数说明" class="headerlink" title="三、参数说明"></a>三、参数说明</h2><p>monkey工具参数如下（图片<a href="https://www.cnblogs.com/TankXiao/p/4815134.html">来源</a>）：</p><p><img src="https://blogres.blackist.org/android-test-monkey-params.png" alt="monkey参数"></p><h3 id="3-1-基础参数"><a href="#3-1-基础参数" class="headerlink" title="3.1 基础参数"></a>3.1 基础参数</h3><h4 id="p-lt-允许的包名列表-gt"><a href="#p-lt-允许的包名列表-gt" class="headerlink" title="-p &lt;允许的包名列表&gt;"></a>-p &lt;允许的包名列表&gt;</h4><p>用此参数指定一个或多个包。指定包之后，monkey将只允许系统启动指定的app。如果不指定包， monkey将允许系统启动设备中的所有app。  </p><p>指定一个包：adb shell monkey -p org.blackist.modulize 100   </p><p>指定多个包：adb shell monkey -p org.blackist.modulize  –p org.blackist.brouter  100</p><h4 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h4><p>用亍指定反馈信息级别（信息级别就是日志的详细程度），总共分3个级别，分别对应的参数如下： </p><p>Level 0  :  adb shell monkey -p org.blackist.modulize -v 100         &#x2F;&#x2F; 缺省值，仅提供启动提示、测试完成和最终结果等少量信息   </p><p>Level 1  :  adb shell monkey -p org.blackist.modulize -v  -v 100     &#x2F;&#x2F; 提供较为详细的日志，包括每个发送到Activity的事件信息</p><p>Level 2  :  adb shell monkey -p org.blackist.modulize -v  -v  -v 100 &#x2F;&#x2F; 最详细的日志，包括了测试中选中&#x2F;未选中的Activity信息</p><p>一般来说，使用Level0即可。</p><h4 id="s-随机数种子"><a href="#s-随机数种子" class="headerlink" title="-s  (随机数种子)"></a>-s <seed> (随机数种子)</h4><p>用亍指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。  示例：</p><p>monkey测试1：adb shell monkey -p org.blackist.modulize –s 101 100                </p><p>monkey测试2：adb shell monkey -p org.blackist.modulize –s 101 100 </p><p>这个参数其实比较重要，比如我们只看日志不容易确定错误位置，需要结合monkey的UI测试过程，这时需要执行相同的随机序列复现步骤。</p><h4 id="–throttle-延时ms"><a href="#–throttle-延时ms" class="headerlink" title="–throttle  (延时ms)"></a>–throttle <delay> (延时ms)</h4><p>用亍指定用户操作（即事件）间的时延，单位是毫秒；如果不指定这个参数，monkey会尽可能快地生成和发送消息。 示例：</p><p>adb shell monkey -p org.blackist.modulize –throttle 3000 100   </p><h3 id="3-2-发送的事件类型"><a href="#3-2-发送的事件类型" class="headerlink" title="3.2 发送的事件类型"></a>3.2 发送的事件类型</h3><p>–pct-touch <percent> （点击事件）</p><p>参数percent为此事件的百分比，比如要求monkey完成10次点击事件：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adb shell monkey -<span class="hljs-selector-tag">p</span> org<span class="hljs-selector-class">.blackist</span><span class="hljs-selector-class">.modulize</span> -v <span class="hljs-attr">--pct-touch</span> <span class="hljs-number">100</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>可以看到如下日志，Event percentages是事件百分比，点击事件100%，其余都是0：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmd">:Monkey: seed=<span class="hljs-number">1552849997195</span> count=<span class="hljs-number">10</span><br>:AllowPackage: cn.edu.zstu.sdmp<br>:IncludeCategory: android.intent.category.LAUNCHER<br>:IncludeCategory: android.intent.category.MONKEY<br>// Event percentages:<br>//   <span class="hljs-number">0</span>: <span class="hljs-number">100</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">1</span>: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">2</span>: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">3</span>: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">4</span>: -<span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">5</span>: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">6</span>: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">7</span>: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">8</span>: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">9</span>: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>//   <span class="hljs-number">10</span>: <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%<br>:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=<span class="hljs-number">0</span>x10200000;component=cn.edu.zstu.sdmp/.main.view.SplashActivity;end<br>    // Allowing <span class="hljs-built_in">start</span> of Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=cn.edu.zstu.sdmp/.main.view.SplashActivity &#125; <span class="hljs-keyword">in</span> package cn.edu.zstu.sdmp<br></code></pre></td></tr></table></figure><p>–pct-motion <percent> （动作事件）</p><p>–pct-trackball <percent> （轨迹球事件）</p><p>–pct-nav <percent> （基本导航事件，输入设备的上、下、左、右）</p><p>–pct-majornav <percent> （主要导航事件，兼容中间键，返回键，菜单按键）</p><p>–pct-syskeys <percent> （系统导航事件，HOME、BACK及拨号音量键）</p><p>–pct-appswitch <percent> （启动App事件）</p><p>–pct-anyevent <percnet> (不常用事件)</p><p>–ignore-crashes （忽略崩溃事件 CRASH）</p><p>–ignore-timeouts （忽略超时事件 ANR）</p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>monkey test 执行后分析保存的日志，可以搜索CRASH、ANR、Exception等关键字查看错误信息，详细的日志分析参考<a href="http://www.cnblogs.com/wfh1988/archive/2010/11/16/1878224.html">http://www.cnblogs.com/wfh1988/archive/2010/11/16/1878224.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yuti.site/2019/03/02/MonkeyTesting/?tdsourcetag=s_pctim_aiomsg">https://yuti.site/2019/03/02/MonkeyTesting/?tdsourcetag=s_pctim_aiomsg</a></p><p><a href="https://www.cnblogs.com/TankXiao/p/4815134.html">https://www.cnblogs.com/TankXiao/p/4815134.html</a></p><p><a href="https://blog.csdn.net/gzh0222/article/details/6631988">https://blog.csdn.net/gzh0222/article/details/6631988</a></p><p><a href="https://blog.csdn.net/viewsky11/article/details/53889143">https://blog.csdn.net/viewsky11/article/details/53889143</a></p><p><a href="https://www.cnblogs.com/TankXiao/p/4815134.html">https://www.cnblogs.com/TankXiao/p/4815134.html</a></p><p><a href="https://blog.csdn.net/MTbaby/article/details/78792215">https://blog.csdn.net/MTbaby/article/details/78792215</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>测试</tag>
      
      <tag>monkey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>校友录-项目线上部署</title>
    <link href="/2019-03-09-javaweb-ar-deploy-path/"/>
    <url>/2019-03-09-javaweb-ar-deploy-path/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/blackist/ar">校友录</a>作为一个具备门户网站服务、后台管理功能的完整项目，可以部署上线使用，线上部署需要注意些事项，本文就笔者的开发过程做个记录。</p><span id="more"></span><h2 id="一、项目编译"><a href="#一、项目编译" class="headerlink" title="一、项目编译"></a>一、项目编译</h2><p>校友录是基于maven构建的多模块项目，ar-parent是父模块，ar-common、ar-manage、ar-portal是子模块，ar-common中主要存放一些实体类、与数据库交互的Mapper文件以及一些基类和工具类，ar-manage、ar-portal皆依赖ar-common，在编译时需要首先编译ar-common并安装到本地，但其实编辑顺序maven可以自行判断，我们只需要执行编译命令即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">├─<span class="hljs-keyword">ar</span>-parent<br>   ├─<span class="hljs-keyword">ar</span>-common<br>   ├─<span class="hljs-keyword">ar</span>-manage<br>   └─<span class="hljs-keyword">ar</span>-portal<br><br></code></pre></td></tr></table></figure><p>校友录项目配置了maven编译插件<strong>maven-war-plugin</strong>，推荐在本地编译项目不建议在服务器构建，项目将以war包的形式部署到tomcat，在ar-parent目录下执行编译命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mvn clean &amp;&amp; mvn install &amp;&amp; mvn package<br><br></code></pre></td></tr></table></figure><p>编译完成后可看到如下日志：</p><p><img src="https://blogres.blackist.org/spring-ar-deploy-path-compile-ok.png" alt="校友录构建"></p><p>构建好的ar-portal.war在ar-parent&#x2F;ar-portal&#x2F;target&#x2F;目录下。</p><h2 id="二、服务器配置"><a href="#二、服务器配置" class="headerlink" title="二、服务器配置"></a>二、服务器配置</h2><p>本文以服务器Ubuntu16.04，JDK1.8，Tomcat8.5为例</p><h3 id="2-1-安装JDK1-8"><a href="#2-1-安装JDK1-8" class="headerlink" title="2.1 安装JDK1.8"></a>2.1 安装JDK1.8</h3><p>添加Oracle的PPA(Personal Package Archive)，</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span>ppa:webupd8team/java<br><br></code></pre></td></tr></table></figure><p>添加完成后依次执行如下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install oracle-java8-installer<br><br></code></pre></td></tr></table></figure><p>安装成功后验证下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">javac -<span class="hljs-built_in">version</span><br><br></code></pre></td></tr></table></figure><p>设置java的环境变量：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>environment<br></code></pre></td></tr></table></figure><p>文件末尾添加如下内容（替换自己的java路径）：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">JAVA_HOME</span>=<span class="hljs-string">&quot;/usr/lib/jvm/java-8-oracle&quot;</span><br></code></pre></td></tr></table></figure><p>最后重载环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/environment<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$JAVA_HOME</span><br></code></pre></td></tr></table></figure><h3 id="2-2-安装tomcat"><a href="#2-2-安装tomcat" class="headerlink" title="2.2 安装tomcat"></a>2.2 安装tomcat</h3><p>下载<a href="http://apache.cs.utah.edu/tomcat/tomcat-8/v8.5.38/bin/apache-tomcat-8.5.38-fulldocs.tar.gz">Tomcat8.5</a>至服务器，建议放在 &#x2F;opt&#x2F; 目录下解压缩即可。</p><p>tomcat默认使用8080端口，可在conf&#x2F;server.xml中配置端口，</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;Connector executor<span class="hljs-operator">=</span><span class="hljs-string">&quot;tomcatThreadPool&quot;</span><br>   port<span class="hljs-operator">=</span><span class="hljs-string">&quot;8080&quot;</span> protocol<span class="hljs-operator">=</span><span class="hljs-string">&quot;HTTP/1.1&quot;</span><br>   connectionTimeout<span class="hljs-operator">=</span><span class="hljs-string">&quot;20000&quot;</span><br>   redirectPort<span class="hljs-operator">=</span><span class="hljs-string">&quot;8443&quot;</span> /&gt;<br><br></code></pre></td></tr></table></figure><h3 id="2-3-安装MySQL5-1数据库"><a href="#2-3-安装MySQL5-1数据库" class="headerlink" title="2.3 安装MySQL5.1数据库"></a>2.3 安装MySQL5.1数据库</h3><p>安装MySQL5.1数据库，使用可视化<a href="https://blogres.blackist.org/spring-ar-deploy-path-NavicatPro.zip">客户端Navicat等</a>新建ar数据库，编码utf-t，导入数据库表结构ar-mysql-data.sql。</p><p>如果数据库用户名密码和项目中<strong>ar-parent\ar-portal\src\main\resources\config.properties</strong>中不一致，则修改项目配置并重新编译上传服务器。</p><p><img src="https://blogres.blackist.org/spring-ar-deploy-path-mysql-config.png" alt="校友录数据库"></p><h2 id="三、应用发布"><a href="#三、应用发布" class="headerlink" title="三、应用发布"></a>三、应用发布</h2><h3 id="3-1-war包发布"><a href="#3-1-war包发布" class="headerlink" title="3.1 war包发布"></a>3.1 war包发布</h3><p>war放在tomcat的webapps&#x2F;目录下，执行tomcat&#x2F;bin&#x2F;下的.&#x2F;startup.sh，tomcat即可启动。</p><p>启动过程中可能出现异常，此时可监听tomcat日志，在tomcat&#x2F;logs&#x2F;下执行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">tail -f catalina.<span class="hljs-keyword">out</span><br><br></code></pre></td></tr></table></figure><p>监听到如下日志，说明项目启动成功：</p><p><img src="https://blogres.blackist.org/spring-ar-deploy-path-project-init.png" alt="校友录启动"></p><h3 id="3-2-静态资源路径"><a href="#3-2-静态资源路径" class="headerlink" title="3.2 静态资源路径"></a>3.2 静态资源路径</h3><p>笔者最初开发的时候，jsp页面中采用如下配置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;%<br><span class="hljs-regexp">//</span> 获取ar-portal<br>String path = request.getContextPath();<br><span class="hljs-regexp">//</span> 获取 http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span>/<br>String basePath = request.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + request.getServerName() + <span class="hljs-string">&quot;:&quot;</span> + request.getServerPort()<br>+ path + <span class="hljs-string">&quot;/&quot;</span>;<br>%&gt;<br><br>&lt;base href=<span class="hljs-string">&quot;&lt;%=basePath%&gt;&quot;</span>&gt;<br><br></code></pre></td></tr></table></figure><p>如此，页面中的静态资源文件、a标签超链接和Form的action都以<a href="">http://localhost:8080/ar-portal/</a>作为基础路径，在本地开发没有任何个问题，当部署到服务器时网站界面一篇空白，我的大脑一阵抽搐，知道肯定是路径出了问题。</p><p>经过排查就是这个basePath引起的，部署到公网服务器资源路径应该是<a href="">http:&#x2F;&#x2F;公网ip:8080&#x2F;ar-portal&#x2F;</a>，可界面中静态资源等的路径依然是localhost…</p><p>解决路径问题较好的实践是在路径前加入项目环境路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/jpg&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;assets/images/logo/title-logo.jpg&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 静态资源路径加入Spring的环境路径 $&#123;pageContext.request.contextPath&#125; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/jpg&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/assets/images/logo/title-logo.jpg&quot;</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;ta/show.action?userId=$&#123;member.userId&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;min-height: 125px;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;$&#123;member.portrait&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-responsive center-block&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;max-height: 125px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        $&#123;member.trueName&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/jpg&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;assets/images/logo/title-logo.jpg&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- a标签超链接加入Spring的环境路径 $&#123;pageContext.request.contextPath&#125; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/ta/show.action?userId=$&#123;member.userId&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;min-height: 125px;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;$&#123;member.portrait&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-responsive center-block&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;max-height: 125px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        $&#123;member.trueName&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="3-3-js中处理环境路径"><a href="#3-3-js中处理环境路径" class="headerlink" title="3.3 js中处理环境路径"></a>3.3 js中处理环境路径</h3><p>独立的js文件无法通过 ${pageContext.request.contextPath} 获取环境路径，可以通过location获取contextPath，如下getContextPath()可放在全局js中，这样在任意文件中都可以调用此方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取 contextPath</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getContextPath</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> pathName = <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>;<br>    <span class="hljs-keyword">var</span> index = pathName.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>    <span class="hljs-keyword">var</span> result = pathName.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br>$.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;classroom/joinClass.action&#x27;</span>, &#123;<br><span class="hljs-string">&quot;userId&quot;</span> : userId,<br><span class="hljs-string">&quot;classId&quot;</span> : classId<br>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();<br>&#125;);<br><span class="hljs-comment">// 在ajax的url中加入环境路径</span><br>$.<span class="hljs-title function_">post</span>(<span class="hljs-title function_">getContextPath</span>() + <span class="hljs-string">&#x27;/classroom/joinClass.action&#x27;</span>, &#123;<br><span class="hljs-string">&quot;userId&quot;</span> : userId,<br><span class="hljs-string">&quot;classId&quot;</span> : classId<br>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>整个项目jsp、js的路径翻修一通，那可真是酸爽。</p><h2 id="四、Nginx域名解析"><a href="#四、Nginx域名解析" class="headerlink" title="四、Nginx域名解析"></a>四、Nginx域名解析</h2><p>自行安装nginx软件，域名商控制台设置域名解析到服务器ip，在&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;下新建配置文件，文件名任意以.conf结尾即可，如tomcat.conf，配置文件中添加如下内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">server_name</span> tomcat.blackist.top;<br>        <span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>;<br>        <br>        <span class="hljs-section">location</span> / &#123;<br>                <span class="hljs-attribute">proxy_pass</span> http://localhost:8080;<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>即当通过域名访问时，访问被代理到本地tomcat的localhost:8080服务，通过域名<a href="http://tomcat.blackist.top/ar-portal/index.action">http://tomcat.blackist.top/ar-portal</a>即可访问到部署在服务器上的Web应用。</p><hr><p>项目地址：<a href="https://github.com/blackist/ar">https://github.com/blackist/ar</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaweb</tag>
      
      <tag>开源</tag>
      
      <tag>校友录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弱网测试环境搭建</title>
    <link href="/2019-02-28-dev-network-weak-network-env/"/>
    <url>/2019-02-28-dev-network-weak-network-env/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Web应用、App应用测试中需要进行弱网测试，测试网络不稳定时应用做出的反应和提示是否友好、无歧义。通常情况下不稳定的网络环境使用工具来模拟，本文通过Fiddler设置网络规则限制应用的网络请求时间，达到弱网测试的目的。</p><span id="more"></span><h2 id="一、弱网环境搭建"><a href="#一、弱网环境搭建" class="headerlink" title="一、弱网环境搭建"></a>一、弱网环境搭建</h2><p>在windows操作系统中，下载解压<a href="https://blogres.blackist.org/dev-network-Fiddler.rar">Fiddler</a>(中文版，可到<a href="https://www.telerik.com/fiddler">官网</a>安装最新原版)，打开软件主界面。</p><p><img src="https://blogres.blackist.org/dev-network-weak-fiddler-main.png"></p><h3 id="设置网络规则"><a href="#设置网络规则" class="headerlink" title="设置网络规则"></a>设置网络规则</h3><p>选项 Rule(规则)-&gt;Custom Rule(自定义规则)，弹出规则编辑器Fiddler Script编辑器，</p><p><img src="https://blogres.blackist.org/dev-network-weak-fiddler-main-script.png"></p><p>在编辑器中寻找如下代码段(Ctrl+F寻找关键字 m_SimulateModem)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (m_SimulateModem) &#123;<br>    <span class="hljs-comment">// Delay sends by 300ms per KB uploaded.</span><br>    oSession[<span class="hljs-string">&quot;request-trickle-delay&quot;</span>] = <span class="hljs-string">&quot;300&quot;</span>; <br>    <span class="hljs-comment">// Delay receives by 150ms per KB downloaded.</span><br>    oSession[<span class="hljs-string">&quot;response-trickle-delay&quot;</span>] = <span class="hljs-string">&quot;150&quot;</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>顾名思义，”request-trickle-delay”表示网络请求延时，”response-trickle-delay”表示网络响应延时，单位是毫秒(ms)。规则进行如下设置并保存，则网络请求延时3秒，网络响应延时3.5秒。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (m_SimulateModem) &#123;<br>    <span class="hljs-comment">// Delay sends by 300ms per KB uploaded.</span><br>    oSession[<span class="hljs-string">&quot;request-trickle-delay&quot;</span>] = <span class="hljs-string">&quot;3000&quot;</span>; <br>    <span class="hljs-comment">// Delay receives by 150ms per KB downloaded.</span><br>    oSession[<span class="hljs-string">&quot;response-trickle-delay&quot;</span>] = <span class="hljs-string">&quot;3500&quot;</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="应用网络限制"><a href="#应用网络限制" class="headerlink" title="应用网络限制"></a>应用网络限制</h3><p>修改并保存规则后，需要应用到系统中，选项 Rule(规则)-&gt;Performance(性能)-&gt;选中Simulate Modems Speeds(模拟调制解调器速度)，即可开启网络延迟</p><h3 id="扩展网络规则"><a href="#扩展网络规则" class="headerlink" title="扩展网络规则"></a>扩展网络规则</h3><p>设置固定的网络延时会使网络一直处于虚弱的环境，时好时坏的网络更贴近实际网络，修改规则可实现动态变化的网络环境：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 随机整数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">randInt</span>(<span class="hljs-params">min, max</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*(max-min)+min);<br>&#125;<br><br><span class="hljs-keyword">if</span> (m_SimulateModem) &#123;<br>    <span class="hljs-comment">// Delay sends by 300ms per KB uploaded.</span><br>    oSession[<span class="hljs-string">&quot;request-trickle-delay&quot;</span>] = <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-title function_">randInt</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6000</span>); <br>    <span class="hljs-comment">// Delay receives by 150ms per KB downloaded.</span><br>    oSession[<span class="hljs-string">&quot;response-trickle-delay&quot;</span>] = <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-title function_">randInt</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3000</span>); <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Web应用弱网环境测试"><a href="#Web应用弱网环境测试" class="headerlink" title="Web应用弱网环境测试"></a>Web应用弱网环境测试</h2><p>基于以上搭建的PC端弱网环境，在本机通过浏览器等访问Web应用即可实现弱网环境测试。</p><p><img src="https://blogres.blackist.org/dev-network-weak-fiddler-console-web.png"></p><h2 id="移动应用弱网环境测试"><a href="#移动应用弱网环境测试" class="headerlink" title="移动应用弱网环境测试"></a>移动应用弱网环境测试</h2><p>移动端进行弱网测试时，iPhone可通过系统设置实现弱网环境，但移动设备一般通过PC端配置弱网环境，移动端与PC处于同一网段并设置网络代理，由PC端控制移动端的网络环境。</p><h3 id="Fiddler设置远程连接"><a href="#Fiddler设置远程连接" class="headerlink" title="Fiddler设置远程连接"></a>Fiddler设置远程连接</h3><p>基于以上Fiddler配置，接着Tools(工具)-&gt;选项(Options)-&gt;Connection(连接)，配置如下：</p><p><img src="https://blogres.blackist.org/dev-network-weak-fiddler-remote-connection.png"></p><h3 id="安卓设备设置代理"><a href="#安卓设备设置代理" class="headerlink" title="安卓设备设置代理"></a>安卓设备设置代理</h3><p>在连接的wifi界面中，设置手动代理，填写PC端代理的的ip和端口号，配置完成后安卓设备上的所有网络请求都被代理到Fiddler。</p><p><img src="https://blogres.blackist.org/dev-network-weak-android-proxy.jpg"></p><p>ip通过PC端命令ipconfig查看:</p><p><img src="https://blogres.blackist.org/dev-network-weak-proxy-ip.png"></p><p>若PC连接wifi，则选择WLAN适配器的ip。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u010618194/article/details/76652513">https://blog.csdn.net/u010618194/article/details/76652513</a><br><a href="https://www.jianshu.com/p/c0b5ec817617">https://www.jianshu.com/p/c0b5ec817617</a><br><a href="http://insights.thoughtworkers.org/mobile-testing-traps/">http://insights.thoughtworkers.org/mobile-testing-traps/</a><br><a href="https://www.jianshu.com/p/728a993329b2?tdsourcetag=s_pctim_aiomsg">https://www.jianshu.com/p/728a993329b2?tdsourcetag=s_pctim_aiomsg</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何为你的代码选择一个开源协议</title>
    <link href="/2019-01-18-public-open-source-license/"/>
    <url>/2019-01-18-public-open-source-license/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相信很多刚踏入软件这个行业的小伙伴一如当初的我，对开源软件的各种协议不甚了解被搞昏了头脑。毕竟对于一个新生程序员来说，如何写好代码才是亟待解决的问题，无暇了解这些。随着你项目做得多了代码写得多了，你会发现编码过程中会不时用到其他人的成果，一个项目下来多少会引入一些优秀的库，别人放在公网上开源的DLL，以及一些算法等等。细心的你会注意到即使只是一小段代码，优秀的作者都在最开始会简单地附上一段关于许可的声明，或者说是协议比如”Licensed under the MIT license”，并且一些博客也会标明”此文章发表在CC协议下”。而如果我们Copy了别人的代码或者文字同时没注意这些的话，在国外法律意识特别强的环境下，我们的作品会因触犯别人的权益而违法。因为好多开源协议最低要求是使用者需要保留原作者对代码的声明，不声不响地就拿来用了必然导致恶果。</p><p>所以开源不等于免费，开源也不等于没有约束。</p><span id="more"></span><h2 id="一、何为License"><a href="#一、何为License" class="headerlink" title="一、何为License"></a>一、何为License</h2><p>License是软件的授权许可，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。软件协议可分为开源和商业。当然本文要讨论的当然是开源协议。</p><p>对于商业协议，或者叫法律声明、许可协议，每个软件会有自己的一套行文，由软件作者或专门律师撰写。这是什么惊为天人的东西嘛还得请专门的律师。因为涉及到以后侵权打官司这种事情，这种商业条款的行文是非常严谨而讲究的，记得以前看到句调侃的话：’如果法律文件不写得那么生涩难懂，律师们就没饭吃了’，就是说任何文字一旦上升到法律的层次，不要说你接受完了九年义务教育，就是考了个专八也会觉得英语白学了，直接的法律协议什么的那不是给常人看的。而至于法律条款缘何会晦涩难懂，这个偏题有点偏远了，可以查看<a href="https://rararizal.wordpress.com/2011/12/04/why-is-the-legal-language-so-hard-to-understand-part-1/">这里</a>了解。看累了？下面是欢乐时刻，奉上一个协议相关的Joke（<a href="http://news.mydrivers.com/1/277/277017.htm">笑崩！苹果iOS7升级协议条款中员工神吐槽</a>）。</p><p>所以对于大多数人来说，不用自己花大把时间去写许可协议，选择一分广为流传的开源协议是个不错的选择，如果你的作品是开源的话，这样省时又省心。</p><h2 id="二、选择一分协议的好处"><a href="#二、选择一分协议的好处" class="headerlink" title="二、选择一分协议的好处"></a>二、选择一分协议的好处</h2><p>你的作品如果不是定性为全商业性质，可以考虑选择一分流行度比较高的开源协议。具体来说的话，你肯定希望作品能够被多数人分享查阅吧，不但提高自己业界的知名度，同时也方便了需要的人为开源做出了贡献。换句话说，你不分享出来的话你的作品的意义何在呢（当然，自己捣腾的私人东西还是自己保留吧）？可是一旦你把你的代码贴出来，这就表示任何人都可以看到并获取，之后发生的事情你无法控制，有的人或许稍微修改一下放进自己的代码中，有的把你的软件改个名字拿去贩卖，有的甚至会拿去把作者名字改为自己然后拿去找工作什么的，而不会有人知道这个作品的原作者，背后辛勤付出了的人。所以为了公开分享你的代码，同时又让你对代码保留一定权利，在作品中声明一个许可协议是非常有必要的，这是很多新人所忽略的问题，同时很多人在使用别人的劳动成果时也会忽视协议的存在，这样不好。所以你会看到我的博客里面时不时会给出连接指向来源页面，同时文末也会列出所有参考过的文章。我相信我做到了这点，别人在转载我的文章的时候，也可以做到这点，这样营造出来的氛围一定会非常和谐，互相尊重&#x2F;Show Respect。</p><p>多说一句，一个事实让你了解国外开发者在尊重他人劳动成果方面做得是如何的到位，如果A的作品是因为B的作品的启发而来，A甚至都没有使用B任何一句代码，但A会在他的作品里面指明是受到了B的启发”Inspired by XXX link :<a href="http://www.blah.com&quot;./">http://www.blah.com&quot;。</a></p><p>当然有人会觉得，有了一分协议声明在那里，我就需要鸟你么，我拿来用了把作者名字去掉同时还要加上我的名字，你咬我？！这是后话，只是在利益很小的情况下，或者作者不知情的情况下，作者不会追究什么责任，但如果你的产品做成功了，那就不一定了。另外就是，有协议和没声明协议的裸代码是有非常重要区别的，一般作品当中没声明协议的默认为Copy right的，也就是版权保留。此种情况表明他人没有任何授权，不得复制分发修改使用等等，但一如上面所讨论的，这样的话还何来开源，何来分享呢。有了协议的声明，在未来你的维权上面会方便很多，让你的作品在分享的同时保留了自身的一些权利。</p><h2 id="三、快速选择"><a href="#三、快速选择" class="headerlink" title="三、快速选择"></a>三、快速选择</h2><p>目前流行的开源协议有很多，并且同一款协议有很多变种，比如你或许看到过’ CC Attribution-NoDerivs’,’ CC Attribution-NonCommercial’同属CC协议（后面会有介绍）。如此纷繁的协议该如何选择？协议太宽松会导致作者丧失对作品的很多权利，太严格又不便于使用者使用及作品的传播。所以除了协议多之外，你还要考虑你对作品想保留哪些权利，放开哪些限制。</p><p>如果你不想了解太多，只是想要一个简直直接的答案，下面给出的建议或许适合你。下方关于协议的选择及表格来自GitHub <a href="https://choosealicense.com/">choosealicence</a>项目。</p><h3 id="3-1-简单宽松的协议"><a href="#3-1-简单宽松的协议" class="headerlink" title="3.1 简单宽松的协议"></a>3.1 简单宽松的协议</h3><p>如果你只想要一个简单点的协议不想太麻烦的话。</p><p><a href="https://choosealicense.com/licenses/mit/">MIT协议</a>相对宽松但还是抓住了要点的。此协议允许别人以任何方式使用你的代码同时署名原作者，但原作者不承担代码使用后的风险，当然也没有技术支持的义务。jQuery和Rails就是MIT协议。</p><h3 id="3-2-考虑有专利的情况"><a href="#3-2-考虑有专利的情况" class="headerlink" title="3.2 考虑有专利的情况"></a>3.2 考虑有专利的情况</h3><p>如果你的作品中涉及到专利相关。</p><p><a href="https://choosealicense.com/licenses/apache-2.0/">Apache协议</a>也是个相对宽松与MIT类似的协议，但它简单指明了作品归属者对用户专利上的一些授权（我的理解是软件作品中含有专利，但它授权你可以免费使用）。Apache服务器，SVN还有NuGet等是使用的Apache协议。</p><h3 id="3-3-代码分享与促进"><a href="#3-3-代码分享与促进" class="headerlink" title="3.3 代码分享与促进"></a>3.3 代码分享与促进</h3><p>如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。</p><p>GPL（<a href="https://choosealicense.com/licenses/gpl-2.0/">V2</a>或<a href="https://choosealicense.com/licenses/gpl-3.0/">V3</a>）是一种版本自由的协议（可以参照copy right来理解，后者是版本保留，那copyleft便是版权自由，或者无版权，但无版权不代表你可以不遵守软件中声明的协议）。此协议要求代码分发者或者以此代码为基础开发出来的衍生作品需要以同样的协议来发布。此协议的版本3与版本2相近，只是多3中加了条对于不支持修改后代码运行的硬件的限制（没太明白此句话的内涵）。</p><h3 id="四、各协议授权详情"><a href="#四、各协议授权详情" class="headerlink" title="四、各协议授权详情"></a>四、各协议授权详情</h3><p>下面是更多开源协议的一个表格任君选择，总有一款是你的菜。</p><p>不过先来了解一些下方表格中出现的用词的解释：</p><ul><li>协议和版权信息(License and copyright notice)：在代码中保留作者提供的协议和版权信息</li><li>声明变更(State Changes)：在代码中声明对原来代码的重大修改及变更</li><li>公开源码(Disclose Source)：代码必需公开。如果是基于LGPL协议 下，则只需使用的开源代码公开，不必将整个软件源码公开</li><li>库引用(Library usage)：该库可以用于商业软件中</li><li>责任承担(Hold Liable)：代码的作者承担代码使用后的风险及产生的后果</li><li>商标使用(Use Trademark)：可以使用作者的姓名，作品的Logo，或商标</li><li>附加协议(Sublicensing)：允许在软件分发传播过程中附加上原来没有的协议条款等</li></ul><p><img src="https://blogres.blackist.org/public-open-source-license-how_to_choose_a_license.html.png" alt="开源协议"></p><p>最流行的六种—-<a href="https://choosealicense.com/licenses/gpl-2.0/">GPL</a>、<a href="https://choosealicense.com/licenses/bsd-2-clause/">BSD</a>、<a href="https://choosealicense.com/licenses/mit/">MIT</a>、<a href="https://choosealicense.com/licenses/mpl-2.0/">Mozilla</a>、<a href="https://choosealicense.com/licenses/apache-2.0/">Apache</a>和<a href="https://choosealicense.com/licenses/lgpl-2.1/">LGPL</a>，六种许可证之间的最大区别如下图（参考<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">阮一峰文章</a>）：</p><p><img src="https://blogres.blackist.org/public-open-source-license.png" alt="开源协议"></p><h2 id="五、非代码类作品的协议"><a href="#五、非代码类作品的协议" class="headerlink" title="五、非代码类作品的协议"></a>五、非代码类作品的协议</h2><p>上面各协议只是针对软件或代码作品，如果你的作品不是代码，比如视频，音乐，图片，文章等，共享于公众之前，也最好声明一下协议以保证自己的权益不被侵犯。针对非代码的数字作品的协议，最通用的莫过于<a href="https://creativecommons.org/choose/">Creative Commons</a>(也是你经常在别人博客下面可以看到的CC协议)协议。所以现在你见到博客园别人文章下面的签名就不会感到陌生了。</p><h2 id="六、无协议"><a href="#六、无协议" class="headerlink" title="六、无协议"></a>六、无协议</h2><p>你没有义务也没人非要你必需在自己的代码作品里面加上一个开源协议。但一如上文所讨论过的优点，如果你想把代码分享出来，最好还是选择一个适合的开源协议，这样别人用着放心。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>转载自 <a href="http://www.cnblogs.com/Wayou/p/how_to_choose_a_license.html">http://www.cnblogs.com/Wayou/p/how_to_choose_a_license.html</a><br>参考 <a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>公共领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>公共领域</tag>
      
      <tag>开源协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎样挑选合适的安全座椅</title>
    <link href="/2019-01-02-public-how-to-buy-car-seat/"/>
    <url>/2019-01-02-public-how-to-buy-car-seat/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-1-大小"><a href="#1-1-大小" class="headerlink" title="1.1 大小"></a>1.1 大小</h3><p>安全座椅跟衣服和鞋子一样，也分大小和使用年龄的，合适的大小能最好地发挥保护作用。</p><p>按Britax美国的标准，分成以下几种类型：</p><ul><li>婴儿提篮（Infant Car Seats），适用于出生到13公斤</li><li>可变座椅（Convertible Car Seats），适用于出生到32公斤</li><li>增高垫（Booster），适用于11公斤到41公斤</li></ul><span id="more"></span><p>Britax在中国在欧洲和中国分得更细一些，有0+组、0+1组、1组、1+2+3组、2+3组这么多，上面的可变座椅（Convertible Car Seats）其实相当于0+1+2+3组，但中国区没卖的，只能从美国买了运回来。</p><p>其它品牌的，适用体重范围有一点点差别，分组和安全标准都是非常接近的。</p><p>厂商所说的适用范围，是从产品安全性能角度来说的，以婴儿提篮为例，厂家建议的最大体重是13公斤，就是说，14公斤的宝宝，再坐婴儿提篮就已经不安全了，超出了婴儿提篮的承重限制。实际上，根据中国的现实情况，13公斤的小孩基本都有两岁了，让他躺在婴儿提篮中是很难的，小孩自己会要求坐着，而不是躺着。</p><p><strong>选购指南</strong></p><ul><li>如果你的宝宝在2岁以内（或者还在妈妈肚子里），建议购买可变座椅（Convertible Car Seats），如Britax Advocate 70。</li><li>如果你的宝宝已经2岁以上，建议购买增高垫（Booster），如Britax Pinnacle 90。虽然2岁还可以继续坐Advocate 70，但Advocate 70最多只能用到70磅（32公斤），而Pinnacle 90最多能用到90磅（41公斤）</li><li>如果你的宝宝在2岁以内，且预算充足（比方案1多awx 1600-2000元），可以买一个婴儿提篮（Infant Car Seats），和一个1+2+3组的可变座椅（Convertible Car Seats）。婴儿提篮可以让宝宝平躺在提篮里睡觉，到家后，如果宝宝还没睡醒，就把提篮卡扣打开，从汽车座椅上卸下来，直接拎回家，这样就不会打扰宝宝睡觉。</li></ul><h3 id="1-2-汽车接口"><a href="#1-2-汽车接口" class="headerlink" title="1.2 汽车接口"></a>1.2 汽车接口</h3><p>我把汽车接口这个因素放在第二，就是因为这个因素在安全座椅选购当中不是最重要的因素。如果你有耐心阅读下面的文字，又有强迫症一定要汽车和座椅的接口完美匹配，可以把本章读完，涨涨经验。</p><p>如果你没耐心看下面的知识，只要能达到国外法定的安全标准就可以了，那么，买一个功能强大正在促销的就可以了（如本店推荐的Britax Advocate 70），不管你是什么车，都可以用安全带固定它。</p><p>—– 下面开始科普安全座椅接口 —–</p><p>安全座椅分三种固定方式：</p><ul><li>LATCH</li><li>ISOFIX</li><li>安全带</li></ul><p>有的品牌，可能会使用一些自己独创的名词，如标致308，宣传资料说是使用了Tti安全座椅接口，我去车上看过，其实就是LATCH。</p><p>安全座椅接口太专业了，我见过不少网店的卖家错误描述这些概念。例如【洋码头海外旗舰店】：<a href="http://detail.tmall.hk/hk/item.htm?id=21211059448%EF%BC%8C%E4%BB%96%E8%AF%B4%EF%BC%9A%E3%80%90%E6%9C%80%E8%BF%91%E5%87%A0%E5%B9%B4%E7%9A%84%E6%96%B0%E8%BD%A6%E9%83%BD%E4%BC%9A%E6%9C%89%E9%85%8D%E5%A4%87%E5%84%BF%E7%AB%A5%E5%AE%89%E5%85%A8%E5%BA%A7%E6%A4%85ISOFIX%E6%8E%A5%E5%8F%A3%E6%88%96%E8%80%85LATCH%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%8E%A5%E5%8F%A3%E5%85%B6%E5%AE%9E%E9%83%BD%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%8C%E5%9C%A8%E7%BE%8E%E5%9B%BD%E5%8F%AB%E5%81%9ALATCH%EF%BC%8C%E5%9C%A8%E6%AC%A7%E6%B4%B2%E5%8F%AB%E5%81%9AISOFIX%E3%80%91%EF%BC%8C%E5%85%B6%E5%AE%9E%E8%BF%99%E6%98%AF%E5%AE%8C%E5%85%A8%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%B4%E6%B3%95%E3%80%82">http://detail.tmall.hk/hk/item.htm?id=21211059448，他说：【最近几年的新车都会有配备儿童安全座椅ISOFIX接口或者LATCH接口，这两种接口其实都是一样的，在美国叫做LATCH，在欧洲叫做ISOFIX】，其实这是完全不正确的说法。</a></p><h4 id="1-2-1-LATCH接口"><a href="#1-2-1-LATCH接口" class="headerlink" title="1.2.1 LATCH接口"></a>1.2.1 LATCH接口</h4><p>LATCH接口是美国标准，从美国买安全座椅，多半情况会买到这个接口的。</p><p>LATCH是兼容ISOFIX的，如果车是LATCH接口的，买LATCH接口或者ISOFIX接口的座椅都可以。</p><p>它是三个固定锚点，比ISOFIX多一个头部固定点（在后排座椅头枕的后面）。</p><h4 id="1-2-2-ISOFIX接口"><a href="#1-2-2-ISOFIX接口" class="headerlink" title="1.2.2 ISOFIX接口"></a>1.2.2 ISOFIX接口</h4><p>ISOFIX是欧洲标准，如果要买ISOFIX接口的座椅，最好是从德国或者英国买。美国网站也有，但款式少一些，优惠幅度应该也不如欧洲。</p><p>ISOFIX接口的汽车，比LATCH接口的少一个固定锚点，因此网上的官方文章都说，ISOFIX的车不能装LATCH的座椅，但在实践中，也可以在ISOFIX的车上使用LATCH的座椅，这是因为：</p><ul><li>可以直接使用安全带固定法。这是合法和安全的</li><li>把LATCH座椅下面的两个带子固定到汽车的ISOFIX接口上之后，再用安全带固定一遍，双保险</li><li>有人在后备箱里找到了一个锚点，把LATCH座椅头部那根带子拉到后备箱去固定了。相当于自己把ISOFIX的车子改造成LATCH接口了（就是有点山寨）</li></ul><h4 id="1-2-3-安全带固定"><a href="#1-2-3-安全带固定" class="headerlink" title="1.2.3 安全带固定"></a>1.2.3 安全带固定</h4><p>有的车子两种接口都没，只能采用安全带固定。几乎所有的安全座椅都支持安全带固定。</p><p>安全带固定也可以上ISOFIX、LATCH同时使用。比方说，车是LATCH接口，买了Britax Advocate 70安全座椅，就可以把LATCH的三个锚点全部接好，同时安全带也绑到安全座椅上去，这样双保险固定后，固若金汤。我就是这么干的</p><h4 id="1-2-4-怎样知道我的车是什么接口"><a href="#1-2-4-怎样知道我的车是什么接口" class="headerlink" title="1.2.4 怎样知道我的车是什么接口"></a>1.2.4 怎样知道我的车是什么接口</h4><ul><li>最保险的办法是去你汽车的后排座椅上看，找到ISOFIX、LATCH的标志和挂钩</li><li>看你的汽车说明书，但要小心，一款车型会有乞丐版、中配版、顶配版、特别版等等很多个版本，不同版本都是共享同一本说明书的，别看错了。或者打汽车品牌官方客服电话问问，不要找4S店客服。</li><li>到汽车类网站上查询参数配置，这种方法准确度最低。网站的资料，准确度存在一些问题，安全座椅在中国是个冷门的东西，汽车网站没有动力把这个资料做得很准确。我就遇到过，汽车之家说本田思域全系标配LATCH接口，而我爬到朋友的车上看，ISOFIX和LATCH都没有。</li></ul><h3 id="1-3-品牌"><a href="#1-3-品牌" class="headerlink" title="1.3 品牌"></a>1.3 品牌</h3><h4 id="1-3-1-美国市场"><a href="#1-3-1-美国市场" class="headerlink" title="1.3.1 美国市场"></a>1.3.1 美国市场</h4><ul><li>Britax，百代适（又译：宝得适），专注母婴的品牌，英国品牌，线上线下都是排名第一的品牌</li><li>Eddie Bauer，埃迪堡，除了母婴，也做衣服鞋子，安全座椅是它收购来的</li><li>Maxi-Cosi，迈可适，荷兰品牌，线下超市和电商有售</li><li>Graco，葛莱，美国品牌，已在广东东莞生产。其鹦鹉螺3合1，常年139美元，适用于20到100磅，以较高的性价比力压Britax排名amazon销售第一</li></ul><h4 id="1-3-2-欧洲市场"><a href="#1-3-2-欧洲市场" class="headerlink" title="1.3.2 欧洲市场"></a>1.3.2 欧洲市场</h4><ul><li>CONCORD，协和&#x2F;康科德</li><li>RECARO，里卡罗</li><li>STM，斯迪姆</li><li>Kiddy，可迪</li></ul><h2 id="2-海淘费用（适用于美国代购）"><a href="#2-海淘费用（适用于美国代购）" class="headerlink" title="2 海淘费用（适用于美国代购）"></a>2 海淘费用（适用于美国代购）</h2><h3 id="2-1-货款"><a href="#2-1-货款" class="headerlink" title="2.1 货款"></a>2.1 货款</h3><p>货款是通过Master或者Visa在信用卡里扣美元的。所以，货款计算方法是：</p><blockquote><p>美元价格 * 汇率（汇率按1美元&#x3D;6.1人民币计算）</p></blockquote><h4 id="2-1-1-货物价格查询"><a href="#2-1-1-货物价格查询" class="headerlink" title="2.1.1 货物价格查询"></a>2.1.1 货物价格查询</h4><p>货物美元价格自行到美国网站查询，我一般在amazon, albeebaby买，地址：</p><ul><li><a href="http://www.albeebaby.com/">http://www.albeebaby.com/</a></li><li><a href="http://www.amazon.com/">http://www.amazon.com/</a></li></ul><p>要注意，不同花色价格也不同的，特价的时候，通常也不是全部的花色都特价</p><h3 id="2-2-消费税"><a href="#2-2-消费税" class="headerlink" title="2.2 消费税"></a>2.2 消费税</h3><p>消费税跟货款一样，由美国商家通过MasterCard&#x2F;Visa收取，汇率也是6.1</p><h4 id="2-2-1-免税州"><a href="#2-2-1-免税州" class="headerlink" title="2.2.1 免税州"></a>2.2.1 免税州</h4><p>美国有的州是收消费税的，免税州不收。下单时用哪个州的地址，取决于使用哪个转运公司。我买安全座椅用360hitao，买耳温枪、包鞋子等小件就用友家。</p><p>360hitao有三个仓库，分别是：</p><ul><li>CA（加州），Amazon的货发到CA州收税，奶粉、米粉等食品免税。Albeebaby发到CA州不收税</li><li>DE（特拉华州），这个是免税州。无论哪个网站的东西，发到这里都不收税。这个州最近暴风雪天气，又因为黑五海淘的中国人多，已经爆仓不收货了</li><li>OR（俄勒冈州），这个也是免税州。</li></ul><h4 id="2-2-2-税率"><a href="#2-2-2-税率" class="headerlink" title="2.2.2 税率"></a>2.2.2 税率</h4><p>不同类目消费税也不同，安全座椅大约是9.5%-10%，即一个Britax Advocate 70 G3，在Amazon卖235美元，消费税大约是23美元。</p><p>要知道精确的税是多少，到Amazon上下个单，填一个CA州的收货地址，Amazon会自动把税金算出来，单列，并累加到订单总金额中去的。</p><h4 id="2-2-3-如何避免被税"><a href="#2-2-3-如何避免被税" class="headerlink" title="2.2.3 如何避免被税"></a>2.2.3 如何避免被税</h4><ul><li>在Albeebaby买，发到CA、DE、OR三个州都不收税</li></ul><p>等等，为什么不能在amazon买发到免税州？且看下面的转运费部分，海淘真心比淘宝麻烦多了好嘛 -_-!</p><h3 id="2-3-转运费"><a href="#2-3-转运费" class="headerlink" title="2.3 转运费"></a>2.3 转运费</h3><p>从商家到转运公司仓库，一般是免费的（Albeebaby满49美元免运费，安全座椅都不止49美元），如果达不到网站免运费的条件，就凑齐了再下单吧，习惯了国内的快递费，被美国网站收运费，会非常肉痛的。</p><h4 id="2-3-1-美国-中国转运费"><a href="#2-3-1-美国-中国转运费" class="headerlink" title="2.3.1 美国-中国转运费"></a>2.3.1 美国-中国转运费</h4><p>转运公司按磅计费，一磅是454克，0.454公斤，不足一磅按一磅算。</p><p>360hitao的运费价格在这里查询：<br><a href="http://www.360hitao.com/freight-calculate/?pagetype=fc">http://www.360hitao.com/freight-calculate/?pagetype=fc</a></p><p>如Britax Advocate 70的重量大概是26磅，黄金卡运费是854.92元。为什么不是标准运费呢？因为花500就可以买个黄金卡了，一个安全座椅的运费铁定超过500，所以，买个黄金卡，再通过支付宝支付剩下的354.92，就可以享受黄金卡的折扣了，可以省165.8元。</p><h4 id="2-3-2-美国境内转运费"><a href="#2-3-2-美国境内转运费" class="headerlink" title="2.3.2 美国境内转运费"></a>2.3.2 美国境内转运费</h4><p>360hitao在美国虽然有3个仓库，但只有CA（加州）的仓库有直飞中国的航班，所以，如果买安全座椅为了省消费税，收货地址写了DE或者OR州，那么就要再付给360hitao一笔美国境内转运费，价格是1美元1磅。一个安全座椅一般是25磅左右。</p><p>对安全座椅来说，这个美国境内转运费都超过消费税了。所以，不值得发免税州。</p><h4 id="2-3-3-体积费"><a href="#2-3-3-体积费" class="headerlink" title="2.3.3 体积费"></a>2.3.3 体积费</h4><p>这个怎么算的我就不详细说了，我直接告诉你结果：安全座椅按体积运费非常非常不划算。360hitao按重收费，不收体积费，这就是我买选360hitao的原因。</p><h4 id="2-3-4-汇率"><a href="#2-3-4-汇率" class="headerlink" title="2.3.4 汇率"></a>2.3.4 汇率</h4><p>转运公司一般是美元报价（也有的人民币双币报价），收人民币（因为海淘的都是国内网民，支付宝收人民币便宜又方便，用Visa、Paypal的话，转运公司又要付一笔手续费）。</p><p>如果你仔细计算，你会发现，转运公司使用的汇率不是6.1，而是高出一些的，例如360hitao就是6.38，去年是6.5，其它转运公司，6.3， 6.4，6.5的都的，6.1的良心企业暂时还没发现。</p><h3 id="2-4-中国海关关税"><a href="#2-4-中国海关关税" class="headerlink" title="2.4 中国海关关税"></a>2.4 中国海关关税</h3><p>安全座椅体积大，货值高，进关几乎必被征税。<br>税金是126人民币，终于不用算汇率了，哦也！</p><p>从海关出来，换成国内快递公司，这个国内快递公司的运费包含在转运公司的转运费里了，不再额外收费。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/qinjx/30min_guides/blob/master/how_to_buy_car_seat.md">https://github.com/qinjx/30min_guides/blob/master/how_to_buy_car_seat.md</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>公共领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>公共领域</tag>
      
      <tag>个人思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零售行业优惠规则分析</title>
    <link href="/2019-01-02-public-comsumer-promotion-rule/"/>
    <url>/2019-01-02-public-comsumer-promotion-rule/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-优惠规则5要素"><a href="#1-优惠规则5要素" class="headerlink" title="1 优惠规则5要素"></a>1 优惠规则5要素</h2><h3 id="1-1-满足优惠条件的动作"><a href="#1-1-满足优惠条件的动作" class="headerlink" title="1.1 满足优惠条件的动作"></a>1.1 满足优惠条件的动作</h3><p>这个要素，是指触发优惠规则的动作，主要包括买和满两种。</p><p>__注__：</p><ul><li>在数学上，买是满的一种特殊情况，只不过做文本串分析时，要同时考虑到这两种文本描述。</li><li>在电商行业，触发优惠的动作还包括：晒单、微博分享、微信关注、给好评、收藏、新用户注册、手机下单等行为，这里我只叙述与商品和订单相关的，与其它行为（注册、营销、手机下单等）相关的暂忽略。</li><li>抽奖，中奖要看运气，所以这时也暂不讨论</li></ul><span id="more"></span><h4 id="1-1-1-买"><a href="#1-1-1-买" class="headerlink" title="1.1.1 买"></a>1.1.1 买</h4><p>只要买就优惠，如买赠（买1送1）、买立减（买此商品立减5元）</p><h4 id="1-1-2-满"><a href="#1-1-2-满" class="headerlink" title="1.1.2 满"></a>1.1.2 满</h4><p>如满88减18</p><h3 id="1-2-优惠条件作用对象"><a href="#1-2-优惠条件作用对象" class="headerlink" title="1.2 优惠条件作用对象"></a>1.2 优惠条件作用对象</h3><p>这个要素，是指满的对象（上文已解释，买其实是满的一种特殊情况，故此处叙述时合并），满什么条件，主要有三种：</p><h4 id="1-2-1-订单金额（抵扣前金额）"><a href="#1-2-1-订单金额（抵扣前金额）" class="headerlink" title="1.2.1 订单金额（抵扣前金额）"></a>1.2.1 订单金额（抵扣前金额）</h4><p>如满88元减18元</p><h4 id="1-2-2-实付金额（抵扣后金额）"><a href="#1-2-2-实付金额（抵扣后金额）" class="headerlink" title="1.2.2 实付金额（抵扣后金额）"></a>1.2.2 实付金额（抵扣后金额）</h4><p>如实付100元再返20元代金券</p><h4 id="1-2-3-商品数量"><a href="#1-2-3-商品数量" class="headerlink" title="1.2.3 商品数量"></a>1.2.3 商品数量</h4><p>如买二送三，满2件每件165元，39元任选三件</p><h3 id="1-3-优惠方式"><a href="#1-3-优惠方式" class="headerlink" title="1.3 优惠方式"></a>1.3 优惠方式</h3><p>这个要素是指，商家以什么方式给予消费者优惠。</p><h4 id="1-3-1-减"><a href="#1-3-1-减" class="headerlink" title="1.3.1 减"></a>1.3.1 减</h4><p>在订单金额中减去部分金额，如满减，买立减，实付减</p><h4 id="1-3-2-折"><a href="#1-3-2-折" class="headerlink" title="1.3.2 折"></a>1.3.2 折</h4><p>订单金额或者商品单价打个折扣。如满188打8折，第二件半价。</p><p>折其实也是减的一种特殊情况，做文本串分析时当两种情况</p><h4 id="1-3-3-送-x2F-赠"><a href="#1-3-3-送-x2F-赠" class="headerlink" title="1.3.3 送&#x2F;赠"></a>1.3.3 送&#x2F;赠</h4><p>订单中赠送，或者订单完成后再赠送。如买1送1，买奶粉送奶瓶，买奶粉送京券</p><h4 id="1-3-4-换购"><a href="#1-3-4-换购" class="headerlink" title="1.3.4 换购"></a>1.3.4 换购</h4><p>满99元即可加1元换购超值礼品</p><h3 id="1-4-回馈内容"><a href="#1-4-回馈内容" class="headerlink" title="1.4 回馈内容"></a>1.4 回馈内容</h3><h4 id="1-4-1-现金"><a href="#1-4-1-现金" class="headerlink" title="1.4.1 现金"></a>1.4.1 现金</h4><ul><li>满减、满折就是减了现金</li></ul><h4 id="1-4-2-可折算成现金几无使用限制的卡-x2F-券-x2F-积分"><a href="#1-4-2-可折算成现金几无使用限制的卡-x2F-券-x2F-积分" class="headerlink" title="1.4.2 可折算成现金几无使用限制的卡&#x2F;券&#x2F;积分"></a>1.4.2 可折算成现金几无使用限制的卡&#x2F;券&#x2F;积分</h4><ul><li>赠送天猫积分、集分宝也等于赠送现金</li><li>京券、京东积分也等于现金</li></ul><h4 id="1-4-3-同主体商品"><a href="#1-4-3-同主体商品" class="headerlink" title="1.4.3 同主体商品"></a>1.4.3 同主体商品</h4><p>这条是指，赠送的商品与消费者购买的商品是同一个商品（可能保质期和生产批次略有不同，但总体上价值是一样的）</p><p>如一号店的德运全脂牛奶，买一升，赠一升，属于赠送同主体的商品。</p><h4 id="1-4-4-其它小赠品"><a href="#1-4-4-其它小赠品" class="headerlink" title="1.4.4 其它小赠品"></a>1.4.4 其它小赠品</h4><p>如买鞋送袜子，买奶粉送奶粉勺。</p><p>把同主体商品拿出来单独说，和其它小赠品区分开，是因为同主体商品有利于计算实际到手价，德运全指牛奶买1送1，就等于是5折了，但如果买1升德运牛奶送5克奥利奥饼干，就不方便衡量饼干的价值进而计算到手价。</p><h4 id="1-4-5-不可折算成现金的卡-x2F-券-x2F-积分"><a href="#1-4-5-不可折算成现金的卡-x2F-券-x2F-积分" class="headerlink" title="1.4.5 不可折算成现金的卡&#x2F;券&#x2F;积分"></a>1.4.5 不可折算成现金的卡&#x2F;券&#x2F;积分</h4><ul><li>送有限制条件的满减券、折扣券</li><li>送一号店积分</li><li>送淘金币</li><li>送航空公司里程等等</li></ul><p>这类回馈有的价值较高（如有限制条件的券），有的如同鸡肋（如淘金币、一号店积分）不好统一衡量价值，也不能拿来参与到手价计算</p><h3 id="1-5-是否有限制"><a href="#1-5-是否有限制" class="headerlink" title="1.5 是否有限制"></a>1.5 是否有限制</h3><p>是否有限制也影响到手价的计算</p><h4 id="1-5-1-有限制"><a href="#1-5-1-有限制" class="headerlink" title="1.5.1 有限制"></a>1.5.1 有限制</h4><ul><li>满150减15，每个订单仅限使用一次</li><li>买1送1，每个收货地址仅限5件</li><li>实付200再返10元，最高返200元</li></ul><h4 id="1-5-2-无限制"><a href="#1-5-2-无限制" class="headerlink" title="1.5.2 无限制"></a>1.5.2 无限制</h4><p>这个不多解释了</p><h2 id="2-常用优惠规则"><a href="#2-常用优惠规则" class="headerlink" title="2 常用优惠规则"></a>2 常用优惠规则</h2><p>上述5个因素，排列组合最多超过200种，但考虑到有些组合不可能存在，如“回馈内容”中的两种“赠品”只可能和“优惠方式”中的“送赠”组合，而不可能和“折、减”组合，实际常用的优惠方式约为几十种（有无限制我就不一一罗列了，读者朋友自行把下面优惠规则总数乘以二）：</p><h3 id="2-1-减折类（6种）"><a href="#2-1-减折类（6种）" class="headerlink" title="2.1 减折类（6种）"></a>2.1 减折类（6种）</h3><p>满折类的优惠条件主要是满N件和满N元，一般不会跟“实付xx元”搭配：</p><ul><li>买立减（买一件）</li><li>买立折（买一件）</li><li>满N件减x元 </li><li>满N件打x折</li><li>满N元减x元</li><li>满N元打x折</li></ul><h4 id="2-2-送（可折算现金）卡-x2F-券-x2F-积分、不可折算现金的卡-x2F-券-x2F-积分、其它小赠品（12种）"><a href="#2-2-送（可折算现金）卡-x2F-券-x2F-积分、不可折算现金的卡-x2F-券-x2F-积分、其它小赠品（12种）" class="headerlink" title="2.2 送（可折算现金）卡&#x2F;券&#x2F;积分、不可折算现金的卡&#x2F;券&#x2F;积分、其它小赠品（12种）"></a>2.2 送（可折算现金）卡&#x2F;券&#x2F;积分、不可折算现金的卡&#x2F;券&#x2F;积分、其它小赠品（12种）</h4><ul><li>买即送（买一件）</li><li>满N件送xx</li><li>满N元送xx</li><li>实付N元送xx</li></ul><p>在有的促销文案里，送虚拟卡券积分也叫满返。</p><p>以上四种场景乘以赠送的三种东西，就是12种。</p><h4 id="2-3-换购（4种）"><a href="#2-3-换购（4种）" class="headerlink" title="2.3 换购（4种）"></a>2.3 换购（4种）</h4><ul><li>买此商品即享换购资格</li><li>满N件即享换购资格</li><li>满N元即享换购资格</li><li>实付N元即享换购资格</li></ul><h4 id="2-4-送同主体商品（3种）"><a href="#2-4-送同主体商品（3种）" class="headerlink" title="2.4 送同主体商品（3种）"></a>2.4 送同主体商品（3种）</h4><ul><li>买N送M</li><li>满N元再送M件</li><li>实付N元再送M件</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/qinjx/30min_guides/blob/master/promotion_rule.md">https://github.com/qinjx/30min_guides/blob/master/promotion_rule.md</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>公共领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>公共领域</tag>
      
      <tag>个人思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS开发60分钟入门</title>
    <link href="/2019-01-02-dev-ios-quiz/"/>
    <url>/2019-01-02-dev-ios-quiz/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文面向已有其它语言（如Java，C，PHP，Javascript）编程经验的iOS开发初学者，初衷在于让我的同事一小时内了解如何开始开发iOS App，学习目标包括：</p><ul><li>能使用Xcode IDE、模拟器</li><li>能修改、调试已有iOS App</li><li>能在已有应用内创建新模块</li><li>能创建新应用</li><li>能发布应用到App Store</li></ul><p>本文不包含任何高级的iOS开发知识，已学会iOS开发的同学不要看，看完这篇文章学会了的同学也不用再看了。</p><span id="more"></span><h2 id="不仅是学习一门新语言"><a href="#不仅是学习一门新语言" class="headerlink" title="不仅是学习一门新语言"></a>不仅是学习一门新语言</h2><p>有过脚本开发经验的人（如Javascript，PHP，Shell）在刚开始学习iOS开发的时候，会觉得iOS开发的学习曲线比脚本语言要高，是的，这种感觉是对的。因为学iOS开发，不仅是学习一门新语言，它包括：</p><ul><li>一门语言：Objective-C</li><li>一个框架：Cocoa Touch</li><li>一个IDE：Xcode</li></ul><p>初学脚本语言通常不会来绘制图形界面、与人交互，iOS如果不做图形界面，像脚本语言一样处理文本操作数据库，就没啥意思了。</p><p>所以，过去我写别的新手入门教程，通常都是写《XXX入门15分钟教程》，而iOS就要花数倍的时间来写了。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>做iOS开发一定要有苹果的软件环境：Mac OS操作系统、Objective-C编译器、设备模拟器等，开发工具倒不一定要用Xcode，只要是个源代码编辑工具就行（vim都行，只是没Xcode那么多功能）。</p><h3 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h3><p>拥有Mac OS环境最简单的方法是找一台苹果电脑，包括iMac, MacBook Pro, MacBook Air, Mac Mini，但不包括苹果的移动设备（iPod Touch, iPhone, iPad, iPad Mini，它们运行的是iOS系统，不是Mac OS），苹果电脑在出厂的时候就会预装Mac OS，目前最新版本是Mac OS X 10.8，主流的版本还有Mac OS X 10.6、Max OS X 10.7。</p><p>如果囊中羞涩，可以借一台，或者上淘宝买个二手的。</p><h4 id="黑苹果"><a href="#黑苹果" class="headerlink" title="黑苹果"></a>黑苹果</h4><p>提到iOS开发入门，似乎没办法不说黑苹果。所谓黑苹果，就是把Mac OS改造后安装在非苹果的硬件上，这是违反DMCA法案的，黑苹果的更多资料，<a href="http://en.wikipedia.org/wiki/OSx86">可以在维基上找到</a></p><p>苹果电脑价格高，国内软件开发者生存压力大，所以黑苹果在国内也有一些真实的存在，国外当然也有啦。</p><p>黑苹果基本可以胜任iOS开发，但有一些问题：</p><ul><li>安装黑苹果是非法的</li><li>个人行为苹果公司一般不会追究，但会遭同行的鄙视</li><li>黑苹果超级难装，挑硬件。即使完全相同的型号，相同的批次，也有可能A机器装上了，B机器装不上</li><li>黑苹果系统多少都存在一些使用上的问题，像驱动Bug啦、待机恢复蓝屏啦、上网浏览有问题啦</li><li>黑苹果不能随意升级，可能升级一次safari就导致整个系统崩溃了</li></ul><p>上面这些虽然不会直接影响Xcode写代码、模拟器测试，但写着写着想上网查个东西的时候，safari不能翻页，确实挺影响心情的。所以，钱包允许的前提下，还是搞个苹果电脑省心一些。</p><h3 id="Xcode-和-模拟器"><a href="#Xcode-和-模拟器" class="headerlink" title="Xcode 和 模拟器"></a>Xcode 和 模拟器</h3><p>Xcode可以在苹果官网免费下载：<a href="https://developer.apple.com/Xcode/index.php">Xcode下载地址</a></p><p>安装Xcode时会自动安装iOS SDK和模拟器。</p><p>这么强大的IDE居然是免费的，还是挺让人开心的。</p><h2 id="从改一个现成的应用开始吧"><a href="#从改一个现成的应用开始吧" class="headerlink" title="从改一个现成的应用开始吧"></a>从改一个现成的应用开始吧</h2><p>学一门新软件开发技能，能够第一时间做出一个可运行的产品非常重要，有助于给自己正面激励，我上大学的时候，有很多次想学一门新语言，往往花了半个月，还沉浸在数据类型和语法字典里，连第一个Hello World都没做出来。</p><p>这一次，就让我们从改一个现成的应用开始吧。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>首先，我们从苹果开发者中心下载一个示例代码回来。我选了<a href="https://developer.apple.com/library/ios/samplecode/ToolbarSearch/ToolbarSearch.zip">ToolBarSearch</a>。</p><p>在本文档的末尾，还有一些其它的网址可以下载开源iOS产品或者代码段，但我试了一下，还是Apple Sample Code最容易成功。</p><p>下载回来的zip文件最好保存在”下载”或者”文稿”目录里，因为在Mac OS 10.8以前，有些目录（例如&#x2F;var&#x2F;private&#x2F;tmp）在Finder中是看不到的，要通过Finder的“前往 &gt; 前往文件夹”功能才能进入。</p><h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p>有三种方式可以打开一个iOS Project</p><h4 id="双击project文件"><a href="#双击project文件" class="headerlink" title="双击project文件"></a>双击project文件</h4><p>打开Finder，进入刚刚下载解压的ToolBarSearch目录，找到ToolBarSearch.Xcodeproj文件，双击之，Xcode会自动启动，并打开这个项目</p><h4 id="在Xcode里选择Project打开"><a href="#在Xcode里选择Project打开" class="headerlink" title="在Xcode里选择Project打开"></a>在Xcode里选择Project打开</h4><ul><li><p>在Xcode没启动的情况下（如果Xcode已经启动了，就先按Command Q退出），启动Xcode，会弹出“Welcome to Xcode”的欢迎页，点击左下角的“Open Other”按钮，找到ToolBarSearch目录，双击ToolBarSearch目录，或者双击ToolBarSearch.Xcodeproj文件都可以</p></li><li><p>如果Xcode处于打开状态，可以点击其菜单栏的File -&gt; Open，或者File -&gt; Open Recent，然后再选择要打开的项目</p></li></ul><h4 id="通过命令行打开"><a href="#通过命令行打开" class="headerlink" title="通过命令行打开"></a>通过命令行打开</h4><p>在Mac OS 10.8以前，有些目录（例如&#x2F;var&#x2F;private&#x2F;tmp），在Finder和Xcode的File &gt; Open对话框中，点击鼠标是找不到的，这时候就要通过命令行终端来打开了。</p><p>打开终端，执行：</p><pre><code class="hljs">cd /ToolBarSearch的父目录/ToolBarSearchopen -a Xcode</code></pre><p>open -a是mac os的系统命令，除了iOS项目，别的项目也可以这样打开。</p><h3 id="运行刚下载的应用"><a href="#运行刚下载的应用" class="headerlink" title="运行刚下载的应用"></a>运行刚下载的应用</h3><p>点击Xcode左上角的Run按钮（或者同时按下Comman和R键），Xcode会编译源码并在模拟器中运行这个应用。</p><p>编译成功会在屏幕上淡淡地显示“Build Succeeded”。反之，失败就显示“Build Failed”且不启动模拟器。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>在模拟器上看到“Performed search using…”了吧，下面我们改掉它。</p><ul><li><p>在Xcode左上角的Run按钮下方，有一排小按钮，从左到右第三个是一个放大镜图标，鼠标移上去会显示“Show the Search Navigator”，点一下它，打开搜索界面，在它下方出现的Find输入框中输入“performed”</p></li><li><p>搜索结果只有一条：ToolbarSearchViewController.m，点文件名下方被高亮的“Performed”字串，右侧代码编辑区会自动打开这个文件，并滚动屏幕，使包含“Performed”的这一行出现在编辑区的中间。</p></li><li><p>修改双引号里的字串，随便改成啥，然后按“Command S”保存。</p></li></ul><p>当然，这些操作，你也可以在终端下通过grep和vim完成。</p><h3 id="运行修改后的应用"><a href="#运行修改后的应用" class="headerlink" title="运行修改后的应用"></a>运行修改后的应用</h3><p>按Command R运行，看看，是不是看到效果啦？</p><p>是的，修改一个应用就这么简单。</p><h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><p>Objective-C是苹果应用软件（包括苹果电脑上的Mac OS App和移动设备上的iOS App）的开发语言。它是一种面向对象的编程语言。</p><p>苹果公司还提供了一个软件，叫Interface Builder，简称IB，用于可视化的界面制作，就像用Dreamweaver做网页，或者像Visual Basic做桌面软件一样。后来IB就整合进了Xcode，成了Xcode的一部分。这篇文档不讲IB，只讲Objective-C，因为：</p><ul><li>基本上，每一本讲iOS开发的书（纸质书、电子书），都有大量的截图一步一步教如何用IB开发iOS应用，而讲Objective-C开发应用的书却没有那么多。</li><li>IB可以用来直观方便地画界面、设置控件属性、建立代码与控件的联系，但后台的业务逻辑和数据处理仍然要靠Objective-C，可见，不管用不用IB，Objective-C都是绕不过去的。</li></ul><h3 id="C的超集"><a href="#C的超集" class="headerlink" title="C的超集"></a>C的超集</h3><p>Objective-C扩展了ANSI C，是C的超集，也就是说：</p><ul><li>任何C源程序，不经修改，即可通过Objective-C编译器成功编译</li><li>Objective-C源程序中可以直接使用任何C语言代码</li></ul><p>除了面向对象有语法是SmallTalk风格的（下面会讲到），其它非面向对象的语法、数据类型，与C完全相同，所以本文就不再赘述。<br>来看一个经典的Hello World示例吧：</p><pre><code class="hljs">#import &lt;Foundation/Foundation.h&gt;int main(int argc, char *argv[])&#123;    @autoreleasepool&#123;        NSLog(@&quot;Hello World!&quot;);    &#125;    return 0;&#125;</code></pre><p>是不是仿佛穿越回了大一学习C语言的时代，看起来和C几乎没有区别，是吧？是的，因为还没用到它的面向对象特性，哈哈！</p><h3 id="SmallTalk的消息传递语法风格"><a href="#SmallTalk的消息传递语法风格" class="headerlink" title="SmallTalk的消息传递语法风格"></a>SmallTalk的消息传递语法风格</h3><p>Objective-C的面向对象语法源自SmallTalk，消息传递（Message Passing）风格。在源码风格方面，这是它与C Family语言（包括C&#x2F;C++、Java、PHP）差别最大的地方。</p><p>在Java、C++世界，我们调用一个对象的某方法，在Objective-C里，这称作给类型发送一个消息，这可不仅仅是文字游戏，他们的技术细节也是不同的。</p><p>在Java里，对象和方法关系非常严格，一个方法必须属于一个类&#x2F;对象，否则编译是要报错的。而在Objective-C里，类型和消息的关系比较松散，消息处理到运行时（runtime）才会动态决定，给类型发送一个它无法处理的消息，也只会抛出一个异常，而不会挂掉。</p><pre><code class="hljs">[obj undefinedMethod];</code></pre><p>在代码里调用没定义的方法（这是Java世界的习惯说法啊，专业的叫法是，给obj对象传递它无法处理的消息），Xcode会警告，但编译能成功，运行的时候会出错。它会输出这样一个错误：</p><pre><code class="hljs">Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[NSObject undefinedMethod]: unrecognized selector sent to instance 0x8871710&#39;</code></pre><h3 id="类似Java的OOP概念"><a href="#类似Java的OOP概念" class="headerlink" title="类似Java的OOP概念"></a>类似Java的OOP概念</h3><p>Objective-C中一些面向对象的概念，也可以在Java中找到类似的实现（只能说是类似，不是完全相同），我的读者基本都是Java和PHP程序员，我会在下文中尽量用Java的概念来类比。</p><p>GoogleCode上有人整理了Java和Objective-C的概念、数据类型对应表，<a href="http://code.google.com/p/j2objc/wiki/JavaConversions">参见这里</a></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Objective-C里有字符串是由双引号包裹，并在引号前加一个@符号，例如：</p><pre><code class="hljs">title = @&quot;Hello&quot;;if(title == @&quot;hello&quot;) &#123;&#125;</code></pre><p>PHP程序员要注意，在这里不能用单引号，即使只有一个字符也不能用。Objective-C与Java、C一样，双引号表示字符串。</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>前文述及，不涉及面向对象时，它和C是完全一样的。以下是几个函数调用的示例：</p><h4 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h4><pre><code class="hljs">startedBlock();</code></pre><h4 id="带参数"><a href="#带参数" class="headerlink" title="带参数"></a>带参数</h4><pre><code class="hljs">NSLog(@&quot;decrypted string: %@&quot;, str);CGRectMake(0,0,0,0);</code></pre><h3 id="传递消息给类-x2F-实例方法"><a href="#传递消息给类-x2F-实例方法" class="headerlink" title="传递消息给类&#x2F;实例方法"></a>传递消息给类&#x2F;实例方法</h3><h4 id="不带参数-1"><a href="#不带参数-1" class="headerlink" title="不带参数"></a>不带参数</h4><pre><code class="hljs">[obj method];</code></pre><p>对应的Java版本</p><pre><code class="hljs">obj.method();</code></pre><h4 id="带一个参数："><a href="#带一个参数：" class="headerlink" title="带一个参数："></a>带一个参数：</h4><pre><code class="hljs">[counter increase:1];</code></pre><p>对应的Java版本</p><pre><code class="hljs">counter.increase(1);</code></pre><h4 id="带多个参数"><a href="#带多个参数" class="headerlink" title="带多个参数"></a>带多个参数</h4><p>对C Family程序员来说，这是最难接受的，最反人类的：</p><pre><code class="hljs">- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue &#123;...&#125; //定义方法[myObj setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; //调用方法</code></pre><p>对应的Java版</p><pre><code class="hljs">public void setColorToRedGreenBlue(float red, float green, float blue) &#123;...&#125;myObj.setColorToRedGreenBlue(1.0, 0.8, 0.2);</code></pre><h4 id="消息嵌套"><a href="#消息嵌套" class="headerlink" title="消息嵌套"></a>消息嵌套</h4><pre><code class="hljs">UINavigationBar *bar = [[[UINavigationBar alloc] init] autorelease];</code></pre><p>对应的Java版</p><pre><code class="hljs">UINavigationBar bar = UINavigationBar.alloc().init().autorelease();//Java没有指针，所以星号去掉了</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h4><p>Objective-C的类分为接口定义和实现两个部分。接口定义（Interface）放在头文件中，文件扩展名是.h，实现（implementation）放在实现文件中，文件扩展名是.m（也有.mm的扩展名，表示Objective-C和C++混编的代码）。</p><p><code>接口定义也可以写在.m文件中，但最好不要这么干</code></p><p>需要注意的是，与Objective-C的interface概念最接近的是C和C++里的头文件，它与implementation是成双成对出现的，作用是声明类的成员变量和方法。它与Java的interface概念完全不同：</p><ul><li>Objective-C里，interface有且只有一个实现，Java的interface可以有0-N个实现</li><li>Objective-C里，interface可以定义成员属性，Java里不可以</li></ul><p>在Objective-C里，和Java的Interface概念相似的是Protocol，下文会讲到。</p><p>请看示例：</p><p>Interface</p><pre><code class="hljs">@interface MyClass &#123;    int memberVar1;    id  memberVar2;&#125;-(return_type) instance_method1; -(return_type) instance_method2: (int) p1;-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end</code></pre><p>Implementation</p><pre><code class="hljs">@implementation MyClass &#123;    int memberVar3;&#125;-(return_type) instance_method1 &#123;    ....&#125;-(return_type) instance_method2: (int) p1 &#123;    ....&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123;    ....&#125;@end</code></pre><p>接口和实现以@interface、@implementation开头，都以@end结束。“@”符号在Objective-C中是个很神奇的符号。</p><p>冒号也是方法名的一部分，method和method:是两个不同的方法名，不是overload，第二个带参数。</p><p>上述代码对应的Java版：</p><pre><code class="hljs">public class MyClass &#123;    protected int memberVar1;    protected pointer memberVar2;    private int memberVar3;        public (return_type) instance_method1() &#123;        ....    &#125;        public (return_type) instance_method2(int p1) &#123;        ....    &#125;        public (return_type) instance_method3andPar(int p1, int p2) &#123;        ....    &#125;&#125;</code></pre><h4 id="私有方法和公开方法"><a href="#私有方法和公开方法" class="headerlink" title="私有方法和公开方法"></a>私有方法和公开方法</h4><p>写在.h头文件里的方法都是公开的，Objective-C里没有私有方法的概念（没有你说个蛋啊，哈哈哈哈）。</p><p>官方并没有提到Objective-C怎么实现私有方法，我查阅了stackoverflow，统一的答案是，要实现私有方法的效果只能借助Category，不过，根据我的测试，即使采用了Category，也不能阻止外部的代码调用这个“私有方法”，只是Xcode不支持“私有方法”的自动完成，并会有警告提示，运行的时候，还是会成功的。各位看官知道有这么回事就可以了，这里不深讲。</p><h4 id="变量和属性"><a href="#变量和属性" class="headerlink" title="变量和属性"></a>变量和属性</h4><h4 id="类方法和实例方法"><a href="#类方法和实例方法" class="headerlink" title="类方法和实例方法"></a>类方法和实例方法</h4><h5 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h5><p>类方法就是Java、PHP里的Static Method，不用实例化就能调。类方法有一个加号前缀。<br>示例：</p><p>类定义</p><pre><code class="hljs">@interface MyClass    +(void) sayHello;@end@implementation MyClass+(void) sayHello &#123;    NSLog(@&quot;Hello, World&quot;);&#125;@end</code></pre><p>使用</p><pre><code class="hljs">[MyClass sayHello];</code></pre><h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><p>实例方法就是Java、PHP里的普通方法，必须实例化才能调。实例方法有一个减号前缀。<br>示例：</p><p>类定义</p><pre><code class="hljs">@interface MyClass : NSObject-(void) sayHello;@end@implementation MyClass-(void) sayHello &#123;    NSLog(@&quot;Hello, World&quot;);&#125;@end</code></pre><p>使用</p><pre><code class="hljs">mycls = [MyClass new];[mycls sayHello];</code></pre><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>selector就是一个方法指针，类似PHP里的动态方法名：</p><pre><code class="hljs">&lt;?phpclass Hello &#123;    public function sayHello() &#123;&#125;        public function test() &#123;        $fun_name = &quot;sayHello&quot;;        $this-&gt;$fun_name();    &#125;&#125;</code></pre><p>在Objective-C里，selector主要用来做两类事情：</p><h5 id="绑定控件触发的动作"><a href="#绑定控件触发的动作" class="headerlink" title="绑定控件触发的动作"></a>绑定控件触发的动作</h5><pre><code class="hljs">@implementation DemoViewController- (void)downButtonPressed:(id)sender &#123;//响应“按钮被按下事件”的方法    UIButton *button = (UIButton*)sender;    [button setSelected:YES];&#125;- (void)drawAnButton &#123;    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];     btn.frame = _frame;     btn.tag = 1;    btn.backgroundColor = [UIColor clearColor];    [btn addTarget: self         action: @selector(downButtonPressed:)         forControlEvents: UIControlEventTouchUpInside];//当这个按钮被按下时，触发downButtonPressed:方法&#125;@end</code></pre><h5 id="延时异步执行"><a href="#延时异步执行" class="headerlink" title="延时异步执行"></a>延时异步执行</h5><pre><code class="hljs">@implementation ETHotDealViewController- (void)viewDidLoad &#123;        //获取数据源    HotDealDataSource *ds = [[HotDealDataSource alloc]init];    [ds reload];    _items = ds.items;        [self performSelector: @selector(refreshTable)          withObject: self          afterDelay: 0.5];//延迟0.5秒调用refreshTable方法&#125;-(void)refreshTable&#123;    [self.tableView reloadData];&#125;@end</code></pre><p>这个例子中，获取数据源是通过ASIHTTP组件异步调用服务端HTTP接口，refreshTable要用到数据源返回回来的数据，如果不延迟0.5秒，就会立刻执行，执行的时候数据还在路上呢，页面就要变空白了。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是写在Interface定义里面的。语法为：子类名在左，父类名在右，中间用冒号分隔。<br>示例：</p><pre><code class="hljs">@interface MyClass : NSObject@end</code></pre><p>对应的Java版本是：</p><pre><code class="hljs">public class MyClass extends NSObject &#123;&#125;</code></pre><h3 id="协议（Protocol）"><a href="#协议（Protocol）" class="headerlink" title="协议（Protocol）"></a>协议（Protocol）</h3><p>就是Java、PHP里的Interface。</p><h4 id="协议的定义"><a href="#协议的定义" class="headerlink" title="协议的定义"></a>协议的定义</h4><p>协议的定义用@protocol关键字：</p><pre><code class="hljs">@protocol Printable    -(void)print:(NSString)str;@end</code></pre><p>对应的Java版本是：</p><pre><code class="hljs">publilc interface Printable &#123;    public void print(String str);&#125;</code></pre><h5 id="协议的继承"><a href="#协议的继承" class="headerlink" title="协议的继承"></a>协议的继承</h5><p>协议本身也可以继承别的协议：</p><pre><code class="hljs">@protocol Printable &lt;NSObject&gt;    -(void)print:(NSString)str;@end</code></pre><p>对应的Java版本：</p><pre><code class="hljs">public interface Printable extends NSObject &#123;    public void print (String str);&#125;</code></pre><h5 id="可选方法"><a href="#可选方法" class="headerlink" title="可选方法"></a>可选方法</h5><p>协议可以包含可选方法，顾名思义，可选方法可以不被类实现：</p><pre><code class="hljs">@protocol Printable@optional    -(void)print:(NSString)str;@end</code></pre><p>加了@optional关键字，一个类在implements这个协议时，便可以不实现print:方法。</p><p>Java里没有类似的实现，除了Collection里会有一些方法带有optional的注释，但Collection是个特例。</p><h4 id="协议的实现"><a href="#协议的实现" class="headerlink" title="协议的实现"></a>协议的实现</h4><p>一个类实现某些协议是写在Interface定义里面的。语法为：协议名用尖括号包裹，多个协议名用逗号隔开，协议写在父类的右边（如果没有父类就直接写在子类右边）。</p><p>示例：</p><pre><code class="hljs">@interface MyClass : NSObject &lt;Printable, Drawable&gt;@end</code></pre><p>Printable, Drawablw就是两个协议。</p><p>对应的Java版本是：</p><pre><code class="hljs">public class MyClass extends NSObject implements Printable, Drawable &#123;&#125;</code></pre><h3 id="分类（Category）"><a href="#分类（Category）" class="headerlink" title="分类（Category）"></a>分类（Category）</h3><p>分类可以给一个已经存在的类增加方法，而不用去改它的源码。Java和PHP中都没有类似的特性。</p><p>比如说，NSObject是一个Objective-C内置的系统类，我们想给它增加toJson方法，就像这样：</p><p>头文件：NSObject+Json.h</p><pre><code class="hljs">@interface NSObject (Json)    -(NSString)toJson;@end</code></pre><p>实现文件：NSObject+Json.m</p><pre><code class="hljs">@implementation NSObject (Json)    -(NSString)toJson &#123;        //...    &#125;@end</code></pre><p>使用的时候，只要包含NSObject+Json.h，实例化NSObject类，就可以使用toJson方法了：</p><pre><code class="hljs">import &quot;NSObject+Json.h&quot;@implementation XYZController    -(void)test &#123;        NSObject *obj = [[NSObject alloc]init];        NSString *str = [obj toJson];    &#125;@end</code></pre><p>当然了，NSObject本来的那些方法依然还是可以用的，什么都没变，只是多了个toJson方法。看起来是不是和继承没太多差别呢（除了使用的时候实例化的是NSObject，而不是JsonObject）？再看一个继承实现不了的例子：</p><p>头文件：NSObject+Json+XML.h</p><pre><code class="hljs">@interface NSObject (Json)    -(NSString)toJson;@end@interface NSObject (XML)    -(NSString)toXML;@end</code></pre><p>实现文件：NSObject+Json+XML.m</p><pre><code class="hljs">@implementation NSObject (Json)    -(NSString)toJson &#123;        //...    &#125;@end@implementation NSObject (XML)    -(NSString)toXML &#123;        //...    &#125;@end</code></pre><p>使用：</p><pre><code class="hljs">import &quot;NSObject+Json+XML.h&quot;@implementation XYZController    -(void)test &#123;        NSObject *obj = [[NSObject alloc]init];        NSString *json = [obj toJson];        NSString *xml = [obj toXML];    &#125;@end</code></pre><h2 id="Cocoa-Touch"><a href="#Cocoa-Touch" class="headerlink" title="Cocoa Touch"></a>Cocoa Touch</h2><p>Cocoa是Mac OS App的开发框架，Cocoa Touch是iOS开发用的框架，Cocoa Touch和Cocoa大部分是一样的，只是Cocoa Touch多了一些移动设备特有的东西，如：触摸屏、加速度传感器、GPS定位。Cocoa中多任务、多窗口的特性，在Cocoa Touch中也是没有的（或者跟Cocoa不完全一样的）。</p><p>就像学了Java语言还要再学一些Spring、Hibernate、Struts（或者其它类似的Java类库）才能开始做J2EE应用一样，学过Objective-C语言之后，也要再学习Cocoa Touch框架才能顺利地开发iOS应用。</p><h3 id="最常用设计模式之Delegate"><a href="#最常用设计模式之Delegate" class="headerlink" title="最常用设计模式之Delegate"></a>最常用设计模式之Delegate</h3><p>Cocoa Touch大量使用Delegate（委派）设计模式。</p><h3 id="常用控件：按钮、文本块、图片、输入框"><a href="#常用控件：按钮、文本块、图片、输入框" class="headerlink" title="常用控件：按钮、文本块、图片、输入框"></a>常用控件：按钮、文本块、图片、输入框</h3><h3 id="TableView"><a href="#TableView" class="headerlink" title="TableView"></a>TableView</h3><h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><h3 id="导航条"><a href="#导航条" class="headerlink" title="导航条"></a>导航条</h3><h2 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>快捷键：Comman R</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="搜索文本"><a href="#搜索文本" class="headerlink" title="搜索文本"></a>搜索文本</h4><h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><h3 id="新建文件-x2F-目录"><a href="#新建文件-x2F-目录" class="headerlink" title="新建文件&#x2F;目录"></a>新建文件&#x2F;目录</h3><p>推荐在Finder中新建好的再添加进来</p><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><h2 id="模拟器和真机测试"><a href="#模拟器和真机测试" class="headerlink" title="模拟器和真机测试"></a>模拟器和真机测试</h2><h3 id="模拟器测试"><a href="#模拟器测试" class="headerlink" title="模拟器测试"></a>模拟器测试</h3><p>在Xcode中打开你的项目，在Xcode顶部工具栏的Stop按钮（Run按钮右边那个黑色正方形按钮）右边，有个下拉菜单，显示着 “ToolBarSearch &gt; iPhone 5.0 Simulator” （即 你的应用英文名 &gt; 当前选中的调试 ），点击这个下拉菜单，选中iPhone 5.0 Simulator（这里的5.0是指iOS版本，不是iPhone5的意思，如果你的项目是iPad应用，请选iPad 5.0 Simulator），再按“Run”按钮，Xcode就会自动把当前正在编辑开发的应用编译并安装到模拟器上。</p><p>在模拟器上操作时，如果执行过程中遇到了你在Xcode里设置的断点，模拟器会暂停运行，并将当前活动窗口切换回Xcode，供你调试。</p><p>在Xcode里增加或者取消了断点，不需要重新编译和安装应用即可生效。</p><h4 id="切换被模拟的设备"><a href="#切换被模拟的设备" class="headerlink" title="切换被模拟的设备"></a>切换被模拟的设备</h4><p>模拟器的“硬件”菜单，可以选择想要模拟什么设备，有iPad、iPhone可选。</p><ul><li>Retina：表示视网膜屏，iPhone(Retina)代表iPhone4，iPhone4S</li><li>4-Inch：表示4英寸的iPhone，iPhone(Retina 4-Inch)就是iPhone 5</li></ul><h4 id="切换模拟的iOS版本"><a href="#切换模拟的iOS版本" class="headerlink" title="切换模拟的iOS版本"></a>切换模拟的iOS版本</h4><p>在模拟器的“版本”菜单，可以选择要模拟什么版本的iOS。设备和版本是彼此独立的，iPhone 4S可以有5.0，5.1，6.1几种iOS版本，当然了，iPhone 5不可能有4.3的iOS版本。</p><h4 id="触摸屏"><a href="#触摸屏" class="headerlink" title="触摸屏"></a>触摸屏</h4><p>用鼠标点击（不区分左右键）模拟器上的iPhone、iPad屏幕，就是在模拟用手指触摸iPhone，iPad的屏幕，可以实现一些触摸效果比如：</p><ul><li>鼠标单击 等于 手指轻触</li><li>鼠标长按 等于 手指长按（例如你可以在模拟器上长按应用icon调出删除应用的确认框）</li><li>鼠标按住拖动 等于 手指拖动</li><li>双击和单击模拟器的Home键也等于双击和单击真机的Home键</li></ul><h5 id="多指手势"><a href="#多指手势" class="headerlink" title="多指手势"></a>多指手势</h5><p>多指手势比较复杂，在白苹果笔记本上可以模拟简单的双指手势，白苹果的触控板天然支持多指触摸，但要定位到模拟器的区域再响应多指手势就需要借助一些额外的键啦：</p><ul><li>按住Option键，再用两个手指去操作触摸板，可模拟双指拖动、旋转</li><li>按住Option+Shift，可模拟双指合拢</li></ul><h4 id="输入法和键盘"><a href="#输入法和键盘" class="headerlink" title="输入法和键盘"></a>输入法和键盘</h4><h5 id="输入中文"><a href="#输入中文" class="headerlink" title="输入中文"></a>输入中文</h5><p>手机上特有的输入法（比如九宫格输入法）不能模拟。模拟器默认的iOS软键盘只有英文输入，在测试应用的时候，我们要用到中文，有两个办法：</p><ul><li>使用剪贴板，在Mac OS里复制，再到模拟器运行的应用中的输入框上长按鼠标（模拟手指长按）3秒以上，等弹出“粘贴”的时候选择之，即可。</li><li>在模拟器里，按Home键，找到Setting那个App icon（不是Mac OS顶部的模拟器菜单啊，那里没有Setting的），打开被模拟iOS设备的设置，依次点击”General - Keyboard - International Keyboards - Add New Keyboard…”，加个中文键盘，以后就可以使用被模拟iOS设备软件盘输入中文了，跟在iPhone&#x2F;iPad真机上一样。</li></ul><h4 id="使用Mac电脑的键盘"><a href="#使用Mac电脑的键盘" class="headerlink" title="使用Mac电脑的键盘"></a>使用Mac电脑的键盘</h4><p>如果要输入大量文本，使用模拟器里的软键盘效率太低，这时候可以使用物理键盘，方法是：在Mac OS顶部的模拟器菜单栏，点击”硬件”菜单，勾选下拉菜单中的“模拟硬件键盘”。以后再用模拟器运行iOS应用时，点击iOS应用中的输入框，软键盘就不弹出来了，可直接使用Mac电脑的物理键盘输入。</p><p><em>注意</em>：</p><ul><li>模拟器中的iOS接管了物理键盘输入，所以，调用的是模拟器iOS的输入法，不是你的Mac电脑的输入法。打个比方，你的Mac OS装的是搜狗五笔，模拟器中iOS加了个拼音输入法（Add New Keyboard），那么，在iOS应用中输入中文会调用拼音输入法。</li><li>要切换模拟器中iOS的中英文输入法，也只能按iOS设备软键盘上的小地球图标，按Mac电脑上的Command+空格键是不行的。</li></ul><h4 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h4><p>但Mac电脑没有定位用的硬件（GPS）和软件基础，因此模拟器不能自动获得当前的地理位置，不能用模拟器测试定位功能。（注意，虽然WiFi也可以独立定位——iPad WiFi版没有GPS也可以定位，但Mac电脑的WiFi不具备定位相关的软件）</p><p>要在模拟器里测试依赖地理位置的功能（如”我附近的xx”），可以手工指定一个经纬度给模拟器，方法：在Mac电脑顶部的模拟器菜单，点击”调试 - 位置 - 自定位置”，会弹出一个对话框，在弹出的框内填入经纬度即可。</p><p>如何获得经纬度？<br>上谷歌地图（ditu.google.cn），在地图上找到你想要的位置（比如你想知道杭州大厦的位置，就在通过搜索框找到杭州大厦），点击右键，选择“这儿是什么”，搜索框中就会出现这个位置的经纬度了，前面是纬度，后面是经度。咱们天朝的版图，都是北纬和东经。</p><h4 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h4><p>Mac电脑有摄像头，但Mac OS没有设计API给iOS模拟器调用，所以，不能用模拟器测试对焦闪光灯等功能。</p><p>要在模拟器上测试依赖照片的功能，可以在代码里做一个workaround，即当代码检测到摄像头不可用时，弹出一个照片选择器，让测试人员从相册里选择一幅照片，来进行后续的操作（如照片美化、人脸识别、条码扫描）。</p><h3 id="真机测试"><a href="#真机测试" class="headerlink" title="真机测试"></a>真机测试</h3><p>模拟器能验证你开发的iOS应用的大部分功能，但有些Mac设备上不具备的硬件，模拟器是不能模拟的。前文提到了一个绕过这些限制的办法，但获取当前位置、拍照、加速度感应这些是模拟不了的，一款应用发布给消费者之前，必须要在真实设备上验证过。</p><p>将未提交App Store审核通过的应用安装到iOS设备上测试，有三种办法：</p><ul><li>加入苹果的Developer Program，成为付费会员，有了这个付费会员资格，就可以直接在Xcode中点击”Run”将刚刚改过的代码编译打包安装到开发测试用的iOS设备上。在iOS真机上操作被测试的程序能激活Xcode中设置的断点。</li><li>越狱iOS设备。将iPhone和iPad越狱后，可以通过SSH直接上传Xcode编译好的ipa包（一个iOS App本质上就是一个ipa包）。</li><li>越狱的iOS设备，配合破解过的Xcode，甚至可以实现和付费开发者计划一样的功能：在Xcode上点击”Run”，就自动编译安装到iOS设备上去运行了</li><li>企业部署方案。就像阿里巴巴的<a href="http://xyj.im/">轩辕剑</a>一样，用iPhone&#x2F;iPad访问这个网址，点击里面的轩辕剑链接就可以安装轩辕剑这个应用了。</li></ul><p>破解Xcode是违法行为（越狱是合法的），而且挑版本挑得厉害，不是所有Xcode版本都能破解，也不是所有Xcode的破解版都能和越狱的iOS配合好。越狱+SSH上传跟企业部署一样效率低（部署效率低，无法激活Xcode中的断点），只能用于QA验收，不适合开发自测。综上所述，最适合开发实时测试的就是第一个正规途径了。下面重点讲这个：</p><h4 id="拥有一个开发者账号"><a href="#拥有一个开发者账号" class="headerlink" title="拥有一个开发者账号"></a>拥有一个开发者账号</h4><p>苹果的Developer Program分为个人开发者和公司开发者，分别是每年99美元和每年299美元，分别可以注册100台和500台苹果测试设备。这个台数限制在一个付费年度内不会清空，比如说，2013年4月1日付费成功的，付费会员资格在2014年3月31日之前有效，这期间，注册一台就少一个名额，哪怕这个设备注册进来用了之后一分钟马上又删掉了，减少的这个名额也不会回来。</p><p>在交钱之前，最好问一下，周围的同事，有没有已经交了钱的。如果有，你只需要注册一个免费的Apple ID（就是你在App Store安装软件用的Apple ID），请他发个邀请邮件给你，把你的Apple ID加入他的团队就可以了，苹果会认为你们两个人是一个团队的，你们分别用自己的账号，共享100台设备的限额，这是合法的。</p><h4 id="安装证书和私钥"><a href="#安装证书和私钥" class="headerlink" title="安装证书和私钥"></a>安装证书和私钥</h4><h5 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h5><p>不想看下面各种点击各种页面跳转的直接用浏览器访问<a href="https://developer.apple.com/ios/manage/certificates/team/index.action">证书管理</a>，你要登录你就用Apple ID登录（前提是交过钱，或者找交了钱的人把你加入团队了）。</p><blockquote></blockquote><p>不嫌烦，或者想知道下次没我这个文档的时候怎么进证书管理吗？按这个步骤操作：</p><ul><li>进入 <a href="https://developer.apple.com/">苹果开发者中心</a></li><li>点击iOS Dev Center</li><li>点蓝色“Login”按钮，用你的Apple ID登录，登录成功会跳到 <a href="https://developer.apple.com/devcenter/ios/index.action">开发者首页</a></li><li>点击右上角的<a href="https://developer.apple.com/ios/manage/overview/index.action">iOS Provisioning Portal</a>（别找了，直接Command F搜索多好）</li><li>点左侧菜单栏里的<a href="https://developer.apple.com/ios/manage/certificates/team/index.action">Certificates</a></li></ul><p>页面上有一个“Your Certificate”区域，下方有个Download圆角按钮，这是你的个人证书，下载下来。再下面一行，有一句“If you do not have the WWDR intermediate certificate installed, <a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer">click here to download now</a>”，这个是苹果的公共证书，也下下来。</p><p>双击下载回来的证书，装证书时，会提示你输入密码，这是【钥匙串访问工具】在问你要你的Mac OS账号开机密码（相当于linux里面的sudo），不是Apple ID的密码，不要搞错了。</p><h5 id="安装私钥"><a href="#安装私钥" class="headerlink" title="安装私钥"></a>安装私钥</h5><p>如果你是和其它同事公用的账号，让他给你一个私钥即可，就是一个扩展名为p12的文件，双击之，钥匙串访问会自动出来，需要你输入一个密码，这个密码问给你p12文件的人要，不是你的Mac OS系统开机密码，也不是你的Apple ID密码。</p><h4 id="将设备注册到Provisioning-Portal"><a href="#将设备注册到Provisioning-Portal" class="headerlink" title="将设备注册到Provisioning Portal"></a>将设备注册到Provisioning Portal</h4><ul><li>打开Xcode，从Xcode的Window菜单中找到Organizer，打开之（Shift Command 2）。</li><li>把iOS设备连上电脑，Organizer会自动识别出你的设备，并显示在左侧边栏。</li><li>在Organizer左侧边栏找到你的设备，右键，点击“Add Device to Provisioning Portal”，然后等Organizer提示你操作成功即可。（选中设备后，右边设备详情区域会显示一个按钮“Use for Development”，点它也可以）。</li></ul><h4 id="到iOS真机上运行测试版程序"><a href="#到iOS真机上运行测试版程序" class="headerlink" title="到iOS真机上运行测试版程序"></a>到iOS真机上运行测试版程序</h4><p>回到Xcode主界面，在Stop按钮（Run按钮右边那个黑色正方形按钮）右边，有个下拉菜单，显示着 “ToolBarSearch &gt; iPhone 5.0 Simulator” （即 你的应用英文名 &gt; 当前选中的调试 ），点击这个下拉菜单，选中你的真机设备名，再按“Run”按钮，Xcode就会自动把当前正在编辑开发的应用编译并安装到真机上测试啦！</p><h4 id="发布到App-Store"><a href="#发布到App-Store" class="headerlink" title="发布到App Store"></a>发布到App Store</h4><h4 id="打IPA包"><a href="#打IPA包" class="headerlink" title="打IPA包"></a>打IPA包</h4><p>IPA包本质上是一个ZIP压缩包，只不过它有着特殊的目录结构，扩展名是ipa，制作方法如下：</p><ul><li>在Xcode中Build项目，快捷键Command B</li><li>在左侧项目导航器中，展开Products文件夹，找到你要打包的应用，你的应用名.app，右键，选择show in finder</li><li>到Finder中Copy这个.app目录（选中，按Command C），复制到一个你新建的名为Payload（区分大小写）的文件夹中</li><li>找到你的应用Logo，即一个512 * 512像素的PNG文件，copy到与Payload一起（与Payload并列，不要放进Payload了），并重命名为iTunesArtwork（区分大小写，没有扩展名）</li><li>将Payload目录、ItunesArtwork文件打成一个zip包，并更改扩展名为ipa</li><li>双击这个ipa文件，会用iTunes打开，如果打开成功，且在iTunes里有应用Logo显示，就成功了</li></ul><h4 id="批量自动打包"><a href="#批量自动打包" class="headerlink" title="批量自动打包"></a>批量自动打包</h4><p>除App Store外，还有许多其它的iOS应用市场（如91助手，同步推等等），如果一个应用需要发布到很多个应用市场，且他们的代码略有不同（比如说，统计代码不同），按上述方法手工修改源码再打包，再还原，比较容易出错。好消息是，Xcode是有命令行的，我们可以写一个shell脚本，先用se自动修改源码，再调用Xcode的命令行来编译以得到your——app.app目录，最后调用zip、mv等命令把上一个章节讲的ipa打包动作自动执行。</p><h2 id="阅读应用代码"><a href="#阅读应用代码" class="headerlink" title="阅读应用代码"></a>阅读应用代码</h2><h2 id="从头新建一个应用：Hello-World"><a href="#从头新建一个应用：Hello-World" class="headerlink" title="从头新建一个应用：Hello World"></a>从头新建一个应用：Hello World</h2><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="代码里的控件尺寸"><a href="#代码里的控件尺寸" class="headerlink" title="代码里的控件尺寸"></a>代码里的控件尺寸</h3><p>iOS App里的控件尺寸和字体大小都是指Point，Retina设备（iPhone 4，4S，5；the new Pad）和非Retina设备（iPhone 3GS，iPad，iPad 2）的Point数是一样的，尽管iPhone 4的分辨率是3GS的2倍。比如说，10point在Retina设备里是20 pixel，在非Retina设备（iPhone 3G）上则是10 pixel。</p><p>项目成员间交流时，应使用Point，不要使用pixel。</p><h3 id="SVN操作含有-符号的文件"><a href="#SVN操作含有-符号的文件" class="headerlink" title="SVN操作含有@符号的文件"></a>SVN操作含有@符号的文件</h3><p>iOS应用中经常出现<a href="mailto:&#x78;&#120;&#120;&#x78;&#64;&#x32;&#120;&#46;&#112;&#x6e;&#x67;">&#x78;&#120;&#120;&#x78;&#64;&#x32;&#120;&#46;&#112;&#x6e;&#x67;</a>这样的文件名,它们是给retina设备用的高分辨率大图，用svn命令行操作它们的时候会被@符号干扰,解决方案是在svn命令末尾加上一个@符号,如:</p><pre><code class="hljs">svn del icon@2x.png@svn info Default@2x.png@</code></pre><p>如果一次移动了几十个png文件再svn commit的,可以用shell批处理:</p><pre><code class="hljs">svn status | awk &#39;($1==&quot;!&quot;)&#123;print $2&#125;&#39; | grep -v @ | xargs svn del</code></pre><p>上面这个命令是将文件名不包含@符号的,且已经不在硬盘上的文件从svn version controll中删掉</p><pre><code class="hljs">for file in `svn status | awk &#39;($1==&quot;!&quot;)&#123;print $2&#125;&#39; `; do svn del $file&quot;@&quot;; done     </code></pre><p>上面这个命令是将文件名包含@符号的,且已经不在硬盘上的文件从svn version controll中删掉</p><p>svn add同上, 如法炮制即可.</p><h3 id="Xcode中的代码结构与操作系统上的文件系统并不一致"><a href="#Xcode中的代码结构与操作系统上的文件系统并不一致" class="headerlink" title="Xcode中的代码结构与操作系统上的文件系统并不一致"></a>Xcode中的代码结构与操作系统上的文件系统并不一致</h3><p>推荐在Finder里建好目录再到Xcode的Project Navigator中点击“Add Files to”添加到项目中</p><h3 id="iPhone-5适配"><a href="#iPhone-5适配" class="headerlink" title="iPhone 5适配"></a>iPhone 5适配</h3><p>iPhone 5与之前的iPhone不一样，采用了4寸Retina屏，所以它的Point数变成了320 * 568 points</p><h3 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h3><ul><li><a href="https://developer.apple.com/library/ios/navigation/#section=Resource%20Types&topic=Sample%20Code">Apple官方的Sample Code</a></li><li><a href="http://en.wikipedia.org/wiki/List_of_free_and_open_source_iOS_applications">维基百科上的开源iOS App</a></li><li><a href="http://www.iosopensource.com/">iOS Opensource</a> –Domain Parking了，以前可以下载Twitter和Wordpress客户端的</li><li><a href="http://code4app.com/">code 4 app</a></li><li><a href="http://ui4app.com/">UI 4 app</a>， code4app的姐妹站</li></ul><h3 id="Objective-C教程"><a href="#Objective-C教程" class="headerlink" title="Objective-C教程"></a>Objective-C教程</h3><ul><li><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html">Apple官方教程</a></li><li><a href="http://cocoadevcentral.com/d/learn_objectivec/">Cocoa Dev Center</a></li><li><a href="http://zh.wikipedia.org/wiki/Objective-C">维基上的Objective-C语言简介</a> –中文，十分钟可读完，推荐</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/qinjx/30min_guides/blob/master/ios.md">https://github.com/qinjx/30min_guides/blob/master/ios.md</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生活和开发的一些良好建议</title>
    <link href="/2019-01-02-life-tips-awesome/"/>
    <url>/2019-01-02-life-tips-awesome/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.一个浪头打过来，最好的办法是迎上去了解个究竟，而不是漠视，或者干脆当事情没有发生。</p><p>2.记住这个教训：别猜，去问！去查！</p><p>3.隔一段时间重顾知识是记忆的关键方法。不要一次性学完一项知识就不管了，这样你无法真正的掌握。隔一段时间回顾一下，每次重复，你都会加深自己的<br>理解，次数多了，你就会理解每个细节，成为真正的专家。</p><span id="more"></span><p>4.对于一个技术通常我们需要抱有这样的疑问</p><p>它是什么 一句话概括<br>解决了什么问题 存在的意义<br>怎样去使用它<br>怎样解决了问题 内部的实现<br>它的缺点是什么 多角度分析</p><p>5.高效率的学习方法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">理清楚概念很重要<br>做好控制变量法<br>多动手实践，与理论结合<br>抓住重点，剔除干扰因素<br><br></code></pre></td></tr></table></figure><p>6.关于如何选择第三方库</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">确定这个库是否是必需的<br>这个库能否带来开发效率的提升，降低代码的维护成本<br>这个库的学习成本如何 比如rxjava其实学习成本会相对高一些。<br>这个库的质量如何，不要仅仅看<span class="hljs-keyword">star</span>，更要看issue的处理情况。<br></code></pre></td></tr></table></figure><p>7.怎样练习算法题？</p><p>每道算法题都先自己去实现，先写思路，然后自己去实现一遍，然后再看看答案，记住答案的思路，第二天再重新按照答案的思路实现一遍。</p><p>8.”另类”的学习方法</p><p>抄书的奥妙——那就是延缓阅读速度，不至遗漏每一个重要的细节：眼到，手到，心到，其实不仅书抄得，代码(优秀源码)也抄得。</p><p>9.建议：建立逐字稿</p><p>计算机网络相关的逐字稿<br>计算机操作系统相关的逐字稿<br>数据库相关的逐字稿<br>设计模式相关的逐字稿<br>数据结构与算法相关的逐字稿<br>Java知识相关的逐字稿<br>Kotlin知识相关的逐字稿<br>Python知识相关的逐字稿<br>React Native知识相关的逐字稿<br>Flutter知识相关的逐字稿<br>小程序知识相关的逐字稿<br>JS知识相关的逐字稿<br>Android知识相关的逐字稿<br>与技术无关的逐字稿</p><p>10.如何提升你的阅读能力？</p><p>只字不差的反复阅读<br>真正的获取知识，是通过阅读，深入思考与践行</p><p>11.如何高效阅读一篇文章？</p><p>由主题扩展为知识树<br>尝试描述<br>尝试记忆</p><p>12.如何阅读源码？</p><p>准备：<br>Java设计模式(模板方法，单例，观察者，工厂方法，代理，策略，装饰者)，<br>Java高级相关<br>熟练掌握这个库<br>先Google了解软件的整体架构设计<br>搭建系统，把源码跑起来</p><p>开始阅读：<br>根据你对系统的理解，设计几个主要的测试案例，定义好输入，输出。(Debug一遍肯定是不行的，需要Debug很多遍)<br>第一篇抛弃细节，抓住主要流程，第二篇，第三篇，再去看各个部分的细节。<br>阅读的时候同时使用UML画出系统的类图。<br>主要的测试案例明白了，丰富测试案例，考虑一些分支。<br>这一步会非常非常地花费时间，但是你做完了，对系统的理解绝对有质的飞跃。</p><p>13.想象一个来自未来的自己，他非常自信，非常成功，<br>拥有你现在所希望的一切，他会对现在的你说些什么？<br>他怎么说，你就怎么去做，10年之后，你就变成了他。</p><p>14.重视实践，充分运用感性认知潜能，在项目中磨炼自<br>己，才是正确的学习之道。在实践中，在某些关键动作<br>上刻意练习，也会取得事半功倍的效果。</p><p>15.我们需要从别人身上学习。从老师、领导、同事、<br>下属甚至对手身上学习，是快速成长的重要手段。</p><p>16.多多总结，多多分享，善莫大焉。</p><p>17.解答别人的问题也是个人成长的重要手段。有时候，<br>某个问题自己本来不太懂，但是在给别人讲解的时候却<br>豁然开朗。所以，“诲人不倦”利人惠己。</p><p>18.学习计划最好能结合工作计划，理论联系实际结合，快速学以致用。</p><p>19.良好的用人方式应该如下：</p><p>首选选择相信，在面临失败后，收缩信任度。</p><p>查找失败的原因，提供改进意见，提升下属的能力。</p><p>总是给下属机会，在恰当地时机给下属更高的挑战。 总之，苍天大树来自一颗小种子，要相信成长的力量。</p><p>20.学习就是不断地刻意联系，刻意练习，就是有目的的练习，先规划好，<br>再去练习。首先给自己定一个目标，目标可以有效的引导你学习，然后使<br>用3F练习法：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>： 专注（Focus），专注在眼前的任务上，在学习过程中保持专注，可以尝试使用番茄工作法。<br><br><span class="hljs-number">2</span>：反馈（Feedback），意识到自己的不足，学习完之后进行反思，思考下自己哪些方面不足，为什么不足，<br><br><span class="hljs-number">3</span>： 修正（<span class="hljs-keyword">Fix</span>），改进自己的不足。<br></code></pre></td></tr></table></figure><p>不停的练习和思考可以改变大脑结构，大脑像肌肉一样，挑战越大，影响越大，学习更高效，并且也会产生突破性。</p><p>21.写一篇博客的过程，其实就是对一件事情，学习、理解、思考、转化，最终输出成一篇博客的过程。</p><p>22.深入浅出SQL给出的学习法则：</p><p>如何快速记忆知识？<br>将文字转换为图片（将文字嵌入图片效果比较好)，如果能转换为令人惊奇，有趣的情景模拟，那么可以让你的大脑意识到这是重要的东西，记忆效果会更好。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs">1.慢慢来，理解越多，需要强记得就越少。<br><br>2.勤做笔记，写下你的心得笔记。<br><br>3.你的大脑会需要一段时间来消化新知识，如果之后再学别的知识，会使之前的记忆效果减弱，因此，在睡前看最重要的知识。<br><br>4.喝水，多喝水。<br><br>5.大声说出你想要记忆的知识，如果能与别人进行一问一答则效果更佳。<br><br>6.当学习知识时，达到了漫不经心或过目即忘的状态，则应该让大脑好好休息。<br><br>7.用心感受，让你的大脑知道这很重要，将学习的内容尽量以情景化+惊奇+幽默的形式展示出来。<br><br>8.用学到的知识解决实际的难题（真实的情景演练）。<br><br></code></pre></td></tr></table></figure><p>23.想要学习新技术，想要提升自己，不是看见新技术就去学，沉下心来认真钻研才行，吃透它，不再为缓解焦虑而学习。</p><p>24.业务代码一样很牛逼</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.使用封装和抽象可以使业务代码更具扩展性。<br><span class="hljs-attribute">2</span>.多和产品交流以便更好地理解和实现业务。<br><span class="hljs-attribute">3</span>.日志记录好了问题定位效率可以提升<span class="hljs-number">10</span>倍。<br></code></pre></td></tr></table></figure><p>25.在工作中学习、实战提升是效果最好的，其余时间可有目的去碎片化学习<br>一整块知识，也可以快速构建牢固的知识体系。</p><p>26.三做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift">做更多：<br>工作中熟悉多个业务代码，端到端（前后端）的业务代码，自学<span class="hljs-operator">。</span><br><br>做更好：<br><span class="hljs-number">1</span>.提升项目稳定性，引进单元测试和<span class="hljs-type">UI测试</span><span class="hljs-operator">。</span><br><span class="hljs-number">2</span>.重构解耦项目<span class="hljs-operator">。</span><br><span class="hljs-number">3</span>.性能优化<span class="hljs-operator">。</span><br><span class="hljs-number">4</span>.设计模式去除重复代码<span class="hljs-operator">。</span><br><br>做练习：<br><span class="hljs-number">1</span>.学习<br><span class="hljs-number">2</span>.尝试<br><span class="hljs-number">3</span>.教学<br></code></pre></td></tr></table></figure><p>27.一项新技术的出现，应该先去了解它，看它是否对自身的技术成长有比较大的帮助，有的话按优先级加入计划表</p><p>28.重复记忆时间间隔：1小时、早上&#x2F;晚上、1天、3天、7天、1个月、3个月形成长期记忆~</p><p>29.学习一个新的知识点的流程：<br>what、why、how、原理&#x2F;源码、优缺点~<br>注意”先主后从“原则，多实践加深理解。</p><p>&#x3D;&#x3D;&#x3D;&#x3D; 告诉我自己 &#x3D;&#x3D;&#x3D;&#x3D;</p><p>30.对自己狠一点</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jsonchao.github.io/2018/04/22/Some%20awesome%20tips/">https://jsonchao.github.io/2018/04/22/Some%20awesome%20tips/</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长之路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结2018展望2019</title>
    <link href="/2018-12-31-life-summary-2018/"/>
    <url>/2018-12-31-life-summary-2018/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是2018年12月31日，2018年的最后一天，做个年终总结，再来个2019Flags。</p><span id="more"></span><h2 id="回顾2018"><a href="#回顾2018" class="headerlink" title="回顾2018"></a>回顾2018</h2><p>这一年来的匆匆，走的匆匆，努力了才会留下些什么。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>今年，感谢大宝贝婷子陪我走，并一路走来，感谢她给予的爱和关怀。因为她的可爱和活泼，我们的生活有很多乐趣；因为她的睿智和耐心，我认识到自己很多不足的地方；因为她的督促和鞭策，我努力改变自己、完善自己，让一个更好的自己陪在她身边。</p><p>平日里，我多数时间用在代码上、项目里，很容易忽略她的感受，对于这一点我比较自责。有时我能陪她聊会天、走一走，她都会很开心，吃东西她也希望我们一人一半，所以说她是个可爱也知足的女孩，我很喜欢很爱她。</p><p>也许像别人说的本命年，会有一劫吧，家里也发生了一些事情，好在一家人同心协力，难关走了过去。</p><p>明白了一些做人的道理，人外有人天外有天，要保持一颗谦卑的心；好多时候好多事情做之前要让别人理解，因为不是我们一个人。</p><p>记一些琐碎的事情，5月份：</p><ul><li>帮朋友忙，朋友请吃牛排，这是婷子第一次说喜欢牛排</li><li>在华元发现一家酸菜鱼面馆，之后和婷子经常去</li><li>婷子这么爱吃，却仍然保持着魔鬼般的身材</li><li>我开始健身，并坚持了一个多月</li></ul><p><img src="https://blogres.blackist.org/life-yuti-IMG_1666%2820181231-113156%29.jpg"></p><p>6月份：</p><ul><li>在学校遇到一个巴基斯坦哥们，了解了穆斯林月</li><li>和婷子去工商食堂吃饭，看到了可爱的HelloKitty主题食堂</li><li>修好了婷子的小蓝车，开始两个人在晴天一起骑车去学校</li><li>在和达成抓到了好多娃娃</li><li>我把实验室的冰箱彻底收拾了一遍，可以称为造福人类的举动</li><li>抓到了大猪佩奇，把抓到的好多小娃娃封箱</li><li>2号楼乒乓球桌被搬走之后好久没打球，在15号楼发现一个乒乓球台，和婷子去玩，结果婷子自己背靠墙等我，我跟别人在玩</li><li>开始在实验室煮东西吃</li><li>看了雷哥的超时空恋爱</li><li>开始关注世界杯</li><li>第一次收到交通罚单，因为骑车载人</li></ul><p><img src="https://blogres.blackist.org/life-yuti-0181231115311.jpg"></p><p>7月份：</p><ul><li>带婷子去弗雷德买个条长裙，很好看</li><li>我嫂子准备自己去苏州打工，我让朋友接待了，一天折腾下来直接回家啦，哈哈</li><li>在实验室煮面条、煮菜粥</li><li>程咬金拿五杀</li><li>和大海去25号楼拍晚霞</li><li>开始和婷子去学校游泳馆游泳</li><li>婷子搬进研究生寝室楼</li><li>我急性肠胃炎，婷子陪我去医院，感谢婷子不嫌弃的陪伴</li><li>婷子开始健身，为了暑假回家可以受一点，每天做一次平板支撑</li><li>向青从老家来杭州看婷子，俩人整天形影不离的，我都羡慕了</li><li>婷子第一次单手骑车，一只手拿太阳伞</li><li>经历了杭州的大雨，整个下沙一片水世界</li></ul><p><img src="https://blogres.blackist.org/life-yuti-IMG_1668%28201.jpg"></p><p>8月份：</p><ul><li>和婷子一起做了小猪佩奇的“纹身”</li><li>买了件透明雨衣，婷子第一次穿雨衣很开心</li><li>上钻石段位</li><li>婷子从研究生寝室楼搬回10号楼</li><li>婷子回老家</li><li>我回老家考驾照科目三</li><li>回到家，吃了好久没吃的老妈做的饭</li><li>送我侄子去汉城国际上小学</li></ul><p><img src="https://blogres.blackist.org/life-yuti-02D126C4784F3151C58F36BE2AC172C1.jpg"></p><p>9月份：</p><ul><li>回到学校</li><li>和婷子去吃素食餐厅</li><li>实验室新生都来了</li><li>给婷子搞了一个书架放在实验室，很实用</li><li>实验室去真味馆聚餐</li><li>四人行学期总结</li><li>我学习vue，用在了时时刻刻项目里</li><li>婷子开始学习ios，做智能家居客户端开发</li><li>和婷子去图书馆找ios开发的书</li><li>参加点赞送书活动，拿到了SpringCloud书</li></ul><p><img src="https://blogres.blackist.org/life-yuti-F01C2F8D164FB7D0AF88B2ECDCADBCDA.png"></p><p>10月份：</p><ul><li>国庆节和婷子去南京玩</li><li>去南京博物馆、玄武湖、夫子庙、1865创意管、达摩洞、长江</li><li>去奥特莱斯买大衣</li><li>和徐兴去钱塘江看潮，最后和婷子小窦昊五人一起去吃晚饭</li><li>大气突然很冷，给侄子买衣服，婷子帮忙选的</li><li>婷子送我一个ikbc的机械键盘</li><li>参加Kylin开源项目线下沙龙杭州站讲座</li></ul><p><img src="https://blogres.blackist.org/life-yuti-DF2C2A34AAC4E1D50B36A09FE7856E0D.png"></p><p>11月份：</p><ul><li>买了一副锤子耳钉，程序媛的风格</li><li>跟婷子去工商，和小窦昊、老黄一起吃饭</li><li>去华元看毒液</li><li>婷子考软件评测师</li><li>瓜皮过生日，在寝室吃了吃蛋糕，等老唐和小柳柳一直没回来，我们先吃了。这才知道我和瓜皮生日仅隔一天</li><li>送婷子去阿姨家，来回46站路，就花了两块钱；婷子在阿姨家很开心，还谈婚论嫁的，一顿紧张</li><li>惹婷子不开心，哭了一大晚上，第二天去工商找小窦昊散散心，发现了一个心理咨询室，嗓子都喊哑了</li><li>学林街的枫树都红了</li><li>把婷子的宿舍彻底收拾了一边</li><li>向青给婷子买了小包包做生日礼物，大大的金链子，贼耀眼；话说拍完买家秀就没背过了</li><li>芳芳、林妹妹都给瑜婷寄来了生日礼物</li></ul><p><img src="https://blogres.yuti.site/yuti-birthday-24-%E5%90%91%E9%9D%92%E5%8C%85%E5%8C%85.jpg"></p><p>12月份：</p><ul><li>给婷子过生日，和梦琳、小颖、博威在和达成吃火锅</li><li>迎来2018杭州第一场雪，带上了粉色的耳套子，暖和最重要</li><li>发现一个60多岁的程序员老大爷，做Android开发的</li><li>学校一区食堂举办了美食大赛</li><li>裸考六级</li><li>婷子拿到软件评测师证书</li><li>冬至和婷子在食堂吃水饺，晚上和实验室同学聚餐，第一次喝江小白</li><li>圣诞节，Coding举办彩蛋兑换奖品活动，其他也就没啥了</li><li>集齐1.98个码币，换了一只Coding猴子</li></ul><p><img src="https://blogres.blackist.org/life-yuti-00E55B447F20192C1C155DC16631EEBB.png"></p><p>这是一年中我还没遗忘，能够记录下来的事情。好多事情让我成长、明白了一些道理，也更明确生活需要努力，未来并不遥远–就是现在，为了让明天的我感谢今天的自己，用心生活。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>主要还是学习开发方面的东西，涉及到Android、Vue、Nodejs、微信小程序、SpringBoot，开始学习一些简单的算法，认真写博客。</p><p>Android：</p><ul><li>WakefulBroadcastReceiver结合IntentService做长连接心跳机制</li><li>可视对讲中音视频卡顿优化，视频帧处理</li><li>Android7.0源码阅读和修改，定制SystemUI、系统预装等</li><li>入门RxJava，但不怎么用还是生疏了</li><li>入门模块化开发，研究组件间通信、主题统一、MVP</li><li>提交开源组件化开发项目<a href="https://github.com/blackist/modulize">Modulize</a></li><li>编写组件间通信工具<a href="https://github.com/blackist/BRouter">BRouter</a>，发布到jcenter，可通过gradle 来导入</li><li>研究Fragment在Activity中的出入栈管理</li></ul><p>Vue：</p><ul><li>Vue入门语法、实践</li><li>vue-router的使用</li><li>axios网络访问框架</li></ul><p>Nodejs：</p><ul><li>Koa路由框架</li><li>数据库框架Sequelize</li><li>开源脚手架项目<a href="https://github.com/blackist/node-koa-restful">node-koa-restful</a>，可以快速搭建一个后台接口服务</li><li>基于脚手架项目，大家极光、小米推送后台服务</li></ul><p>微信小程序：</p><ul><li>基于vue学习mvvue框架开发小程序，但没有实战项目，浅尝辄止</li></ul><p>SpringBoot：</p><ul><li>SpringBoot入门</li></ul><p>RxJava以及Kotlin对于Java开发是很重要，一直列在TODO list上却没有执行，模块化开的几篇笔记还没有完成，SPringBoot系列框架还没有熟悉，SpringBoot脚手架还没有搭建。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>今年主要在做三个项目，智能门禁以及客户端项目(Android)、时时刻刻课程系统项目(Vue)、智慧宿管平台项目(Android+Spring)，感受比较深的就是需要做好团队内的沟通工作，大家一起向着一个目标努力。</p><p>因为智能家居项目，去贵州出差过，但项目发展中遇到一些问题，还没有正式上线，对于做开发的我来说缺乏一些鼓励。做项目需要做好需求分析以及目标管理，项目的实施和落地才是最好的动力。</p><h2 id="展望2019"><a href="#展望2019" class="headerlink" title="展望2019"></a>展望2019</h2><p>2019是亥猪年，也就是我的本命年，兴许我也会遇到自己的“一劫”，我不会畏惧，反而要勇敢的面对，不能把后背留给“敌人”–困难。把问题清楚地写下来，问题就解决一半了，我能想到的问题：</p><ul><li>发一级期刊小论文</li><li>找工作、面试</li><li>职业方向选择</li></ul><p>我现在不知道论文怎么写的，论文怎么发的，更不知道一级期刊长什么样子；就业方面我打算留在杭州，从事Android开发还是Java后端开发是我在思考的一个问题。</p><p>2019年，我将围绕这些困扰我的问题来做事情，</p><ul><li>做好论文研究，为一级期刊小论文打基础</li><li>研究、学习算法，刷牛客网、leetcode关于java的算法题，为找工作做准备</li><li>深入学习RxJava、JVM基础知识、Java8&amp;java9新特性、</li><li>Kotlin入门并深入，写个小app或在modulize中使用</li><li>SpringBoot系列框架入门、脚手架项目搭建、项目管理工入门(SpringBoot、JPA、Swagger、Jenkins、Sonar)</li><li>Docker容器技术入门</li><li>定期阅读阮一峰老师的博客</li><li>关注并参与GoogleIO 2019，多关注Android开发者大会，做一个合格的Androider</li><li>六级必过</li><li>驾照到手</li></ul><p>有人说，最好的爱情就是两个人共同成长，听起来似乎有点难度，细想来，两个人一起学习相互督促不正是所说的最好的爱情吗？!正如婷子现在在做英语阅读，我在做年终总结一样。</p><p>婷子也有自己的Flags，为她贴在这里</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">少吃辣<br>多读书<br>多睡觉<br></code></pre></td></tr></table></figure><p>不愧是个小可爱的目标，都是为了成就美美的自己，嘿嘿嘿。</p><p>2019，扬帆起航。</p><p>元旦快乐！！！</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>年终总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长之路</tag>
      
      <tag>2018</tag>
      
      <tag>2019</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本编程30分钟入门</title>
    <link href="/2018-12-29-linux-shell-script/"/>
    <url>/2018-12-29-linux-shell-script/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>看个例子吧：</p><span id="more"></span><pre><code class="hljs">#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do    touch test_$i.txtdone</code></pre><h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><ul><li>第1行：指定脚本解释器，这里是用&#x2F;bin&#x2F;sh做解释器的</li><li>第2行：切换到当前用户的home目录</li><li>第3行：创建一个目录shell_tut</li><li>第4行：切换到shell_tut目录</li><li>第5行：循环条件，一共循环10次</li><li>第6行：创建一个test_0…9.txt文件</li><li>第7行：循环体结束</li></ul><p>mkdir, touch都是系统自带的程序，一般在&#x2F;bin或者&#x2F;usr&#x2F;bin目录下。for, do, done是sh脚本语言的关键字。</p><h3 id="shell和shell脚本的概念"><a href="#shell和shell脚本的概念" class="headerlink" title="shell和shell脚本的概念"></a>shell和shell脚本的概念</h3><p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p><p>shell脚本（shell script），是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux默认安装就带了shell解释器。</p><h4 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h4><p>Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</p><h4 id="Windows上的模拟器"><a href="#Windows上的模拟器" class="headerlink" title="Windows上的模拟器"></a>Windows上的模拟器</h4><p>windows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。</p><ul><li><a href="http://www.cygwin.com/">cygwin</a></li><li><a href="http://www.mingw.org/">mingw</a></li></ul><h3 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h3><h4 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h4><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是&#x2F;bin&#x2F;sh，由Bell Labs开发。</p><p>本文讲的是sh，如果你使用其它语言用作shell编程，请自行参考相应语言的文档。</p><h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是&#x2F;bin&#x2F;bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p><p>在CentOS里，&#x2F;bin&#x2F;sh是一个指向&#x2F;bin&#x2F;bash的符号链接:</p><pre><code class="hljs">[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dashlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash</code></pre><p>但在Mac OS上不是，&#x2F;bin&#x2F;sh和&#x2F;bin&#x2F;bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p><pre><code class="hljs">iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h4 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h4><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p><p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（&#x2F;bin&#x2F;csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p><p>如下是一个PHP Shell Script示例（假设文件名叫test.php）：</p><pre><code class="hljs">#!/usr/bin/php&lt;?phpfor ($i=0; $i &lt; 10; $i++)        echo $i . &quot;\n&quot;;</code></pre><p>执行：</p><pre><code class="hljs">/usr/bin/php test.php</code></pre><p>或者：</p><pre><code class="hljs">chmod +x test.php./test.php</code></pre><h2 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h2><h3 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h3><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p><p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p><h3 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h3><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p><p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p><ul><li>它的函数只能返回字串，无法返回数组</li><li>它不支持面向对象，你无法实现一些优雅的设计模式</li><li>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</li></ul><h3 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h3><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p><h2 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h2><h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><p>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。</p><p>输入一些代码，第一行一般是这样：</p><pre><code class="hljs">#!/bin/bash#!/usr/bin/php</code></pre><p>“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行Shell脚本有两种方法：</p><h4 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h4><pre><code class="hljs">chmod +x test.sh./test.sh</code></pre><p>注意，一定要写成.&#x2F;test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用.&#x2F;test.sh告诉系统说，就在当前目录找。</p><p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p><p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用&#x2F;bin&#x2F;sh作为解释器的脚本是不是可以省去第一行呢？是的。</p><h4 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h4><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p><pre><code class="hljs">/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量时，变量名不加美元符号（$），如：</p><pre><code class="hljs">your_name=&quot;qinjx&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</p><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code class="hljs">for file in `ls /etc`</code></pre><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code class="hljs">your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125;</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code class="hljs">for skill in Ada Coffe Action Java; do    echo &quot;I am good at $&#123;skill&#125;Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。</p><h3 id="重定义变量"><a href="#重定义变量" class="headerlink" title="重定义变量"></a>重定义变量</h3><p>已定义的变量，可以被重新定义，如：</p><pre><code class="hljs">your_name=&quot;qinjx&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name&#x3D;”alibaba”，使用变量的时候才加美元符。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>以“#”开头的行就是注释，会被解释器忽略。</p><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>sh里没有多行注释，只能每一行加一个#号。就像这样：</p><pre><code class="hljs">#--------------------------------------------# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：https://github.com/webfrogs/xcode_shell/blob/master/ipa-build# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包# 特色：全自动打包，不需要输入任何参数#--------------------------------------------##### 用户配置区 开始 ######## 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了# 应用名，确保和Xcode里Product下的target_name.app名字一致###### 用户配置区 结束  #####</code></pre><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><pre><code class="hljs">str=&#39;this is a string&#39;</code></pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li></ul><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><pre><code class="hljs">your_name=&#39;qinjx&#39;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><pre><code class="hljs">your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting $greeting_1</code></pre><h4 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h4><pre><code class="hljs">string=&quot;abcd&quot;echo $</code></pre>]]></content>
    
    
    <categories>
      
      <category>OPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fragment与Activity管理之出入栈、点击事件穿透</title>
    <link href="/2018-12-28-android-fragment-manage/"/>
    <url>/2018-12-28-android-fragment-manage/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单Activity管理多个Fragment进行界面展示、页面跳转是很常见的界面编程方式，Fragment在使用时有一些使用技巧和“坑人”的地方，本文进行总结与分享。</p><span id="more"></span><h2 id="Activity管理Fragment"><a href="#Activity管理Fragment" class="headerlink" title="Activity管理Fragment"></a>Activity管理Fragment</h2><p>Activity控制Fragment的展示、布局。</p><h3 id="Fragment的展示和切换-出入栈"><a href="#Fragment的展示和切换-出入栈" class="headerlink" title="Fragment的展示和切换(出入栈)"></a>Fragment的展示和切换(出入栈)</h3><p>通过FragmentManager管理Fragment出入栈，建议为每个Fragment定义一个tag(字符串常量)，方便Fragment管理、Activity与Fragment通信，FragmentManager管理Fragment核心代码如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG_LEAVE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;tag_leave&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG_LEAVE_APPLY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;tag_leave_apply&quot;</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">navigateToTargetFragment</span><span class="hljs-params">(String tag, Bundle param)</span> &#123;<br>    <span class="hljs-comment">// get fragment</span><br>    BaseFragment targetFragment;<br>    <span class="hljs-comment">// 根据tag加载指定的fragment，假定每种fragment只有一个实例存在栈中</span><br>    <span class="hljs-keyword">if</span> (TAG_LEAVE.equals(tag)) &#123;<br>        <span class="hljs-keyword">if</span> (leaveFragment == <span class="hljs-literal">null</span>) &#123;<br>            leaveFragment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeaveFragment</span>();<br>        &#125;<br>        targetFragment = leaveFragment;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_LEAVE_APPLY.equals(tag)) &#123;<br>        <span class="hljs-keyword">if</span> (leaveApplyFragment == <span class="hljs-literal">null</span>) &#123;<br>            leaveApplyFragment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeaveApplyFragment</span>();<br>        &#125;<br>        targetFragment = leaveApplyFragment;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (leaveFragment == <span class="hljs-literal">null</span>) &#123;<br>            leaveFragment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeaveFragment</span>();<br>        &#125;<br>        targetFragment = leaveFragment;<br>        tag = TAG_LEAVE;<br>    &#125;<br>    <span class="hljs-comment">// check whether fragment is showing.</span><br>    <span class="hljs-keyword">if</span> (targetFragment == <span class="hljs-literal">null</span> || targetFragment.isVisible() || targetFragment.isAdded()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 刷新界面，比如activity的titleBar</span><br>    displayLayout(tag);<br>    <span class="hljs-comment">// 设置Fragment参数</span><br>    <span class="hljs-keyword">if</span> (param != <span class="hljs-literal">null</span>) &#123;<br>        targetFragment.setArguments(param);<br>    &#125;<br>    <span class="hljs-comment">// 如果FrameLayout为空则用replace方法添加Fragment，</span><br>    <span class="hljs-comment">// FrameLayout不为空，直接添加Fragment(注意设置Fragment背景为不透明，如?android:windowBackground)</span><br>    <span class="hljs-comment">// 添加Fragment设置tag、压入栈中</span><br>    <span class="hljs-keyword">if</span> (currentFragment == <span class="hljs-literal">null</span>) &#123;<br>        fragmentManager.beginTransaction()<br>                .replace(R.id.fragment_container, targetFragment, tag)<br>                .addToBackStack(tag)<br>                .commit();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fragmentManager.beginTransaction()<br>                .add(R.id.fragment_container, targetFragment, tag)<br>                .addToBackStack(tag)<br>                .commit();<br>    &#125;<br>    currentFragment = targetFragment;<br>    fragmentTag = tag;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据tag设置当前界面UI，通常是设置Activity标题栏</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayLayout</span><span class="hljs-params">(String tag)</span> &#123;<br>    setCommonRightIcon(R.drawable.common_transparent);<br>    <span class="hljs-keyword">switch</span> (tag) &#123;<br>        <span class="hljs-keyword">case</span> TAG_LEAVE: &#123;<br>            <span class="hljs-comment">//设置titleBar标题栏</span><br>            setCommonTitle(R.string.room_leave_resign_manage);<br>            <span class="hljs-comment">// 设置titleBar右上角图标点击事件</span><br>            setCommonRightIcon(R.drawable.action_bar_add);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> TAG_LEAVE_APPLY: &#123;<br>            setCommonTitle(R.string.room_leave_apply);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上是Activity添加Fragment到当前界面，并在Fragment入栈时设置Activity UI。</p><p>通常情况下，当用户点击返回键(物理返回键、界面虚拟返回键)时，需要返回到上一个Activity而不是直接FinishActivity，而Fragment无法直接拦截物理返回键点击事件，因此需要通过宿主Activity来管理Fragment的出栈。核心代码在Activity，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBackPressed</span><span class="hljs-params">()</span> &#123;<br>    backFragment();<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backFragment</span><span class="hljs-params">()</span> &#123;<br>    fragmentManager.popBackStackImmediate();<br>    <span class="hljs-keyword">if</span> (fragmentManager.getBackStackEntryCount() == <span class="hljs-number">0</span>) &#123;<br>        finish();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fragmentTag = fragmentManager.getFragments().get(fragmentManager.getBackStackEntryCount() - <span class="hljs-number">1</span>).getTag();<br>        displayLayout(fragmentTag);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Fragment通信"><a href="#Fragment通信" class="headerlink" title="Fragment通信"></a>Fragment通信</h2><p>Fragment和Activity通信、Fragment之间通信(例如左右布局)</p><h3 id="Fragment和Activity通信"><a href="#Fragment和Activity通信" class="headerlink" title="Fragment和Activity通信"></a>Fragment和Activity通信</h3><ul><li>通过接口回调实现Fragment向Activity的通信，宿主Activity实现通信接口，Fragment调用FragmentEvent的Activity实例传递事件和参数。通信接口类如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FragmentEvent</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Fragment communicate with activity with FragmentEvent listener.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> event  event event</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> param event param</span><br><span class="hljs-comment">     */</span><br>    Object <span class="hljs-title function_">onFragmentEvent</span><span class="hljs-params">(String event, Object param)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Activity实现接口，Fragment获取实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeaveActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FragmentEvent</span> &#123;<br>  ...<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">onFragmentEvent</span><span class="hljs-params">(String event, Object param)</span> &#123;<br>      <span class="hljs-keyword">if</span> (CommonUtil.isEmpty(event)) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">switch</span> (event) &#123;<br>          <span class="hljs-keyword">case</span> TAG_LEAVE_DETAIL: &#123;<br>              <span class="hljs-type">Bundle</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>              params.putLong(LeaveDetailFragment.PARAM_LEAVE_ID, (Long) param);<br>              navigateToTargetFragment(TAG_LEAVE_DETAIL, params);<br>          &#125;<br>          <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">case</span> TITLE_TAG: &#123;<br>              fragmentTag = param.toString();<br>              displayLayout(fragmentTag);<br>          &#125;<br>          <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">case</span> BACK_TAG: &#123;<br>              backFragment();<br>          &#125;<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  ...<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在BaseFragment中onAttatch()及以后的生命周期方法皆可获取实例Fragment实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (getActivity() <span class="hljs-keyword">instanceof</span> FragmentEvent) &#123;<br>    <span class="hljs-built_in">this</span>.mFragmentEvent = (FragmentEvent) getActivity();<br>&#125;<br><br><span class="hljs-comment">// Fragment中通过接口实例和Activity通信</span><br>mFragmentEvent.onFragmentEvent(BACK_TAG, <span class="hljs-literal">null</span>);<br><br></code></pre></td></tr></table></figure><ul><li>通过广播，在Activity中注册广播，Fragment发送广播；</li></ul><h3 id="Activity向Fragment通信"><a href="#Activity向Fragment通信" class="headerlink" title="Activity向Fragment通信"></a>Activity向Fragment通信</h3><ul><li><p>通过fragmet的setArguments()方法，在fragment初始化的时候传递参数和事件；</p></li><li><p>Fragment中定义public方法，通过Activity中的fragment实例调用；</p></li><li><p>通过EventBus在activity中向fragment传递事；</p></li></ul><h3 id="Fragment之间通信"><a href="#Fragment之间通信" class="headerlink" title="Fragment之间通信"></a>Fragment之间通信</h3><ul><li><p>通过fragment的public方法，首先fragmentA通过getActivity().getFragmentManager().getFragment…()获取到fragmentB，然后调用fragmentB的public方法，比较繁琐。</p></li><li><p>使用接口（推荐），首先如上通过接口实现fragment向activity的通信，其次通过public方法实现activity向Fragment的通信，从而间接实现Fragment之间的通信。</p></li><li><p>使用setTargetFragment()、onActivityResult()、getTargetFragment()进行fragment间的通信</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">FragmentA &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span>&#123;<br>setTargetFragment(fargmentB, ...);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode, <span class="hljs-type">int</span> resultCode, Intent data)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onActivityResult(requestCode, resultCode, data);<br>...<br>    &#125;<br>&#125;<br><br>FragmentB &#123;<br>getTargetFragment().onActivityResult(requestCode, resultCode, Intent data);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Fragment一些坑点"><a href="#Fragment一些坑点" class="headerlink" title="Fragment一些坑点"></a>Fragment一些坑点</h2><h3 id="Fragment点击事件穿透"><a href="#Fragment点击事件穿透" class="headerlink" title="Fragment点击事件穿透"></a>Fragment点击事件穿透</h3><p>Fragment入栈后若没有被hide，上层Fragment的点击事件会被下发到下一层，通过拦截点击事件消除此影响。<br>在BaseFragment中为rootView设置点击属性，消化掉此层的点击事件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, <span class="hljs-meta">@Nullable</span> ViewGroup container, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-keyword">if</span> (rootView == <span class="hljs-literal">null</span>) &#123;<br>        rootView = inflater.inflate(<span class="hljs-built_in">this</span>.getLayoutResId(), container, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rootView.getParent() != <span class="hljs-literal">null</span>) &#123;<br>        ((ViewGroup) rootView.getParent()).removeView(rootView);<br>    &#125;<br><span class="hljs-comment">// preventing click penetration</span><br>rootView.setClickable(<span class="hljs-literal">true</span>);<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>参考</p><p><a href="https://blog.csdn.net/u012881042/article/details/51798736">https://blog.csdn.net/u012881042/article/details/51798736</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java算法笔记</title>
    <link href="/2018-12-25-java-arithmetic/"/>
    <url>/2018-12-25-java-arithmetic/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算法和编程思想是程序员的内功，2019开启修炼旅程。学习算法的代码和笔记放在Github上<a href="https://github.com/blackist/coding-sword">https://github.com/blackist/coding-sword</a>。</p><p>学习的计划如下：</p><ul><li>1月-2月，学习、思考、实践、总结<a href="">剑指Offer</a>系列算法；</li><li>3月，开启<a href="https://leetcode.com/">leetcode</a>系列算法；</li><li>4月-5月，开启<a href="">牛客网</a>、<a href="https://github.com/JsonChao/Awesome-Android-Interview">JsonChao的笔记</a>系列面试题；</li></ul><span id="more"></span><h2 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h2><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Yuti生日快乐</title>
    <link href="/2018-11-30-life-yuti-birthday-24/"/>
    <url>/2018-11-30-life-yuti-birthday-24/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Yuti大姑娘24岁了，生日快乐！！！</p><span id="more"></span><p>被人惦记，Yuti会快乐。</p><p><img src="https://blogres.yuti.site/yuti-birthday-24.jpg"></p><p>收到最好的朋友的礼物，整个人都飞了。</p><p><img src="https://blogres.yuti.site/yuti-birthday-24-%E5%90%91%E9%9D%92%E5%8C%85%E5%8C%85.jpg"></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长之路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDE快速搭建</title>
    <link href="/2018-11-08-dev-ide-licenses/"/>
    <url>/2018-11-08-dev-ide-licenses/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>整理开发集成环境工具等破解文件。</p><span id="more"></span><h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3><hr><ul><li>spket<br><a href="https://blogres.blackist.org/dev-ide-license-eclipse-spket.zip">Spket</a> 及其 <a href="https://github.com/DIRACGrid/WebAppDIRAC/wiki/How-to-setup-Eclipse-for-developing-ExtJs">配置方法</a></li></ul><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>License</tag>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解SpringMVC在JavaWeb应用的基本原理</title>
    <link href="/2018-11-06-javaweb-springmvc-dispatcher/"/>
    <url>/2018-11-06-javaweb-springmvc-dispatcher/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringMVC在JavaWeb中应用很广，处理前台、接请求并返回页面、数据，本文尝试理解SpringMVC在web应用中的工作流程。</p><span id="more"></span><p>假定我们建立测试项目WGS、使用Tomcat8.0作为我们的调试服务器，我们将web应用程序WGS部署到Tomcat的webapps目录，如图：</p><p><img src="https://blogres.blackist.org/spring-springmvc-webxml-spring-springmvc-webxml-tomcat-webapps.png"></p><p>Tomcat目录下有其内置的其它应用模块，每个应用的下的目录结构相似，下面是WGS的应用结构</p><p><img src="https://blogres.blackist.org/spring-springmvc-webxml-app-wgs.png"></p><p>WEB-INF下是应用程序的核心代码，其中web.xml文件是整个Web应用的部署文件和工程加载文件(web.xml不是Web应用必须的配置文件，但在基于jsp开发的动态网站应用中，web.xml几乎无处不在)。</p><p><img src="https://blogres.blackist.org/spring-springmvc-webxml-app-web-inf.png"></p><p>其实Tomcat的配置文件夹下也有web.xml，这是配置所有Web应用的公共配置，每个Web应用拥有自己的web.xml进行个性化配置。</p><p><img src="https://blogres.blackist.org/spring-springmvc-webxml-tomcat-apps.png"></p><h3 id="web-xml-of-Tomcat"><a href="#web-xml-of-Tomcat" class="headerlink" title="web.xml of Tomcat"></a>web.xml of Tomcat</h3><hr><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.1&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- The default servlet for all web applications, that serves static     --&gt;</span><br><span class="hljs-comment">&lt;!-- resources.  It processes all requests that are not mapped to other   --&gt;</span><br><span class="hljs-comment">&lt;!-- servlets with servlet mappings (defined either here or in your own   --&gt;</span><br><span class="hljs-comment">&lt;!-- web.xml file).  This servlet supports the following initialization   --&gt;</span><br><span class="hljs-comment">&lt;!-- parameters (default values are in square brackets):                  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>listings<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-comment">&lt;!-- The mapping for the default servlet --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- The JSP page compiler and execution servlet, which is the mechanism  --&gt;</span><br><span class="hljs-comment">&lt;!-- used by Tomcat to support JSP pages.  Traditionally, this servlet    --&gt;</span><br><span class="hljs-comment">&lt;!-- is mapped to the URL pattern &quot;*.jsp&quot;.  This servlet supports the     --&gt;</span><br><span class="hljs-comment">&lt;!-- following initialization parameters (default values are in square    --&gt;</span><br><span class="hljs-comment">&lt;!-- brackets):                                                           --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>fork<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>xpoweredBy<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- ==================== Default Session Configuration ================= --&gt;</span><br>  <span class="hljs-comment">&lt;!-- You can set the default session timeout (in minutes) for all newly   --&gt;</span><br>  <span class="hljs-comment">&lt;!-- created sessions by modifying the value below.                       --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- ===================== Default MIME Type Mappings =================== --&gt;</span><br><span class="hljs-comment">&lt;!-- When serving static resources, Tomcat will automatically generate    --&gt;</span><br><span class="hljs-comment">&lt;!-- a &quot;Content-Type&quot; header based on the resource&#x27;s filename extension,  --&gt;</span><br><span class="hljs-comment">&lt;!-- based on these mappings.  Additional mappings can be added here (to  --&gt;</span><br><span class="hljs-comment">&lt;!-- apply to all web applications), or in your own application&#x27;s web.xml --&gt;</span><br><span class="hljs-comment">&lt;!-- deployment descriptor.                                               --&gt;</span><br><span class="hljs-comment">&lt;!-- <span class="hljs-doctag">Note:</span> Extensions are always matched in a case-insensitive manner.    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mime-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span>zmm<span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mime-type</span>&gt;</span>application/vnd.handheld-entertainment+xml<span class="hljs-tag">&lt;/<span class="hljs-name">mime-type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mime-mapping</span>&gt;</span><br>.<br>.<br>.<br><span class="hljs-tag">&lt;<span class="hljs-name">mime-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mime-type</span>&gt;</span>application/vnd.lotus-1-2-3<span class="hljs-tag">&lt;/<span class="hljs-name">mime-type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mime-mapping</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- ==================== Default Welcome File List ===================== --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.htm<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li><p>** Servlet default **<br>默认Servlet，<url-pattern>&#x2F;</url-pattern> 过滤所有Web应用的请求，可以处理所有应用的静态资源，也处理在其他应用中未匹配到请求，所以优先级比较低。</p></li><li><p>** Servlet jsp **<br>JspServlet，<url-pattern>*.jsp</url-pattern>处理.jsp后缀文件,编译、执行JSP，浏览器不能显示动态网页(基于动态网站技术的页面，e.g jsp,php,.net)，JspServlet将jsp编译后生成html，返回给客户端。</p></li><li><p>** session-timeout **<br>session的存活时间。</p></li><li><p>** mime-mapping **<br>mine-mapping通过匹配文件后缀判断mine类型，<extension>123</extension>即为文件扩展名，服务器通过mine-mapping告诉浏览器返回内容的mine类型。</p></li><li><p>** Welcome List **<br>welcome-file-list配置Web应用的欢迎页，如果Web应用没有在自己的web.xml中配置此项，<welcome-file>index.html</welcome-file>指定其默认页面为index.html。</p></li></ul><p>注：动态网页不是指有动态效果的页面，而是基于动态网站技术开发的页面，如jsp,php,asp等，动态网页和静态网页可通过下图来区分。</p><p><img src="https://blogres.blackist.org/spring-springmvc-webxml-web-static-dynamic.png"></p><h3 id="web-xml-of-WGS"><a href="#web-xml-of-WGS" class="headerlink" title="web.xml of WGS"></a>web.xml of WGS</h3><hr><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="hljs-attr">xmlns:web</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.5&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>WGS<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Context Param --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><br>classpath*:/applicationContext.xml,<br>classpath*:/applicationContext-shiro.xml<br><span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>spring.profiles.default<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>production<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Context Loader Listener  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Encoding Config --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- JPA Config --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>openEntityManagerInViewFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>openEntityManagerInViewFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>  <br><br><span class="hljs-comment">&lt;!-- Shiro Config --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>targetFilterLifecycle<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Spring MVC Config --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/WEB-INF/views/error/404.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>如上，Web应用web.xml中主要有几个标签，context-param、listener、filter、filter-mapping、servlet、servlet-mapping，Tomcat初始化顺序为context-param、listener、filter、servlet，初始化流程如下：</p><ul><li>Tomcat读取web.xml中的context-param、listener两类节点</li><li>Tomcat创建ServletContext，即上Web应用下文，将context-param对应的键值交给ServletContext，接着创建listener</li><li>Tomcat实例化listener对应的类(ContextLoaderListener)，根据listener中的方法加载context-param的值，也就是去加载applicationContext.xml和applicationContext-shiro.xml，以及根据<param-name>spring.profiles.default</param-name>加载生产环境下的属性文件。这些配置文件描述了如何加载应用程序。</li><li>Tomcat初始化过滤器Filter</li><li>Tomcat初始化Servlet，servlet-mapping定义过滤规则，load-on-startup指定启动顺序，大于1则此Servlet启动优先级最高。</li></ul><p>springServlet就是应用程序的Servlet，使用的是org.springframework.web.servlet.DispatcherServlet这个类，Tomcat实例化此类来处理web请求，具体实例化配置在 &#x2F;WEB-INF&#x2F;spring-mvc.xml 中定义，此配置文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 自动扫描且只扫描 @Controller --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.smarts&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span> <span class="hljs-attr">register-defaults</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 将StringHttpMessageConverter的默认编码设为UTF-8 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 定义JSP文件的位置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span></span><br><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 容器默认的DefaultServletHandler处理 所有静态内容与无RequestMapping处理的URL --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 定义无需Controller的url&lt;-&gt;view直接映射 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;redirect:/manage/&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 替换异常处理方式。指定的异常转到指定页面；否则作为json返回 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exceptionResolver&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.smarts.exception.CustomSimpleMappingExceptionResolver&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionMappings&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;com.smarts.exception.WebException&quot;</span>&gt;</span>error/jsonerror<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.NullPointerException&quot;</span>&gt;</span>error/jsonerror<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.exception&quot;</span>&gt;</span>error/500<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>如上，是我们熟悉的SpringMVC的配置文件，通过@Controller注解来管理请求处理类，并定义返回jsp文件的位置。</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>javaweb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android模块化-推送服务端</title>
    <link href="/2018-10-27-android-modulize-push-server/"/>
    <url>/2018-10-27-android-modulize-push-server/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于Nodejs+Koa搭建极光推送的用户服务端程序，RESTful接口、文件上传。</p><span id="more"></span><h3 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h3><hr><p>使用 <a href="https://github.com/blackist/node-koa-restful">Koa脚手架</a> 快速开发服务端程序，clone下来此项目，删除controller下的UserController.js、comomon&#x2F;UploadController.js，新建PushController.js，编写处理请求的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">pushNotice</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; &#123;<br><span class="hljs-keyword">let</span> param = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param)<br>ctx.<span class="hljs-property">body</span> = <span class="hljs-title function_">format</span>(&#123;&#125;, <span class="hljs-variable constant_">ERROR_CODE</span>.<span class="hljs-property">OK</span>)<br><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-string">&#x27;POST /push/notice&#x27;</span>: pushNotice<br>&#125;<br><br></code></pre></td></tr></table></figure><p>先测试一下接口，用postman提交请求</p><p><img src="https://blogres.blackist.org/android-jpush-node-push-api-weweew.png"></p><p>接收到的参数如下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">&#123; alias: [ &#x27;<span class="hljs-number">17816118870</span>&#x27;, &#x27;<span class="hljs-number">18796221162</span>&#x27; ],<br><span class="hljs-function">  content: &#123; <span class="hljs-title">uuid</span>: &#x27;1232&#x27; &#125; &#125;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h3 id="集成JPush-SDK"><a href="#集成JPush-SDK" class="headerlink" title="集成JPush SDK"></a>集成JPush SDK</h3><hr><p>参考极光推送<a href="https://docs.jiguang.cn/jpush/server/sdk/nodejs_sdk/">官方文档</a>，安装sdk依赖，</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install jpush-async --save<br><br></code></pre></td></tr></table></figure><p>在PushController.js中引入依赖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">JPush</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jpush-async&#x27;</span>).<span class="hljs-property">JPushAsync</span><br><span class="hljs-keyword">const</span> jPushClient = <span class="hljs-title class_">JPush</span>.<span class="hljs-title function_">buildClient</span>(<br>  <span class="hljs-string">&#x27;0a2*****************2ba&#x27;</span>,<br>  <span class="hljs-string">&#x27;5e2*****************8dc&#x27;</span><br>)<br><br></code></pre></td></tr></table></figure><p>buildClient()中 两个参数分别为为 极光推送的AppKey以及Master Secret，填写这两个参需要注意，不要复制错误或留有空格，这都会导致服务调用异常。<br>使用Alias方式发送自定义消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jpush send message</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">alias</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">notice</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> jPushSend = <span class="hljs-keyword">function</span>(<span class="hljs-params">alias, notice</span>) &#123;<br>  jPushClient<br>    .<span class="hljs-title function_">push</span>()<br>    .<span class="hljs-title function_">setPlatform</span>(<span class="hljs-string">&#x27;ios&#x27;</span>, <span class="hljs-string">&#x27;android&#x27;</span>)<br><span class="hljs-comment">// 设置别名</span><br>    .<span class="hljs-title function_">setAudience</span>(<span class="hljs-title class_">JPush</span>.<span class="hljs-title function_">alias</span>(alias))<br>    <span class="hljs-comment">// .setNotification(&#x27;NotificationContent&#x27;)</span><br><span class="hljs-comment">// 设置推送内容</span><br>    .<span class="hljs-title function_">setMessage</span>(notice)<br>    .<span class="hljs-title function_">setOptions</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">60</span>)<br>    .<span class="hljs-title function_">send</span>()<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>    &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>alias格式为 ‘17816227765,18746578867’，所以需要将接收到的参数格式化，直接数组转字符串即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">pushNotice</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> param = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param)<br>  <span class="hljs-keyword">let</span> alias = param.<span class="hljs-property">alias</span>.<span class="hljs-title function_">toString</span>()<br>  param.<span class="hljs-property">content</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;NOTICE&#x27;</span><br>  <span class="hljs-title function_">jPushSend</span>(alias, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(param.<span class="hljs-property">content</span>))<br>  ctx.<span class="hljs-property">body</span> = <span class="hljs-title function_">format</span>(&#123;&#125;, <span class="hljs-variable constant_">ERROR_CODE</span>.<span class="hljs-property">OK</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>进行接口测试，移动端可正常接收推送消息。</p><h3 id="推送媒体文件"><a href="#推送媒体文件" class="headerlink" title="推送媒体文件"></a>推送媒体文件</h3><hr><p>实现思路为 接收客户端推送图片、视频、语音等媒体文件，保存成功后根据推送参数向指定客户端推送消息，附带上文件的url（多个文件则放入数组）以及其他的推送内容。</p><h4 id="保存推送的媒体文件"><a href="#保存推送的媒体文件" class="headerlink" title="保存推送的媒体文件"></a>保存推送的媒体文件</h4><p>使用文件上传接口的部分代码，将文件保存在服务端或第三方文件服务器，并获得文件的url，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * handle media push</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"></span>&#125; <span class="hljs-variable">ctx</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">next</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">pushMedia</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; &#123;<br>  <span class="hljs-comment">// ctx.req.files contains files uploaded</span><br>  <span class="hljs-comment">// ctx.req.body contains fields property</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">req</span>.<span class="hljs-property">files</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">req</span>.<span class="hljs-property">body</span>)<br>  <span class="hljs-keyword">if</span> (!ctx.<span class="hljs-property">req</span>.<span class="hljs-property">files</span> || ctx.<span class="hljs-property">req</span>.<span class="hljs-property">files</span>.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>    ctx.<span class="hljs-property">body</span> = <span class="hljs-title function_">format</span>(&#123;&#125;, <span class="hljs-variable constant_">ERROR_CODE</span>.<span class="hljs-property">FILE_NULL</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// push param</span><br>  <span class="hljs-keyword">let</span> param = ctx.<span class="hljs-property">req</span>.<span class="hljs-property">body</span><br>  param.<span class="hljs-property">content</span> = &#123;&#125;<br>  param.<span class="hljs-property">content</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;MEDIA&#x27;</span><br>  <span class="hljs-keyword">let</span> alias = param.<span class="hljs-property">alias</span>.<span class="hljs-title function_">toString</span>()<br><br>  <span class="hljs-keyword">let</span> datas<br>  <span class="hljs-comment">// single file</span><br>  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">req</span>.<span class="hljs-property">files</span>.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">let</span> file = ctx.<span class="hljs-property">req</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]<br>    datas = <span class="hljs-keyword">await</span> <span class="hljs-title function_">saveFile</span>(file)<br>    <span class="hljs-keyword">if</span> (datas) &#123;<br>      ctx.<span class="hljs-property">body</span> = <span class="hljs-title function_">format</span>(datas, <span class="hljs-variable constant_">ERROR_CODE</span>.<span class="hljs-property">OK</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ctx.<span class="hljs-property">body</span> = <span class="hljs-title function_">format</span>(&#123;&#125;, <span class="hljs-variable constant_">ERROR_CODE</span>.<span class="hljs-property">FILE_WRITE_ERROR</span>)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// multi files</span><br>    datas = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ctx.<span class="hljs-property">req</span>.<span class="hljs-property">files</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> file = ctx.<span class="hljs-property">req</span>.<span class="hljs-property">files</span>[i]<br>      <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">saveFile</span>(file)<br>      <span class="hljs-keyword">if</span> (res) &#123;<br>        datas.<span class="hljs-title function_">push</span>(res)<br>      &#125;<br>    &#125;<br>    ctx.<span class="hljs-property">body</span> = <span class="hljs-title function_">format</span>(&#123; datas &#125;, <span class="hljs-variable constant_">ERROR_CODE</span>.<span class="hljs-property">OK</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// push</span><br>  param.<span class="hljs-property">content</span>.<span class="hljs-property">media</span> = datas<br>  <span class="hljs-title function_">jPushSend</span>(alias, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(param.<span class="hljs-property">content</span>))<br><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="推送消息"><a href="#推送消息" class="headerlink" title="推送消息"></a>推送消息</h4><p>param.content是完整的推送内容，param.content.media是媒体文件的url，jPushSend(alias, JSON.stringify(param.content))<br>调用SDK完成推送。</p><p>返回信息为文件上传结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;OK&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;datas&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;/uploads/2018-10-21/9e0e8bde-2e22-4f8d-9ada-bbe74c6a6d8d.png&quot;</span>,<br>                <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;study.png&quot;</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;/uploads/2018-10-21/92b10c98-fc1e-4be0-ba48-9111069fc485.jpeg&quot;</span>,<br>                <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;1_S7BwOWdiQNcL0HHG2fDL0w.jpeg&quot;</span><br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>至此，基于Nodejs+JPush搭建的推送服务基本完成。</p><h3 id="多推送通道"><a href="#多推送通道" class="headerlink" title="多推送通道"></a>多推送通道</h3>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>nodejs</tag>
      
      <tag>server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android组件化-推送服务</title>
    <link href="/2018-10-25-android-modulize-push/"/>
    <url>/2018-10-25-android-modulize-push/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>App开发中，服务器主动向客户端推送消息，基本采用第三方推送服务。本文讲述在组件化项目开发中，如何集成推送服务并进行业务隔离，集成多通道推送提高到达率、消息去重等。</p><span id="more"></span><blockquote><p><strong>系列文章</strong></p><p><a href="/2018/10/18/android-modulize-common/">Android组件化-基础框架搭建</a></p><p><a href="/2018/10/23/android-modulize-router/">Android组件化-组件间通信BRouter</a></p><p><a href="/2019/03/21/android-modulize-ui-theme/">Android组件化-风格统一&amp;主题变色</a></p><p><a href="/2019/03/31/android-modulize-mvp/">Android组件化-MVP设计模式</a></p></blockquote><p>首先集成<a href="https://www.jiguang.cn/">极光推送</a>，具体操作参考<a href="https://docs.jiguang.cn/jpush/client/Android/android_guide/">极光推送Android SDK集成指南</a>。我们要做到推送服务与业务代码隔离，在lib-push库中处理推送逻辑，对外暴露一个推送服务初始化接口，以及推送通知接口，具体实现如下。</p><h4 id="推送初始化"><a href="#推送初始化" class="headerlink" title="推送初始化"></a>推送初始化</h4><p>新建PushClient类，使用单例模式，这是对外提供服务的工具类，包含推送初始化、别名设置、通知接口设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushClient</span> &#123;<br><br><span class="hljs-comment">// 推送通知回调，回调给业务层</span><br>    PushListener mListener;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PushClient <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 单例模式</span><br>...<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Push init</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> PushClient <span class="hljs-title function_">init</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mContext = context;<br>        JPushInterface.setDebugMode(<span class="hljs-literal">true</span>);<br>        JPushInterface.init(mContext);<br><br><span class="hljs-comment">// 其它推送</span><br>...<br><br>        <span class="hljs-keyword">return</span> PushClient.<span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set push alias</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> alias alias</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> PushClient <span class="hljs-title function_">setAlias</span><span class="hljs-params">(String alias)</span> &#123;<br>        JPushInterface.setAlias(mContext, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(), alias);<br>        ...<br><br>        <span class="hljs-keyword">return</span> PushClient.<span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set push listener to receive message</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> listener</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> PushClient <span class="hljs-title function_">setListener</span><span class="hljs-params">(PushListener listener)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mListener = listener;<br><br>        <span class="hljs-keyword">return</span> PushClient.<span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="推送回调"><a href="#推送回调" class="headerlink" title="推送回调"></a>推送回调</h4><p>PushListener为回调接口，业务层实现此接口，当推送服务收到推送，会在接收器里回调此实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> intent.getExtras();<br>        Log.d(TAG, <span class="hljs-string">&quot;[JPush]: onReceive - &quot;</span> + intent.getAction() + <span class="hljs-string">&quot;, extras: &quot;</span> + printBundle(bundle));<br>...<br>        <br>        <span class="hljs-keyword">if</span> (PushClient.getInstance().mListener != <span class="hljs-literal">null</span>) &#123;<br>            PushClient.getInstance().mListener.onPush(context, content);<br>        &#125;<br>        <br>...<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>当业务层接收到推送后，可进行具体而复杂的处理。</p><h4 id="多通道推送"><a href="#多通道推送" class="headerlink" title="多通道推送"></a>多通道推送</h4><p>实际开发中，遇到小米推送不及时、偶发性推送失效的场景，解决方案是集成2-3个推送通道，本项目集成了小米、极光推送，小米推送集成参见<a href="https://dev.mi.com/console/doc/detail?pId=41">小米推送Android客户端SDK使用指南</a>，和极光推送一样，都配置在lib-push中，与上层逻辑隔离，集成时请留意权限配置。小米推送依然在PushClinet中初始化，别名设置也在setAlias()方法中。</p><p>此时迎来第二个问题，多通道推送必然导致消息重复，需要对收到的推送进行过滤，也正式因此，消息推送最好采用自定义消息（小米称透传消息）的方式推送，方便客户端进行消息过滤以及自定义通知栏。</p><h4 id="消息去重"><a href="#消息去重" class="headerlink" title="消息去重"></a>消息去重</h4><p>在消息到达客户端的时候，不再直接回调业务层接口实现，应该先进行消息处理，确认消息不重复之后再进行回调通知，加入PushManage消息处理类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> intent.getExtras();<br>        Log.d(TAG, <span class="hljs-string">&quot;[JPush]: onReceive - &quot;</span> + intent.getAction() + <span class="hljs-string">&quot;, extras: &quot;</span> + printBundle(bundle));<br>...<br>        <span class="hljs-comment">// 处理消息 进行消息去重、数据库存储</span><br>        PushManage.push(context, content);<br>        <br>...<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>PushManage对消息进行过滤，并存储到数据库，重启App以后仍然可对消息进行有效过滤，防止推送延迟严重的现象。</p><p>项目Github地址：<a href="https://github.com/blackist/modulize">https://github.com/blackist/modulize</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>组件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android组件化-组件间通信BRouter</title>
    <link href="/2018-10-23-android-modulize-router/"/>
    <url>/2018-10-23-android-modulize-router/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Android组件化开发项目中，一个很大的问题就是解耦之后组件间的通信，Activity&#x2F;Fragment的跳转切换、组件间数据传递、数据共享等，可以通过广播Broadcast、EventBus等决绝部分问题，不过多数实践证明Broadcast和EventBus随着业务扩张，会使数据传递、代码调用变得难以追踪。阿里的<a href="https://github.com/alibaba/ARouter">ARouter</a>也是一个用于解决组件间通信的框架，支持跨模块页面跳转、跨模块API调用、通过URL映射到模块内部、拦截跳转、支持注解等，简单易用。</p><p>个人觉得ARouter功能比较丰富，也感觉有些重量级，包括gradle工程文件配置、注解URL与代码耦合，我曾经接触过一个团队，他们组内非常抵触注解开发，因为他们觉得注解开发方便但会使代码变得难以追踪。加上小小的造轮子热情，组件化开发中我没有引入ARouter，而是手写了一套路由框架<a href="https://github.com/blackist/BRouter">BRouter</a>，这个框架很大程度上借鉴了<a href="https://www.jianshu.com/p/200c6cc6adaf">SRouter</a>。</p><span id="more"></span><blockquote><p><strong>系列文章</strong></p><p><a href="/2018/10/18/android-modulize-common/">Android组件化-基础框架搭建</a></p><p><a href="/2018/10/23/android-modulize-router/">Android组件化-组件间通信BRouter</a></p><p><a href="/2019/03/21/android-modulize-ui-theme/">Android组件化-风格统一&amp;主题变色</a></p><p><a href="/2019/03/31/android-modulize-mvp/">Android组件化-MVP设计模式</a></p></blockquote><h3 id="BRouter设计思路"><a href="#BRouter设计思路" class="headerlink" title="BRouter设计思路"></a>BRouter设计思路</h3><hr><p>首先创造一个路由中心，每个module都在路由中心进行注册，组件间通信通过向路由中心发出请求，路由中心进行转发并返回处理结果。路由请求指定URL(e.g “&#x2F;modeule&#x2F;…”)并可携带参数，返回值可以是Activity、Fragment、任何数据或者为空。BRouter模型如下：</p><p><img src="https://blogres.blackist.org/android-modulize-router-brouter-module-pic.png"></p><p>各模块实现一个BAction，在路由中心通过&lt;path, BAction&gt;存储在一个HashMap中，路由注册以及请求转发都是通过这个HashMap来处理，单模块实现BAction代码如下(e.g app-message)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BAction</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;message&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">startAction</span><span class="hljs-params">(Context context, String path, Bundle param, BEvent event)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (path) &#123;<br><br>            <span class="hljs-keyword">default</span>: &#123;<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(context, MessageActivity.class);<br>                intent.putExtras(param);<br>                intent.setFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK);<br>                context.startActivity(intent);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>路由中心在app壳工程中的Application中初始化，实例化每个Action方法到BRouter的路由列表中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseApplication</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>    ...<br>    BRouter.register(MainAction.NAME, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainAction</span>());<br>    BRouter.register(MineAction.NAME, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MineAction</span>());<br>    BRouter.register(MessageAction.NAME, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageAction</span>());<br>    ...<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>BRouter是单例模式，在多进程情况下，Application会多次初始化，每个进程中都会持有一个BRouter并实例化Action，所以每个BRouter持有一份路由列表，BRouter适用于多进程的。</p><h3 id="BRouter内部原理解析"><a href="#BRouter内部原理解析" class="headerlink" title="BRouter内部原理解析"></a>BRouter内部原理解析</h3><hr><p>BRouter代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BRouter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> BRouter instance;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, BAction&gt; actions;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">BRouter</span><span class="hljs-params">()</span> &#123;<br>        actions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * singleton for multithread.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> router instance</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BRouter <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (BRouter.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    Log.d(<span class="hljs-string">&quot;BRouter&quot;</span>, <span class="hljs-string">&quot;BRouter initing... &quot;</span>);<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BRouter</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * register action in router pool.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name   name of action</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> action action</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String name, BAction action)</span> &#123;<br>        <span class="hljs-keyword">if</span> (getInstance().actions.containsKey(name)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        getInstance().actions.put(name, action);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * invoke action by router request.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req     request param</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> router response</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BRouterRes <span class="hljs-title function_">push</span><span class="hljs-params">(Context context, BRouterReq req)</span> &#123;<br>        <span class="hljs-type">BRouterRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BRouterRes</span>();<br>        <span class="hljs-type">BAction</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> getAction(req);<br>        <span class="hljs-keyword">if</span> (action != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> action.startAction(context, req.getPath(), req.getParam(), <span class="hljs-literal">null</span>);<br>            res.set(object, BRouterRes.CODE.OK);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.set(BRouterRes.CODE.NOT_FOUND);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * invoke action by router request.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req     request param</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> event   callback</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> router response</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BRouterRes <span class="hljs-title function_">push</span><span class="hljs-params">(Context context, BRouterReq req, BEvent event)</span> &#123;<br>        <span class="hljs-type">BRouterRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BRouterRes</span>();<br>        <span class="hljs-type">BAction</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> getAction(req);<br>        <span class="hljs-keyword">if</span> (action != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> action.startAction(context, req.getPath(), req.getParam(), event);<br>            res.set(object, BRouterRes.CODE.OK);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.set(BRouterRes.CODE.NOT_FOUND);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get action from router</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> action</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BAction <span class="hljs-title function_">getAction</span><span class="hljs-params">(BRouterReq req)</span> &#123;<br>        <span class="hljs-keyword">if</span> (getInstance().actions.containsKey(req.getAction())) &#123;<br>            <span class="hljs-keyword">return</span> getInstance().actions.get(req.getAction());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>BRouter使用单例模式，默认构造一个HashMap actions作为路由列表，通过register方法向actions添加路由，自定义URL作为key，new Action() 作为value。</p><p><img src="https://blogres.blackist.org/android-modulize-router-brouter-action-registers.png"></p><p>组件间通信转化为路由请求，路由请求首先构造请求对象BRouterReq，然后调用BRouter的push方法进行路由转发，并通过BRouterRes进行响应，以app-main开启app-message消息界面为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BRouterRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> BRouter.push(<br>        getApplicationContext(),<br>        BRouterReq.build().action(<span class="hljs-string">&quot;message&quot;</span>).path(<span class="hljs-string">&quot;message/list&quot;</span>)<br>);<br>getFragmentManager().beginTransaction().add((Fragment) res.data(), <span class="hljs-string">&quot;&quot;</span>).commit();<br><br></code></pre></td></tr></table></figure><p>路由请求构造方式为 BRouterReq.build().action(URL).param(key, value)，BRouter.push(context, req, callback)进行转发，同步处理可获得返回结果BRouterRes，异步处理可通过BEvent callback实现。MessageAction具体处理逻辑在模块内部实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BAction</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;message&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MESSAGE_LIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;message/list&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">startAction</span><span class="hljs-params">(Context context, String path, Bundle param, BEvent event)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (path) &#123;<br><br>            <span class="hljs-keyword">case</span> MESSAGE_LIST: &#123;<br>                data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageFragment</span>();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">default</span>: &#123;<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(context, MessageActivity.class);<br>                intent.putExtras(param);<br>                intent.setFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK);<br>                context.startActivity(intent);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>请结果返回MessageFragment实例，在app-main中进行展示。BRouterReq支持多种参数形式，内部通过Bundle对象存储参数，方便参数在activity以及fragment中传递，可以整个Bundle对象直接set进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BRouterReq</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String action;<br><br>    <span class="hljs-keyword">private</span> String path;<br><br>    <span class="hljs-keyword">private</span> Bundle param;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">BRouterReq</span><span class="hljs-params">()</span> &#123;<br>        param = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get instance of request</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> request</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BRouterReq <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BRouterReq</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set action for request</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> action action</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> request</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BRouterReq <span class="hljs-title function_">action</span><span class="hljs-params">(String action)</span> &#123;<br>        <span class="hljs-built_in">this</span>.action = action;<br>        <span class="hljs-keyword">return</span> BRouterReq.<span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set request path</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path request path</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> this</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BRouterReq <span class="hljs-title function_">path</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.param == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.param = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.path = path == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;&quot;</span> : path;<br>        <span class="hljs-keyword">return</span> BRouterReq.<span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set bundle param for request</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data bundle param</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> BRouter Request</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BRouterReq <span class="hljs-title function_">data</span><span class="hljs-params">(Bundle data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.param == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.param = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.param.putAll(data);<br>        &#125;<br>        <span class="hljs-keyword">return</span> BRouterReq.<span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * put param into param</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> router request</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BRouterReq <span class="hljs-title function_">data</span><span class="hljs-params">(String key, Object value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.param == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.param = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.param.putString(key, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String) &#123;<br>            <span class="hljs-built_in">this</span>.param.putString(key, value.toString());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.getClass().equals(<span class="hljs-type">int</span>.class)) &#123;<br>            <span class="hljs-built_in">this</span>.param.putInt(key, (<span class="hljs-type">int</span>) value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.getClass().equals(<span class="hljs-type">boolean</span>.class)) &#123;<br>            <span class="hljs-built_in">this</span>.param.putBoolean(key, (<span class="hljs-type">boolean</span>) value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.getClass().equals(<span class="hljs-type">float</span>.class)) &#123;<br>            <span class="hljs-built_in">this</span>.param.putLong(key, (<span class="hljs-type">long</span>) value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.getClass().equals(<span class="hljs-type">char</span>.class)) &#123;<br>            <span class="hljs-built_in">this</span>.param.putChar(key, (<span class="hljs-type">char</span>) value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.getClass().equals(<span class="hljs-type">short</span>.class)) &#123;<br>            <span class="hljs-built_in">this</span>.param.putShort(key, (<span class="hljs-type">short</span>) value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Serializable) &#123;<br>            <span class="hljs-built_in">this</span>.param.putSerializable(key, (Serializable) value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Parcelable) &#123;<br>            <span class="hljs-built_in">this</span>.param.putParcelable(key, (Parcelable) value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.param.putString(key, <span class="hljs-literal">null</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> BRouterReq.<span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAction</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> action;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> path != <span class="hljs-literal">null</span> ? path : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Bundle <span class="hljs-title function_">getParam</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> param;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>BRouterRes包含路由请求响应的ERROR_CODE、ERROR_MSG以及处理结果data，若调用成功code为OK，调用方可通过code判断请求是否成功，从而形成闭环控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BRouterRes</span> &#123;<br><br>    <span class="hljs-keyword">private</span> CODE code;<br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-keyword">private</span> Object data;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(CODE code)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.msg = code.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(Object data, CODE code)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.msg = code.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(Object data, CODE code, String msg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * response to string</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> response</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">string</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            res.put(<span class="hljs-string">&quot;code&quot;</span>, code.name())<br>                    .put(<span class="hljs-string">&quot;msg&quot;</span>, msg)<br>                    .put(<span class="hljs-string">&quot;data&quot;</span>, data);<br>        &#125; <span class="hljs-keyword">catch</span> (JSONException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CODE</span> &#123;<br><br>        OK(<span class="hljs-string">&quot;OK&quot;</span>),<br>        ERROR(<span class="hljs-string">&quot;ERROR&quot;</span>),<br>        NOT_FOUND(<span class="hljs-string">&quot;ACTION_NOT_FOUND&quot;</span>);<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String message;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * msg passed to enum constrctor for each enum constant</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> msg msg</span><br><span class="hljs-comment">         */</span><br>        CODE(<span class="hljs-keyword">final</span> String msg) &#123;<br>            <span class="hljs-built_in">this</span>.message = msg;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="BRouter实践"><a href="#BRouter实践" class="headerlink" title="BRouter实践"></a>BRouter实践</h3><hr><p>BRouter已经自己使用在项目中，基本满足需求且稳定。我的开源项目中也在使用，传送门<a href="https://github.com/blackist/modulize">Modulize</a>。</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>组件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android组件化-基础框架搭建</title>
    <link href="/2018-10-18-android-modulize-common/"/>
    <url>/2018-10-18-android-modulize-common/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>安卓组件化开发是老生常谈的问题，基础的模块化开发教程很多，本系列教程展现从零开始，到整个系统搭建的过程，设计项目组件化结构、MVP设计模式、组件间通信路由框架、WebSocket网络交互基础库的设计、推送服务基础库的设计、UI统一风格基础库的设计、数据库交互基础库的设计、以及业务相关的实际应用场景问题。</p><span id="more"></span><blockquote><p><strong>系列文章</strong></p><p><a href="/2018/10/18/android-modulize-common/">Android组件化-基础框架搭建</a></p><p><a href="/2018/10/23/android-modulize-router/">Android组件化-组件间通信BRouter</a></p><p><a href="/2019/03/21/android-modulize-ui-theme/">Android组件化-风格统一&amp;主题变色</a></p><p><a href="/2019/03/31/android-modulize-mvp/">Android组件化-MVP设计模式</a></p></blockquote><h2 id="一、模块化开发的几个问题"><a href="#一、模块化开发的几个问题" class="headerlink" title="一、模块化开发的几个问题"></a>一、模块化开发的几个问题</h2><ul><li>资源冲突</li><li>单模块调试</li><li>组件间通信</li></ul><p>项目由一个空壳模块app、一个主界面app-main模块、若干app-xxx业务模块组成、一个公共库lib-common、若干基础库组成，借本结构如下</p><p><img src="https://blogres.blackist.org/android-modulize-common-base-structure.png"></p><p>使用Android Studio作为IDE开发，项目模块基本文件结构如下：</p><p><img src="https://blogres.blackist.org/android-modulize-common-base-as-folder.png"></p><h2 id="二、项目搭建"><a href="#二、项目搭建" class="headerlink" title="二、项目搭建"></a>二、项目搭建</h2><p>项目搭建主要分三步，搭建基础库模块lib-xxx、全局公共库模块lib-common，搭建业务应用模块app-xxx，整合业务模块到app空壳模块。</p><h3 id="2-1-基础库"><a href="#2-1-基础库" class="headerlink" title="2.1 基础库"></a>2.1 基础库</h3><p>新建一个模块作为lib，在AndroidStudio中 File-&gt;New-&gt;New Module…-&gt;Android Library，LibraryName为db，ModuleName为lib-db,如图：</p><p><img src="https://blogres.blackist.org/android-modulize-common-new-lib-module-db.png"></p><p>lib-db模块中build.gradle修改如下，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 用来定义此模块是lib库模块还是应用模块</span><br>apply plugin: <span class="hljs-string">&#x27;com.android.library&#x27;</span><br><br>android &#123;<br>    compileSdkVersion rootProject.ext.compileSdkVersion<br><br>    defaultConfig &#123;<br>        minSdkVersion rootProject.ext.minSdkVersion<br>        targetSdkVersion rootProject.ext.targetSdkVersion<br>        versionCode rootProject.ext.versionCode<br>        versionName rootProject.ext.versionName<br><br>        testInstrumentationRunner <span class="hljs-string">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-keyword">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-keyword">fileTree</span>(dir: <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-keyword">include</span>: [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br><br>    implementation <span class="hljs-string">&#x27;com.android.support:appcompat-v7:26.1.0&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;junit:junit:4.12&#x27;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时lib-db 未引入任何第三方库，rootProject.ext.compileSdkVersion为项目根目录build.gradle中定义的统一配置，方便做全局修改。根目录build.gradle如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ext &#123;<br>    <span class="hljs-comment">// SDK Tool Version</span><br>    minSdkVersion = <span class="hljs-number">21</span><br>    targetSdkVersion = <span class="hljs-number">26</span><br>    compileSdkVersion = <span class="hljs-number">26</span><br>    buildToolsVersion = <span class="hljs-string">&#x27;25.0.3&#x27;</span><br><br>    <span class="hljs-comment">// Build Version</span><br>    versionCode = <span class="hljs-number">1</span><br>    versionName = <span class="hljs-string">&quot;1.0&quot;</span><br><br>    <span class="hljs-comment">// java version</span><br>    javaVersion = JavaVersion.VERSION_1_8<br><br>    <span class="hljs-comment">// 第三方依赖的版本</span><br>    supportVersion = <span class="hljs-string">&quot;26.1.0&quot;</span><br>    butterknifeVersion = <span class="hljs-string">&quot;8.8.1&quot;</span><br>    gsonVersion = <span class="hljs-string">&quot;2.8.5&quot;</span><br>    rxJavaVersion = <span class="hljs-string">&quot;2.2.2&quot;</span><br>    rxAndroidVersion = <span class="hljs-string">&quot;2.1.0&quot;</span><br>    rxBindingVersion = <span class="hljs-string">&quot;1.0.0&quot;</span><br>    rxPermissionVersion = <span class="hljs-string">&quot;0.10.2&quot;</span><br>    retrofitVersion = <span class="hljs-string">&quot;2.4.0&quot;</span><br>    okHttpVersion = <span class="hljs-string">&quot;3.11.0&quot;</span><br>    eventBusVersion = <span class="hljs-string">&quot;3.1.1&quot;</span><br>    greenDaoVersion = <span class="hljs-string">&quot;3.2.2&quot;</span><br>    lottieVersion = <span class="hljs-string">&quot;2.6.1&quot;</span><br>&#125;<br><br><span class="hljs-keyword">buildscript</span> &#123;<br><br>    <span class="hljs-keyword">repositories</span> &#123;<br>        google()<br>        jcenter()<br>    &#125;<br><br>    <span class="hljs-keyword">dependencies</span> &#123;<br>        <span class="hljs-keyword">classpath</span> <span class="hljs-string">&#x27;com.android.tools.build:gradle:3.0.1&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 后期框架引入诸多第三方库，需要添加更多远程仓库</span><br><span class="hljs-keyword">allprojects</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>        google()<br>        jcenter()<br>        mavenCentral()<br>        maven &#123; url <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span> &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">task</span> clean(type: <span class="hljs-keyword">Delete</span>) &#123;<br>    <span class="hljs-keyword">delete</span> rootProject.buildDir<br>&#125;<br><br><span class="hljs-comment">// 统一配置android support version</span><br><span class="hljs-keyword">subprojects</span> &#123;<br>    <span class="hljs-keyword">project</span>.<span class="hljs-keyword">configurations</span>.all &#123;<br>        resolutionStrategy.eachDependency &#123; details -&gt;<br>            <span class="hljs-keyword">if</span> (details.requested.<span class="hljs-keyword">group</span> == <span class="hljs-string">&#x27;com.android.support&#x27;</span><br>                    &amp;&amp; !details.requested.name.contains(<span class="hljs-string">&#x27;multidex&#x27;</span>)) &#123;<br>                details.useVersion <span class="hljs-string">&quot;26.1.0&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>** lib库模块中引入第三方库需注意，假如此库中 方法&#x2F;View控件 需要在应用模块中使用，则此依赖需要使用api引入，如 **</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">api <span class="hljs-string">&quot;com.thirdpart.app:app:1.0&quot;</span><br><br></code></pre></td></tr></table></figure><p>类似地新建其他几个lib库模块lib-log、lib-push、lib-apptool、lib-socket。</p><h3 id="2-2-common库"><a href="#2-2-common库" class="headerlink" title="2.2 common库"></a>2.2 common库</h3><p>lib-common和基础库同样是lib库模块，搭建的方法相同，不同点在于lib-common模块通过 ‘compile project’ 依赖其它所有的基础库模块，并直接被其它应用模块所依赖，实现向应用模块提供服务。</p><p>新建lib-common后，build.gradle配置如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs gradle">apply plugin: <span class="hljs-string">&#x27;com.android.library&#x27;</span><br><br>android &#123;<br>    compileSdkVersion rootProject.ext.compileSdkVersion<br><br>    defaultConfig &#123;<br>        minSdkVersion rootProject.ext.minSdkVersion<br>        targetSdkVersion rootProject.ext.targetSdkVersion<br>        versionCode rootProject.ext.versionCode<br>        versionName rootProject.ext.versionName<br><br>        testInstrumentationRunner <span class="hljs-string">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        debug &#123;<br><br>        &#125;<br>        release &#123;<br>            minifyEnabled <span class="hljs-keyword">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-keyword">fileTree</span>(dir: <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-keyword">include</span>: [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br><br>    <span class="hljs-comment">// Support Libary</span><br>    <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.android.support:design:$rootProject.supportVersion&quot;</span><br>    <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.android.support:cardview-v7:$rootProject.supportVersion&quot;</span><br>    <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.android.support:appcompat-v7:$rootProject.supportVersion&quot;</span><br>    <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.android.support:recyclerview-v7:$rootProject.supportVersion&quot;</span><br>    <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.android.support.constraint:constraint-layout:1.1.3&quot;</span><br><br>    <span class="hljs-comment">// Test</span><br>    testImplementation <span class="hljs-string">&#x27;junit:junit:4.12&#x27;</span><br><br>    <span class="hljs-comment">// 其它基础库模块</span><br>    <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:lib-ui&#x27;</span>)<br>    <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:lib-log&#x27;</span>)<br>    <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:lib-push&#x27;</span>)<br>    <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:lib-router&#x27;</span>)<br>    <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:lib-socket&#x27;</span>)<br>    <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:lib-apptool&#x27;</span>)<br><br>    api <span class="hljs-string">&quot;com.google.code.gson:gson:$rootProject.gsonVersion&quot;</span><br><br>    <span class="hljs-comment">// Rx</span><br>    api <span class="hljs-string">&quot;io.reactivex.rxjava2:rxjava:$rootProject.rxJavaVersion&quot;</span><br>    api <span class="hljs-string">&quot;io.reactivex.rxjava2:rxandroid:$rootProject.rxAndroidVersion&quot;</span><br>    <span class="hljs-comment">// RxBinding</span><br>    api <span class="hljs-string">&quot;com.jakewharton.rxbinding:rxbinding:$rootProject.rxBindingVersion&quot;</span><br>    api <span class="hljs-string">&quot;com.jakewharton.rxbinding:rxbinding-appcompat-v7:$rootProject.rxBindingVersion&quot;</span><br>    api <span class="hljs-string">&quot;com.jakewharton.rxbinding:rxbinding-recyclerview-v7:$rootProject.rxBindingVersion&quot;</span><br>    api <span class="hljs-string">&quot;com.jakewharton.rxbinding:rxbinding-design:$rootProject.rxBindingVersion&quot;</span><br><br>    <span class="hljs-comment">// RxPermission</span><br>    api <span class="hljs-string">&quot;com.github.tbruyelle:rxpermissions:$rootProject.rxPermissionVersion&quot;</span><br>    <span class="hljs-comment">// network</span><br>    api <span class="hljs-string">&quot;com.squareup.okhttp3:okhttp:$rootProject.okHttpVersion&quot;</span><br>    api <span class="hljs-string">&quot;com.squareup.okhttp3:logging-interceptor:$rootProject.okHttpVersion&quot;</span><br>    api <span class="hljs-string">&quot;com.squareup.retrofit2:retrofit:$rootProject.retrofitVersion&quot;</span><br>    api <span class="hljs-string">&quot;com.squareup.retrofit2:converter-gson:$rootProject.retrofitVersion&quot;</span><br>    api <span class="hljs-string">&quot;com.squareup.retrofit2:adapter-rxjava:$rootProject.retrofitVersion&quot;</span><br>    <span class="hljs-comment">// EventBus</span><br>    api <span class="hljs-string">&quot;org.greenrobot:eventbus:$rootProject.eventBusVersion&quot;</span><br><br>    <span class="hljs-comment">// RefreshLayout</span><br>    api <span class="hljs-string">&#x27;com.scwang.smartrefresh:SmartRefreshLayout:1.1.0-alpha-14&#x27;</span><br>    api <span class="hljs-string">&#x27;com.scwang.smartrefresh:SmartRefreshHeader:1.0.3&#x27;</span><span class="hljs-comment">//没有使用特殊Header，可以不加这行</span><br><br>    <span class="hljs-comment">// Views</span><br>    api(<span class="hljs-string">&quot;com.airbnb.android:lottie:$rootProject.lottieVersion&quot;</span>) &#123;<br>        <span class="hljs-keyword">exclude</span> <span class="hljs-keyword">group</span>: <span class="hljs-string">&#x27;com.android.support&#x27;</span><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="2-3-业务模块"><a href="#2-3-业务模块" class="headerlink" title="2.3 业务模块"></a>2.3 业务模块</h3><p>业务模块如app-mine(个人中心)、app-message(消息中心)等既可作为应用模块独立运行，也可作为库模块被空壳app依赖，新建业务模块 File-&gt;New Module-&gt;Phone &amp; Tablet Module，</p><p><img src="https://blogres.blackist.org/android-modulize-common-new-app-module-message.png"></p><p>app-message模块中build.gradle配置如下</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 模块切换至应用模块或库模块</span><br><span class="hljs-keyword">if</span> (moduling.toBoolean()) &#123;<br>    apply plugin: <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    apply plugin: <span class="hljs-string">&#x27;com.android.library&#x27;</span><br>&#125;<br><br>android &#123;<br>    compileSdkVersion rootProject.ext.compileSdkVersion<br><br>    defaultConfig &#123;<br>        minSdkVersion rootProject.ext.minSdkVersion<br>        targetSdkVersion rootProject.ext.targetSdkVersion<br>        versionCode rootProject.ext.versionCode<br>        versionName rootProject.ext.versionName<br><br>        testInstrumentationRunner <span class="hljs-string">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-keyword">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 为避免资源冲突，为不同模块的资源加上前缀，资源文件前缀手动加入</span><br>    resourcePrefix <span class="hljs-string">&#x27;message_&#x27;</span><br><br>    <span class="hljs-comment">// 库模块和应用模块使用不同的Manifest.xml和Application</span><br>    <span class="hljs-keyword">sourceSets</span> &#123;<br>        main &#123;<br>            <span class="hljs-keyword">if</span> (moduling.toBoolean()) &#123;<br>                <span class="hljs-comment">// 注意，粘贴代码时mainfest容易变成Manifest</span><br>                manifest.srcFile <span class="hljs-string">&#x27;src/main/debug/AndroidManifest.xml&#x27;</span><br>                <span class="hljs-keyword">println</span> <span class="hljs-string">&#x27;[Module-Message]: Appling Application...&#x27;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                manifest.srcFile <span class="hljs-string">&#x27;src/main/AndroidManifest.xml&#x27;</span><br>                java &#123;<br>                    <span class="hljs-keyword">exclude</span> <span class="hljs-string">&#x27;debug/**&#x27;</span><br>                &#125;<br>                <span class="hljs-keyword">println</span> <span class="hljs-string">&#x27;[Module-Message]: Appling Library...&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-keyword">fileTree</span>(dir: <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-keyword">include</span>: [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br>    implementation <span class="hljs-string">&#x27;com.android.support:support-v4:26.1.0&#x27;</span><br><br>    <span class="hljs-comment">// 依赖 common 库模块</span><br>    <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:lib-common&#x27;</span>)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>如上的gradle配置涉及到单组件运行调试、组件间资源文件冲突。</p><blockquote><p>粘贴代码时 manifest.srcFile 容易变成 Manifest.srcFile</p></blockquote><h3 id="2-4-空壳app模块"><a href="#2-4-空壳app模块" class="headerlink" title="2.4 空壳app模块"></a>2.4 空壳app模块</h3><p>空壳app是作为应用模块的“组合车间”，通过依赖不同的&#x2F;所有的应用模块，将各个功能模块的功能聚合起来，实现app应有的功能，app模块中包含：</p><ul><li>build.gradle </li><li>app的名称、图标</li><li>全局的Application文件</li></ul><p>build.gradle如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gradle">apply plugin: <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br>android &#123;<br>    compileSdkVersion rootProject.ext.compileSdkVersion<br><br>    defaultConfig &#123;<br>        minSdkVersion rootProject.ext.minSdkVersion<br>        targetSdkVersion rootProject.ext.targetSdkVersion<br>        versionCode rootProject.ext.versionCode<br>        versionName rootProject.ext.versionName<br><br>        testInstrumentationRunner <span class="hljs-string">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><br>        <span class="hljs-comment">// jni配置</span><br>        ndk &#123;<br>            abiFilters <span class="hljs-string">&#x27;armeabi&#x27;</span>, <span class="hljs-string">&#x27;armeabi-v7a&#x27;</span>, <span class="hljs-string">&#x27;arm64-v8a&#x27;</span><br>        &#125;<br>    &#125;<br><br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-keyword">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 资源文件前缀</span><br>    resourcePrefix <span class="hljs-string">&#x27;app_&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-keyword">fileTree</span>(dir: <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-keyword">include</span>: [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br><br>    <span class="hljs-keyword">if</span> (moduling.toBoolean()) &#123;<br>        <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:lib-common&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 依赖需要的应用模块</span><br>        <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:app-main&#x27;</span>)<br>        <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:app-mine&#x27;</span>)<br>        <span class="hljs-keyword">compile</span> <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:app-message&#x27;</span>)<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>app名称、图标配置在空壳中方便全局修改；</p><p>app还包含Application文件，在此做一些初始化操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CommonApplication</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br><br>        BLog.d(<span class="hljs-string">&quot;[App]: Application Starting...&quot;</span>);<br><br>        initRouter();<br><br>        <span class="hljs-keyword">if</span> (shouldInit()) &#123;<br>            PushClient.getInstance().init(<span class="hljs-built_in">this</span>)..setListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PushHandler</span>());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>除此之外，空壳app不包含任何逻辑、业务代码，登录注册页、欢迎页、主界面包含在app-main中，也是作为应用模块被app依赖。app模块是真正意义上的空壳。</p><h2 id="三、单模块调试"><a href="#三、单模块调试" class="headerlink" title="三、单模块调试"></a>三、单模块调试</h2><h3 id="3-1-模块动态切换"><a href="#3-1-模块动态切换" class="headerlink" title="3.1 模块动态切换"></a>3.1 模块动态切换</h3><p>app-message模块里builld.gradle开头的moduling配置在gradle.properties中，为boolean类型，</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># debug settings</span><br><span class="hljs-attr">moduling</span>=<span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><p>通过配置moduling的值，实现app-message作为独立应用模块或库模块的切换。</p><p>当build.gradle的apply plugin配置为’com.android.application’时，app-message作为应用模块：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">apply plugin: <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br></code></pre></td></tr></table></figure><p>此时模块图标为 <img src="https://blogres.blackist.org/android-modulize-common-module-lib-icon.png"></p><p>当build.gradle的apply plugin配置为’com.android.library’时，app-message作为库模块：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">apply plugin: <span class="hljs-string">&#x27;com.android.library&#x27;</span><br><br></code></pre></td></tr></table></figure><p>此时模块图标为 <img src="https://blogres.blackist.org/android-modulize-common-module-app-icon.png"></p><h3 id="3-2-使用不同的Manifest和Application"><a href="#3-2-使用不同的Manifest和Application" class="headerlink" title="3.2 使用不同的Manifest和Application"></a>3.2 使用不同的Manifest和Application</h3><p>在应用模块的build.gradle中有如下配置：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gradle">...<br><br>android &#123;<br>    ...<br><br>    <span class="hljs-comment">// 库模块和应用模块使用不同的 Manifest.xml 和 Application </span><br>    <span class="hljs-keyword">sourceSets</span> &#123;<br>        main &#123;<br>            <span class="hljs-keyword">if</span> (moduling.toBoolean()) &#123;<br>                <span class="hljs-comment">// 注意，粘贴代码时mainfest容易变成Manifest</span><br>                manifest.srcFile <span class="hljs-string">&#x27;src/main/debug/AndroidManifest.xml&#x27;</span><br>                <span class="hljs-keyword">println</span> <span class="hljs-string">&#x27;[Module-Message]: Appling Application...&#x27;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                manifest.srcFile <span class="hljs-string">&#x27;src/main/AndroidManifest.xml&#x27;</span><br>                java &#123;<br>                    <span class="hljs-keyword">exclude</span> <span class="hljs-string">&#x27;debug/**&#x27;</span><br>                &#125;<br>                <span class="hljs-keyword">println</span> <span class="hljs-string">&#x27;[Module-Message]: Appling Library...&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当模块为独立应用模块时，模块使用 ‘src&#x2F;main&#x2F;debug&#x2F;‘下的AndroidManifest.xml，当模块作为库模块被app空壳依赖时，使用’src&#x2F;main’下的AndroidManifest.xml。</p><p>‘src&#x2F;main&#x2F;debug&#x2F;AndroidManifest.xml’配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;org.blackist.modulize.message&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/message_app_name&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:roundIcon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:supportsRtl</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/message_AppTheme&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.view.MessageActivity&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>单模块调试时需要有独立的启动Activity、图标、app名称，如果需要独立的Application进行初始化操作，也在此配置。</p><p>‘src&#x2F;main&#x2F;AndroidManifest.xml’配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;org.blackist.modulize.message&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.view.MessageActivity&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>作为库模块被依赖时，只需要在Manifest中注册activity、service等即可。</p><p>单模块开发、调试的时候，activity的配置只注册在debug下的Manifest，请记得手动拷贝至main下Manifest中。</p><h2 id="四、资源冲突合并问题"><a href="#四、资源冲突合并问题" class="headerlink" title="四、资源冲突合并问题"></a>四、资源冲突合并问题</h2><p>不同模块中资源文件难免会有相似的资源文件，比如app-message有个list_icon的drawable、app-main中也有个list_icon的drawable，非单模块调试的时候需要合并资源文件，聚合在app空壳中，此时会引起资源冲突。</p><p>一种比较好的实践就是在各模块中添加资源前缀，尽量避免冲突，这要求项目组成员遵守规范，即资源命名为message_list_icon和main_list_icon。</p><p>xml中资源可以被android studio检查，如string.xml或color.xml中的资源，但图片类的资源不会被检查，需要开发者严格遵守约定。</p><p>组件化开发还有个问题就是，在各应用模块中使用if-else判断资源id，而不是switch，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(R.id.message_list_icon == id) &#123;<br>    ...<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (R.id.message_list_text == id) &#123;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="五、组件间通信"><a href="#五、组件间通信" class="headerlink" title="五、组件间通信"></a>五、组件间通信</h2><p>因为应用模块(app-xxx)依赖库模块(lib-xxx)，所以应用模块可以直接使用库模块中的View控件和方法，而应用模块之间项目隔离，无法直接使用其它模块的控件和方法，需要使用组件间通信工具来协助完成。</p><p>使用广播、EventBus会有一些相应的问题，比较好的一种实践就是阿里巴巴开源的ARouter以及一些自定义的组件间通信框架如<a href="/2018/10/23/android-modulize-router/">Brouter</a>，组件间通信在组件化开发中经常使用。</p><h3 id="5-1-app-main主界面的实现"><a href="#5-1-app-main主界面的实现" class="headerlink" title="5.1 app-main主界面的实现"></a>5.1 app-main主界面的实现</h3><p>主界面有三部分主页、消息中心、个人中心，主页一般在核心的业务逻辑模块中，消息中心页在app-message模块中，个人中心页在app-mine模块中。</p><p>app-main中MainActivity负责处理三个页面的展示和切换，即一个Activity包含三个Fragment，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-keyword">private</span> BaseFragment currentFragment;<br><span class="hljs-keyword">private</span> BaseFragment mainFragment;<br><span class="hljs-keyword">private</span> BaseFragment mineFragment;<br><span class="hljs-keyword">private</span> BaseFragment messageFragment;<br><br>...<br><br><span class="hljs-type">BRouterRes</span> <span class="hljs-variable">roomRes</span> <span class="hljs-operator">=</span> BRouter.push(<br>        getApplicationContext(),<br>        BRouterReq.build().action(<span class="hljs-string">&quot;room&quot;</span>).path(<span class="hljs-string">&quot;room/home&quot;</span>)<br>);<br>mainFragment = (BaseFragment) roomRes.data();<br><br><span class="hljs-type">BRouterRes</span> <span class="hljs-variable">mineRes</span> <span class="hljs-operator">=</span> BRouter.push(<br>        getApplicationContext(),<br>        BRouterReq.build().action(<span class="hljs-string">&quot;mine&quot;</span>).path(<span class="hljs-string">&quot;/mine/info&quot;</span>)<br>);<br>mineFragment = (BaseFragment) mineRes.data();<br><br><span class="hljs-type">BRouterRes</span> <span class="hljs-variable">messageRes</span> <span class="hljs-operator">=</span> BRouter.push(<br>        getApplicationContext(),<br>        BRouterReq.build().action(<span class="hljs-string">&quot;message&quot;</span>).path(<span class="hljs-string">&quot;/message/info&quot;</span>)<br>);<br>messageFragment = (BaseFragment) messageRes.data();<br><br><span class="hljs-comment">// fragment 展示</span><br>...<br><br></code></pre></td></tr></table></figure><h3 id="5-2-跨模块数据访问"><a href="#5-2-跨模块数据访问" class="headerlink" title="5.2 跨模块数据访问"></a>5.2 跨模块数据访问</h3><h4 id="直接返回数据"><a href="#直接返回数据" class="headerlink" title="直接返回数据"></a>直接返回数据</h4><p>类似于获取其它模块的Fragment，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BRouterRes</span> <span class="hljs-variable">roomRes</span> <span class="hljs-operator">=</span> BRouter.push(<br>        getApplicationContext(),<br>        BRouterReq.build().action(<span class="hljs-string">&quot;room&quot;</span>).path(<span class="hljs-string">&quot;room/home&quot;</span>)<br>);<br>mainFragment = (BaseFragment) roomRes.data();<br><br></code></pre></td></tr></table></figure><h4 id="startActivityForResult"><a href="#startActivityForResult" class="headerlink" title="startActivityForResult"></a>startActivityForResult</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BRouterRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> BRouter.push(<br>        getContext(),<br>        BRouterReq.build().action(<span class="hljs-string">&quot;repair&quot;</span>).path(<span class="hljs-string">&quot;repair/main/clazz&quot;</span>));<br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(getActivity(), (Class) res.data());<br>intent.putExtra(<span class="hljs-string">&quot;COMMAD&quot;</span>, <span class="hljs-string">&quot;func&quot;</span>);<br>getActivity().startActivityForResult(intent, REQUEST_CODE);<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode, <span class="hljs-type">int</span> resultCode, Intent data)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onActivityResult(requestCode, resultCode, data);<br>    ...<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>组件化开发基本架构到此已有雏形，可以进行简单的业务功能开发。</p><p>项目Github地址：<a href="https://github.com/blackist/modulize">https://github.com/blackist/modulize</a></p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>组件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-basic</title>
    <link href="/2018-09-29-java-basic/"/>
    <url>/2018-09-29-java-basic/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java 基础语法应用</p><span id="more"></span><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><hr><p>参考<a href="https://blog.csdn.net/shikangkai/article/details/50273527">类型判断</a></p><h4 id="判断是否实现接口"><a href="#判断是否实现接口" class="headerlink" title="判断是否实现接口"></a>判断是否实现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IsAssignableFromTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;  <br>  <br>    <span class="hljs-comment">/** 序列号 */</span>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">5716955136475665579L</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>          <br>        <span class="hljs-comment">//测试是否实现了父类  </span><br>        <span class="hljs-type">boolean</span> re1= Object.class.isAssignableFrom(IsAssignableFromTest.class);  <br>        <span class="hljs-comment">//测试是否实现了接口  </span><br>        <span class="hljs-type">boolean</span> re2=Serializable.class.isAssignableFrom(IsAssignableFromTest.class);  <br>          <br>        System.out.println(<span class="hljs-string">&quot;re1:&quot;</span>+re1+<span class="hljs-string">&quot; re2:&quot;</span>+re2);  <br>    &#125;  <br>&#125;  <br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Enum with String</title>
    <link href="/2018-09-29-java-basic-enum-string/"/>
    <url>/2018-09-29-java-basic-enum-string/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>java 中 Enum包含String类型的值可以有很好的应用，定义ErrorCode以及在数据库交互中都很方便。  </p><span id="more"></span><ul><li>使用Enum做error code字典，定义包含String值的Enum:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CODE</span> &#123;<br>OK(<span class="hljs-string">&quot;OK&quot;</span>),<br>ERROR(<span class="hljs-string">&quot;ERROR&quot;</span>)<br>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String msg;<br><br>CODE(<span class="hljs-keyword">final</span> String msg) &#123;<br><span class="hljs-built_in">this</span>.msg = msg;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.msg;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.msg;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>用values()方法遍历enum包含的所有value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (CODE code : CODE.values()) &#123;<br>System.out.println(code.name() + <span class="hljs-string">&quot;:&quot;</span> + code.getMsg());<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>可以通过自定义的方法获取单个Enum的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Sytem.out.println(CODE.OK.getMsg());<br><br><br></code></pre></td></tr></table></figure><p>通过name获取Enum类型的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(CODE.valueOf(<span class="hljs-string">&quot;OK&quot;</span>));<br><br></code></pre></td></tr></table></figure><p>也可以自定义方法通过value获取Enum的name</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CODE</span> &#123;<br>OK(<span class="hljs-string">&quot;OK&quot;</span>),<br>ERROR(<span class="hljs-string">&quot;ERROR&quot;</span>)<br>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String msg;<br><br>CODE(<span class="hljs-keyword">final</span> String msg) &#123;<br><span class="hljs-built_in">this</span>.msg = msg;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.msg;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.msg;<br>&#125;<br><br><span class="hljs-comment">// define dictionary for name/value</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, CODE&gt; lookup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-keyword">for</span> (CODE code : CODE.values()) &#123;<br>lookup.put(code.getMsg() : code);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CODE <span class="hljs-title function_">get</span><span class="hljs-params">(String msg)</span> &#123;<br><span class="hljs-keyword">return</span> loopup.get(msg);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用也很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CODE</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> CODE.get(<span class="hljs-string">&quot;OK&quot;</span>);<br><br><br></code></pre></td></tr></table></figure><ul><li>包含String的Enum在JPA中用作和数据库交互</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">QuestionClassify</span> &#123;<br>    SINGLE(<span class="hljs-string">&quot;SINGLE&quot;</span>),  <span class="hljs-comment">//HR</span><br>    MULTI(<span class="hljs-string">&quot;MULTI&quot;</span>), <span class="hljs-comment">//部门管理员</span><br>    ESSAY(<span class="hljs-string">&quot;ESSAY&quot;</span>), <span class="hljs-comment">//培训师</span><br>    EVALUATION(<span class="hljs-string">&quot;EVALUATION&quot;</span>); <span class="hljs-comment">//学生</span><br><br>    <span class="hljs-keyword">private</span> String type;<br><br>    RoleClassify(String type) &#123;<br>        <span class="hljs-built_in">this</span>.type = type;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript学习笔记</title>
    <link href="/2018-09-26-fe-prototype/"/>
    <url>/2018-09-26-fe-prototype/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端开发中 js 常用操作</p><span id="more"></span><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><hr><h4 id="变量类型-var-x2F-let-x2F-const"><a href="#变量类型-var-x2F-let-x2F-const" class="headerlink" title="变量类型 var&#x2F;let&#x2F;const"></a>变量类型 var&#x2F;let&#x2F;const</h4><p>Link: <a href="https://www.w3schools.com/js/js_let.asp">W3C let</a> &amp; <a href="https://www.w3schools.com/js/js_const.asp">W3C const</a> </p><p><strong>let</strong> 和 <strong>const</strong>  是ES2015引入的两个重要的关键字，用const定义的变量和let很相似，除了const变量不能重新赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.141592653589793</span>;<br><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;      <span class="hljs-comment">// This will give an error</span><br><span class="hljs-variable constant_">PI</span> = <span class="hljs-variable constant_">PI</span> + <span class="hljs-number">10</span>;   <span class="hljs-comment">// This will also give an error</span><br><br></code></pre></td></tr></table></figure><p>const 和 let 有着相似的<strong>块作用域</strong>，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// Here x is 10</span><br>&#123; <br>    <span class="hljs-keyword">const</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// Here x is 2</span><br>&#125;<br><span class="hljs-comment">// Here x is 10</span><br><br></code></pre></td></tr></table></figure><p>const变量必须在声明的时候赋值，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span>;<br><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14159265359</span>; <span class="hljs-comment">// Error</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14159265359</span>; <span class="hljs-comment">// Correct</span><br><br></code></pre></td></tr></table></figure><p>const很容易令人误解，const定义的不是常量，而是对一个值的常量引用，因此，不能改变const定义的常量原始的值，却可以改变常量对象的属性，但是仍然不能给const声明的引用重新赋对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.141592653589793</span>;<br><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;      <span class="hljs-comment">// This will give an error</span><br><span class="hljs-variable constant_">PI</span> = <span class="hljs-variable constant_">PI</span> + <span class="hljs-number">10</span>;   <span class="hljs-comment">// This will also give an error</span><br><br><span class="hljs-comment">// You can create a const object:</span><br><span class="hljs-keyword">const</span> car = &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;Fiat&quot;</span>, <span class="hljs-attr">model</span>:<span class="hljs-string">&quot;500&quot;</span>, <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;white&quot;</span>&#125;;<br><span class="hljs-comment">// You can change a property:</span><br>car.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;red&quot;</span>;<br><span class="hljs-comment">// You can add a property:</span><br>car.<span class="hljs-property">owner</span> = <span class="hljs-string">&quot;Johnson&quot;</span>;<br><br><span class="hljs-keyword">const</span> car = &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;Fiat&quot;</span>, <span class="hljs-attr">model</span>:<span class="hljs-string">&quot;500&quot;</span>, <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;white&quot;</span>&#125;;<br>car = &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;Volvo&quot;</span>, <span class="hljs-attr">model</span>:<span class="hljs-string">&quot;EX60&quot;</span>, <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>&#125;;    <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><hr><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><p>Object instanceof Type</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]<br>arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> <br>| arr.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span> <br>| (arr.<span class="hljs-property">prop</span> &amp;&amp; arr.<span class="hljs-property">prop</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>)<br><br><span class="hljs-keyword">var</span> auto = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Honda&#x27;</span>, <span class="hljs-string">&#x27;Accord&#x27;</span>, <span class="hljs-number">1998</span>)<br>auto <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Car</span><br>auto <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span><br><br></code></pre></td></tr></table></figure><p>typeof Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>);<br><span class="hljs-comment">// expected output: &quot;number&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;blubber&#x27;</span>);<br><span class="hljs-comment">// expected output: &quot;string&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// expected output: &quot;boolean&quot;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> declaredButUndefinedVariable);<br><span class="hljs-comment">// expected output: &quot;undefined&quot;;</span><br><br></code></pre></td></tr></table></figure><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 排序 arr =&gt; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>]<br>arr.<span class="hljs-title function_">sort</span>()<br><br><br><span class="hljs-comment">// array转string arr =&gt; &#x27;A,B,C&#x27;</span><br>arr.<span class="hljs-title function_">join</span>()<br><br></code></pre></td></tr></table></figure><h4 id="合并Object"><a href="#合并Object" class="headerlink" title="合并Object"></a>合并Object</h4><p>合并两个对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// merge b with a</span><br>a = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, a, b)<br><br></code></pre></td></tr></table></figure><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">var</span> filtered = array.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, arr</span>)&#123;<br><br>    <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">5</span>;<br><br>&#125;);<br><br><span class="hljs-comment">//filtered =&gt; [6, 7, 8, 9]</span><br><span class="hljs-comment">//array =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span><br><br></code></pre></td></tr></table></figure><p>数组拼接 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arrayA = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">var</span> arrayB = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> newArray = arrayA.<span class="hljs-title function_">concat</span>(arrayB);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FrontEnd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>前端</tag>
      
      <tag>开发技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mock.js</title>
    <link href="/2018-09-25-fe-api-mockjs/"/>
    <url>/2018-09-25-fe-api-mockjs/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端开发经常会遇见后端接口延期的情况，这个时候我们需要给自己造接口和数据。方法有很多种，最近接触到mockjs</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>FrontEnd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>js</tag>
      
      <tag>前端</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Sqlite</title>
    <link href="/2018-09-07-android-sqlite/"/>
    <url>/2018-09-07-android-sqlite/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SQLite是android的内置数据库，App开发中应用比较广泛，常见有三种使用场景，原生SQL基于SQLiteDatabase接口、ORM框架、ContentProvider+LoaderManager.</p><span id="more"></span><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><hr><p>使用Android SDK提供的SQLiteDatebase等接口，执行原生SQL语句，或调用接口内的方法insert()、update()、query()、delete()，其实质也是根据参数凭借SQL，下面是调用SQLiteDatabase接口方法的Demo，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SQLiteOpenHelper</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DB_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sdmp.db&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DB_VERSION</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TABLE_MESSAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;user&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DBHelper</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, DB_NAME, <span class="hljs-literal">null</span>, DB_VERSION);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> &#123;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sql.append(<span class="hljs-string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span>);<br>        sql.append(TABLE_MESSAGE);<br>        sql.append(<span class="hljs-string">&quot; (&quot;</span>);<br>        sql.append(<span class="hljs-string">&quot;id INTEGER PRIMARY KEY NOT NULL, &quot;</span>);<br>        sql.append(<span class="hljs-string">&quot;content TEXT, &quot;</span>);<br>        sql.append(<span class="hljs-string">&quot;date INTEGER&quot;</span>);<br>        sql.append(<span class="hljs-string">&quot;);&quot;</span>);<br>        db.execSQL(sql.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-type">int</span> oldVersion, <span class="hljs-type">int</span> newVersion)</span> &#123;<br>        db.execSQL(<span class="hljs-string">&quot;DROP TABLE IF EXISTS &quot;</span> + TABLE_MESSAGE);<br>        onCreate(db);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>定义数据访问类 MessageDao，调用DBHelper与数据库交互，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageDao</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MessageDao&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;id&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONTENT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;content&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DATE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;date&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> String[] MESSAGE_COLUMS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;date&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">private</span> Context context;<br>    <span class="hljs-keyword">private</span> DBHelper helper;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageDao</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.context = context;<br>        helper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DBHelper</span>(context);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String content, String date)</span> &#123;<br>        <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            db = helper.getReadableDatabase();<br>            db.beginTransaction();<br><br>            <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>            values.put(MessageDao.ID, ThreadLocalRandom.current().nextInt(<span class="hljs-number">1</span>, <span class="hljs-number">99999</span> + <span class="hljs-number">1</span>));<br>            values.put(MessageDao.CONTENT, content);<br>            values.put(MessageDao.DATE, date);<br>            db.insertOrThrow(DBHelper.TABLE_MESSAGE, <span class="hljs-string">&quot;null&quot;</span>, values);<br><br>            db.setTransactionSuccessful();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (db != <span class="hljs-literal">null</span>) &#123;<br>                db.endTransaction();<br>                db.close();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Message&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getReadableDatabase();<br>        <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> db.query(DBHelper.TABLE_MESSAGE, MESSAGE_COLUMS, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (cursor.getCount() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        List&lt;Message&gt; messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br>            messages.add(parseMessage(cursor));<br>        &#125;<br>        <span class="hljs-keyword">return</span> messages;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();<br>        db.beginTransaction();<br>        db.delete(DBHelper.TABLE_MESSAGE, <span class="hljs-string">&quot;id=?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;String.valueOf(id)&#125;);<br>        db.setTransactionSuccessful();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String content)</span> &#123;<br>        <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>        values.put(CONTENT, content);<br><br>        <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();<br>        db.beginTransaction();<br><br>        db.update(DBHelper.TABLE_MESSAGE, values, <span class="hljs-string">&quot;id=?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;String.valueOf(id)&#125;);<br>        db.setTransactionSuccessful();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Message <span class="hljs-title function_">parseMessage</span><span class="hljs-params">(Cursor cursor)</span> &#123;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>        message.setId(cursor.getInt(cursor.getColumnIndex(<span class="hljs-string">&quot;id&quot;</span>)));<br>        message.setContent(cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;content&quot;</span>)));<br>        message.setDate(cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;date&quot;</span>)));<br>        message.print();<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Message为实体类，接触过JDBC编程的童鞋应该比较熟悉比较业务实体类，数据库查询结果映射到实体类，业务层调用更加方便，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseEntity</span> &#123;<br><br>    <span class="hljs-type">int</span> id;<br>    String content;<br>    String date;<br><br>    ... get set<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用Android SDK自带的框架写SQL比较麻烦，但是最好开发者都可以经历这一步，踩了这些坑才可以更好的理解其它框架的好，同时练习一下SQL语句的编写。学习总是这么自下向上的。</p><p>当然Android自带的数据库操作始终是比较重的方式，手写SQL怎么都不算优美，并且字符串形式的SQL得不到任何编译器的检查，只有在运行时才会报错，增大程序异常的概率，实践证明ORM是比较简洁优雅的数据库交互方案。</p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><hr><p>常用ORM框架性能对比</p><p><img src="https://blogres.blackist.org/android-sqlite-android-sqlite-orm-framework-.png"></p><p>Realm的问题是不是sqlite，有自己独立的存储引擎，因此占用体积会比较大；<br>优点是专为移动端设计，也有iOS版本</p><p>Realm并不是传统的关系型数据库,有很多有用的特性,非常值得学习,官网有中文的wiki…. SqlBrite主要是提供了RxJava响应式的api,可以配合SqlDelight的代码生成一起使用,这两个比较轻量级….greenDao也开始支持RxJava了…..建议多了解greenDao和Realm,这两个的资料也比较多.</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>sqlite</tag>
      
      <tag>orm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓源码-保持屏幕旋转角度</title>
    <link href="/2018-08-24-android-source-screen-rotation/"/>
    <url>/2018-08-24-android-source-screen-rotation/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">updateRotationUncheckedLocked</span><span class="hljs-params">(<span class="hljs-type">boolean</span> inTransaction)</span> &#123;<br>...<br><br><span class="hljs-keyword">if</span> (DEBUG_ORIENTATION) &#123;<br>        Slog.v(TAG_WM, <span class="hljs-string">&quot;Selected orientation &quot;</span><br>                + mLastOrientation + <span class="hljs-string">&quot;, got rotation &quot;</span> + rotation<br>                + <span class="hljs-string">&quot; which has &quot;</span> + (altOrientation ? <span class="hljs-string">&quot;incompatible&quot;</span> : <span class="hljs-string">&quot;compatible&quot;</span>)<br>                + <span class="hljs-string">&quot; metrics&quot;</span>);<br>    &#125;<br><br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Add By e0040: Force show rotation .</span><br><span class="hljs-comment"> * Test using adb shell setprop sys.rotation.LANDSCAPE 0/90/180/270</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">switch</span> (SystemProperties.getInt(<span class="hljs-string">&quot;sys.rotation.LANDSCAPE&quot;</span>, <span class="hljs-number">0</span>)) &#123;<br>    <br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        rotation = Surface.ROTATION_0;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">90</span>: <br>        rotation = Surface.ROTATION_90;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">180</span>:<br>        rotation = Surface.ROTATION_180;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">270</span>:<br>        rotation = Surface.ROTATION_270;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">default</span>: <br>        rotation = Surface.ROTATION_0;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">adb shell setprop sys.rotation.LANDSCAPE <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String StringBuilder 和 StringBuffer</title>
    <link href="/2018-08-22-java-string-stringbufferbuilder/"/>
    <url>/2018-08-22-java-string-stringbufferbuilder/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>java中String, StringBuilder和StringBuffer都是常用的类型，熟悉它们各自的特性，可提高程序的健壮性和执行效率。</p><span id="more"></span><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NDK开发-JNI加密</title>
    <link href="/2018-08-10-android-jni-encrypt/"/>
    <url>/2018-08-10-android-jni-encrypt/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>java.lang.UnsatisfiedLinkError: No implementation found for java.lang.String cn.edu.zstu.sdmp.ble.controller.BleController.encode(java.lang.String) (tried Java_cn_edu_zstu_sdmp_ble_controller_BleController_encode and Java_cn_edu_zstu_sdmp_ble_controller_BleController_encode__Ljava_lang_String_2)</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><a href="https://developer.android.com/ndk/guides/abis">https://developer.android.com/ndk/guides/abis</a></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="输出路径"><a href="#输出路径" class="headerlink" title="输出路径"></a>输出路径</h3><p><a href="https://stackoverflow.com/questions/30865110/change-ndk-build-output-locations">https://stackoverflow.com/questions/30865110/change-ndk-build-output-locations</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/rd_w_csdn/article/details/53841018">https://blog.csdn.net/rd_w_csdn/article/details/53841018</a><br><a href="https://www.jianshu.com/p/d6750a920019">https://www.jianshu.com/p/d6750a920019</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>jni</tag>
      
      <tag>加密</tag>
      
      <tag>md5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于KOA的RESTful 脚手架</title>
    <link href="/2018-08-08-nodejs-koa/"/>
    <url>/2018-08-08-nodejs-koa/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开发中经常需要编写一些服务器测试脚本，测试自己的应用，且一些第三方服务器应用也可以基于noejs部署到服务器，学习基本的nodejs编程是有必要的。</p><p>nodejs编写服务端接口，用koa做主要框架，加入一些必要的中间件，并进行RESTful架构，搭建一个脚手架，项目地址 <a href="https://github.com/blackist/node-koa-restful">https://github.com/blackist/node-koa-restful</a></p><span id="more"></span><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><hr><p>clone此项目，项目结构如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cmd">├─.gitignore<br>├─controller.js<br>├─package-lock.json<br>├─package.json<br>├─README.<span class="hljs-built_in">md</span><br>├─server.js<br>├─service<br>|    └UserService.js<br>├─model<br>|   └User.js<br>├─controller<br>|     ├─UserController.js<br>|     ├─upload<br>|     |   └UploadController.js<br>├─conf<br>|  └db.js<br>├─common<br>|   ├─UploadFile.js<br>|   ├─util<br>|   |  └response.js<br>|   ├─error<br>|   |   ├─error-code.js<br>|   |   ├─error-common.js<br>|   |   └error-msg.js<br><br></code></pre></td></tr></table></figure><p>建立名为node-koa的MySQL数据库，可先修改数据库配置信息，在。conf&#x2F;db.js里，配置信息如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// node-koa 为数据库名称</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sequelize</span>(<span class="hljs-string">&#x27;node-koa&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>, &#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>  <span class="hljs-attr">dialect</span>: <span class="hljs-string">&#x27;mysql&#x27;</span>,<br>  <span class="hljs-attr">pool</span>: &#123;<br>    <span class="hljs-attr">max</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">idle</span>: <span class="hljs-number">10000</span><br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>进入项目目录运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># Command line <span class="hljs-built_in">cd</span> project directory<br><span class="hljs-built_in">cd</span> node-koa-restful<br><br># install dependencies<br>npm install <br><br># node run<br>node server.js<br><br></code></pre></td></tr></table></figure><p>初始化日志如下 </p><p><img src="https://blogres.blackist.org/node-koa-init.png"></p><p>接口访问 <a href="http://localhost:8080/v1/users/ids">http://localhost:8080/v1/users/ids</a></p><h3 id="框架解析"><a href="#框架解析" class="headerlink" title="框架解析"></a>框架解析</h3><hr><h4 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h4><p>koa-router作为请求转发路由</p>]]></content>
    
    
    <categories>
      
      <category>Nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>nodejs</tag>
      
      <tag>koa</tag>
      
      <tag>RESTful</tag>
      
      <tag>server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓视频录制-MediaCodec MediaMuxer</title>
    <link href="/2018-08-06-android-media-recorder/"/>
    <url>/2018-08-06-android-media-recorder/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>音视频</tag>
      
      <tag>MediaCodec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓开机自启动脚本</title>
    <link href="/2018-08-03-android-source-auto-run/"/>
    <url>/2018-08-03-android-source-auto-run/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为安卓系统添加自启动脚本，预安装app并进行系统设置. 间接实现app的静默安装.</p><p>基于项目的全智A64平台，安装自己开发的app，此app不会设置为系统预安装app, app更新的时候先下载到指定位置;<br>通过adb shell中 pm install 安装下载的更新，但pm 需要系统级权限，所以打算通过开机自启动脚本安装下载的apk, 即下载成功之后通过app重启Android系统完成安装。</p><span id="more"></span><h3 id="App重启Android系统"><a href="#App重启Android系统" class="headerlink" title="App重启Android系统"></a>App重启Android系统</h3><hr><h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android UI统一</title>
    <link href="/2018-06-28-android-ui-mipmap/"/>
    <url>/2018-06-28-android-ui-mipmap/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://frodoking.github.io/2015/07/01/android-theme/">http://frodoking.github.io/2015/07/01/android-theme/</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue - 基础应用</title>
    <link href="/2018-06-20-fe-vue-basic/"/>
    <url>/2018-06-20-fe-vue-basic/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vue 常用操作</p><span id="more"></span><h4 id="全局常量、函数"><a href="#全局常量、函数" class="headerlink" title="全局常量、函数"></a>全局常量、函数</h4><ul><li>Plugin</li></ul><p>新建 Constants.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><br>  <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue, options</span>) &#123;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">G</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(&#123;<br><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * ROLE OF SYSTEM USER</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-variable constant_">USER_ROLE</span> : &#123;<br>        <span class="hljs-attr">STU</span>: <span class="hljs-string">&#x27;Students&#x27;</span>,<br>        <span class="hljs-attr">TRAIN</span>: <span class="hljs-string">&#x27;Trains&#x27;</span>,<br>        <span class="hljs-attr">ADMIN</span>: <span class="hljs-string">&#x27;Admins&#x27;</span><br>      &#125;, <br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * num of question option.</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-variable constant_">OPTION_NUM</span> : &#123;<br>        <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>        <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;B&#x27;</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;C&#x27;</span><br>      &#125;<br>&#125;)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>新建 Function.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue, options</span>) &#123;<br> <br>     <span class="hljs-comment">// Class Method</span><br>     <span class="hljs-title class_">Date</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">format</span> = _format<br> <br>     <span class="hljs-comment">// F Method</span><br>     <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">F</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(&#123;<br>       clone : _clone<br>     &#125;)<br>   &#125;<br> &#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_format</span> () &#123;<br>  ...<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_clone</span> () &#123;<br>  ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 main.js 中引入 Constants.js、Function.js 并应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> G <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./common/Constants&#x27;</span><br><span class="hljs-keyword">import</span> F <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./common/Function&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(G)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(F)<br><br></code></pre></td></tr></table></figure><p>在 组件中可以直接调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;yyyyMMdd HH:mm:ss&#x27;</span>)<br><span class="hljs-keyword">let</span> _date = <span class="hljs-variable language_">this</span>.<span class="hljs-property">F</span>.<span class="hljs-title function_">clone</span>(date)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">G</span>.<span class="hljs-property">USER_ROLE</span>.<span class="hljs-property">STU</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">G</span>.<span class="hljs-property">OPTION_NUM</span>[<span class="hljs-number">0</span>])<br><br></code></pre></td></tr></table></figure><p>以上常量挂在使用 Object.freeze() 是安全操作，常量内容不会被改变；<br>常量挂载点 G、F 可省略，此处为全局调用方便区分；</p><ul><li>Vue.prototype</li></ul><p>直接使用 Vue.prototype 挂在常量，在 main.js 中挂载如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">USER_ROLE</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(&#123;<br>  <span class="hljs-variable constant_">STU</span> : <span class="hljs-string">&#x27;Stu&#x27;</span>,<br>  <span class="hljs-variable constant_">ADMIN</span> : <span class="hljs-string">&#x27;Admin&#x27;</span><br>&#125;)<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">clone</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) &#123;<br>  ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在组件中可以直接调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> date = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">clone</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">USER_ROLE</span>.<span class="hljs-property">STU</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FrontEnd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>js</tag>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android-menu</title>
    <link href="/2018-06-01-android-menu/"/>
    <url>/2018-06-01-android-menu/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android备忘录</title>
    <link href="/2018-05-10-android-basic-mark/"/>
    <url>/2018-05-10-android-basic-mark/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Android 备忘录</p><span id="more"></span><h2 id="Resouce"><a href="#Resouce" class="headerlink" title="Resouce"></a>Resouce</h2><h3 id="String-xml-占位符"><a href="#String-xml-占位符" class="headerlink" title="String.xml 占位符"></a>String.xml 占位符</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;string_test&quot;</span>&gt;</span>%1$d %2$s<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String.format(getString(R.string.string_test), <span class="hljs-number">20</span>, <span class="hljs-string">&quot;String&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://blogres.blackist.org/android-basic-complete_android_fragment_lifecycle.png"></p><p><img src="https://blogres.blackist.org/android-basic-primary_color.png"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android APK静默安装</title>
    <link href="/2018-04-30-android-auto-install/"/>
    <url>/2018-04-30-android-auto-install/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><br><p>实现真正意义上的静默安装，两种方式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pm install -r &lt;test.apk&gt;<br><br># 或 通过反射调用 <br><br>PackageManager.installPackage(...)<br><br></code></pre></td></tr></table></figure><p>使用pm 命令需要满足三个条件，使用反射机制要满足前两个条件</p><ul><li>在Manifest.xml根节点中加入 **android:sharedUserId&#x3D;”android.uid.system” **</li><li>为Apk加上系统平台数字签名</li><li>apk要预装在&#x2F;system&#x2F;app下面</li></ul><p>这些需要在有源码的基础上才可以做到，这些条件可如下实现。</p><span id="more"></span><h4 id="Manifest-xml"><a href="#Manifest-xml" class="headerlink" title="Manifest.xml"></a>Manifest.xml</h4><hr><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;site.your.package&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:sharedUserId</span>=<span class="hljs-string">&quot;android.uid.system&quot;</span>&gt;</span><br><br>...<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><hr><p>在安卓源码中拿到以下工具</p><ul><li>在android源码下 build&#x2F;target&#x2F;product&#x2F;security 找到两个密钥文件 platform.x509.pem platform.pk8</li><li>out&#x2F;host&#x2F;Linux-x86&#x2F;framework&#x2F;signapk.jar找到系统封装工具signapk.jar</li><li>使用命令给 build 好的apk进行签名</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">java -jar signapk.jar /<span class="hljs-built_in">path</span>/to/platform.x509.pem /<span class="hljs-built_in">path</span>/to/platform.pk8 /<span class="hljs-built_in">path</span>/to/test.apk /<span class="hljs-built_in">path</span>/to/test-sign.apk<br><br></code></pre></td></tr></table></figure><p>test-sign.apk</p><h4 id="系统预装App"><a href="#系统预装App" class="headerlink" title="系统预装App"></a>系统预装App</h4><hr><p>在如下路径创建目录 Test 存放对应的test-sign.apk (视平台而定)</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">android/device/softwinner/common/prebuild/apk/Test/test-sign.apk<br><br></code></pre></td></tr></table></figure><p>在该目录下创建Android.mk, 编辑</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Example</span><br>LOCAL_PATH :=<span class="hljs-variable">$(<span class="hljs-built_in">call</span> my-<span class="hljs-built_in">dir</span>)</span><br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(CLEAR_VARS)</span><br><span class="hljs-comment"># APK_MODULE_NAME(模块的唯一名字)</span><br>LOCAL_MODULE := Test<br>LOCAL_MODULE_TAGS := optional<br>LOCAL_CERTIFICATE := platform<br>LOCAL_DEX_PREOPT := false<br>LOCAL_MODULE_CLASS := APPS<br>LOCAL_MODULE_SUFFIX := <span class="hljs-variable">$(COMMON_ANDROID_PACKAGE_SUFFIX)</span><br>LOCAL_CERTIFICATE :=PRESIGNED<br><span class="hljs-comment"># apk的文件名</span><br>LOCAL_SRC_FILES := test-sign.apk<br><span class="hljs-comment"># 使用@直接引用apk内部的so</span><br>LOCAL_PREBUILD_JNI_LIBS :=@lib/<span class="hljs-variable">$(TARGET_ARCH)</span>/libjni.so<br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(BUILD_PREBUILT)</span><br><br></code></pre></td></tr></table></figure><p>在方案mk文件(device&#x2F;vendor-name&#x2F;device-name&#x2F;product-name.mk)中的 PRODUCT_PACKAGES项中加入:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">PRODUCT_PACKAGES += Test (模块的唯一名字)<br><br></code></pre></td></tr></table></figure><p>至此, app被提升为系统预装app, 系统启动后进入 adb shell, 可在 &#x2F;system&#x2F;app&#x2F; 下面看到Test.apk。</p><h3 id="反射调用-installPackage"><a href="#反射调用-installPackage" class="headerlink" title="反射调用 installPackage()"></a>反射调用 installPackage()</h3><hr><p>需要在项目根目录建立相关的package 和 class: </p><p><img src="https://blogres.blackist.org/android-auto-install-package.png" alt="静默安装"></p><p>IPackageDeleteObserver:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPackageDeleteObserver</span> &#123;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.Binder <span class="hljs-keyword">implements</span> <span class="hljs-title class_">android</span>.content.pm.IPackageDeleteObserver &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stub</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> android.content.pm.IPackageDeleteObserver <span class="hljs-title function_">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> android.os.IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTransact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-type">int</span> flags)</span><br>                <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">packageDeleted</span><span class="hljs-params">(java.lang.String packageName, <span class="hljs-type">int</span> returnCode)</span><br>            <span class="hljs-keyword">throws</span> android.os.RemoteException;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>IPackageInstallObserver:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPackageInstallObserver</span> &#123;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.Binder <span class="hljs-keyword">implements</span> <span class="hljs-title class_">android</span>.content.pm.IPackageInstallObserver &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stub</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> android.content.pm.IPackageInstallObserver <span class="hljs-title function_">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> android.os.IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTransact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-type">int</span> flags)</span><br>                <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">packageInstalled</span><span class="hljs-params">(java.lang.String packageName, <span class="hljs-type">int</span> returnCode)</span><br>            <span class="hljs-keyword">throws</span> android.os.RemoteException;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>PackageDeleteObserver:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageDeleteObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IPackageDeleteObserver</span>.Stub &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">packageDeleted</span><span class="hljs-params">(String packageName, <span class="hljs-type">int</span> returnCode)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>PackageInstallObserver:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackageInstallObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IPackageInstallObserver</span>.Stub &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">packageInstalled</span><span class="hljs-params">(String packageName, <span class="hljs-type">int</span> returnCode)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ContextPackageManager(类名自定义):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContextPackageManager</span> &#123;<br><br>    <span class="hljs-comment">//如果已经存在的包使用这个flag</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INSTALL_REPLACE_EXISTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x00000002</span>;<br>    <span class="hljs-comment">// install for all user</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INSTALL_ALL_USERS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x00000040</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installPackage</span><span class="hljs-params">(Context context, File apk)</span> &#123;<br><br>        <span class="hljs-type">PackageManager</span> <span class="hljs-variable">pm</span> <span class="hljs-operator">=</span> context.getPackageManager();<br>        Class&lt;?&gt;[] types = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Uri.class, IPackageInstallObserver.class, <span class="hljs-type">int</span>.class, String.class&#125;;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">installPackage</span> <span class="hljs-operator">=</span> pm.getClass().getMethod(<span class="hljs-string">&quot;installPackage&quot;</span>, types);<br>            installPackage.invoke(pm, Uri.fromFile(apk), <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageInstallObserver</span>(), INSTALL_ALL_USERS, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePackage</span><span class="hljs-params">(Context context, File apk)</span> &#123;<br><br>        <span class="hljs-type">PackageManager</span> <span class="hljs-variable">pm</span> <span class="hljs-operator">=</span> context.getPackageManager();<br>        Class&lt;?&gt;[] types = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Uri.class, IPackageInstallObserver.class, <span class="hljs-type">int</span>.class, String.class&#125;;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">installPackage</span> <span class="hljs-operator">=</span> pm.getClass().getMethod(<span class="hljs-string">&quot;installPackage&quot;</span>, types);<br>            installPackage.invoke(pm, Uri.fromFile(apk), <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageInstallObserver</span>(), INSTALL_REPLACE_EXISTING, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deletePackage</span><span class="hljs-params">(Context context)</span> &#123;<br><br>        <span class="hljs-type">PackageManager</span> <span class="hljs-variable">pm</span> <span class="hljs-operator">=</span> context.getPackageManager();<br>        Class&lt;?&gt;[] types = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, IPackageDeleteObserver.class, <span class="hljs-type">int</span>.class&#125;;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">deletePackage</span> <span class="hljs-operator">=</span> pm.getClass().getMethod(<span class="hljs-string">&quot;deletePackage&quot;</span>, types);<br>            deletePackage.invoke(pm, DeviceConfig.PACKAGE_NAME, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageDeleteObserver</span>(), <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用处一行代码即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ContextPackageManager.updatePackage(context, <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(appPath));<br><br></code></pre></td></tr></table></figure><h3 id="pm-insatll-命令安装"><a href="#pm-insatll-命令安装" class="headerlink" title="pm insatll 命令安装"></a>pm insatll 命令安装</h3><hr><p>调用pm 命令，如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ShellUtil.executeCommand(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;pm install -r /sdcard/.../test.apk&quot;</span>&#125;);<br><br></code></pre></td></tr></table></figure><p>ShellUtil.executeCommand():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCommand</span><span class="hljs-params">(String[] commands)</span> &#123;<br><span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">successResult</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">errorResult</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">successMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">errorMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            process = Runtime.getRuntime().exec(<span class="hljs-string">&quot;sh&quot;</span>);<br>            os = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(process.getOutputStream());<br>            <span class="hljs-keyword">for</span> (String command : commands) &#123;<br>                <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// donnot use os.writeBytes(commmand), avoid chinese charset error</span><br>                os.write(command.getBytes());<br>                os.writeBytes(<span class="hljs-string">&quot;exit\n&quot;</span>);<br>                os.flush();<br>            &#125;<br>            os.writeBytes(<span class="hljs-string">&quot;\n&quot;</span>);<br>            os.flush();<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> process.waitFor();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (os != <span class="hljs-literal">null</span>) &#123;<br>                    os.close();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (successResult != <span class="hljs-literal">null</span>) &#123;<br>                    successResult.close();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (errorResult != <span class="hljs-literal">null</span>) &#123;<br>                    errorResult.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (process != <span class="hljs-literal">null</span>) &#123;<br>                process.destroy();<br>            &#125;<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>pm静默安装参考<a href="http://www.trinea.cn/android/android-silent-install/">Trinea</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>发布android内测版本，并进行在线更新</title>
    <link href="/2018-04-30-android-publish-beta-apk/"/>
    <url>/2018-04-30-android-publish-beta-apk/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="使用第三方平台托管apk"><a href="#使用第三方平台托管apk" class="headerlink" title="使用第三方平台托管apk"></a>使用第三方平台托管apk</h4><hr><p>我在项目智能门禁开发中使用<a href="https://www.pgyer.com/">蒲公英</a>托管apk，方便快捷，创建自己的应用，上传apk发布即可完成。</p><p>创建应用后，每个应用有唯一的api_key，app_key，在调用<a href="https://www.pgyer.com/doc/view/api#paramInfo">蒲公英API</a>的时候，一定要使用到这两个参数。比如智能门禁应用的app_key，api_key如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">app_key</span>&gt;</span>f129*************************71af<span class="hljs-tag">&lt;/<span class="hljs-name">app_key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">api_key</span>&gt;</span>160e**********************491<span class="hljs-tag">&lt;/<span class="hljs-name">api_key</span>&gt;</span><br><br></code></pre></td></tr></table></figure><span id="more"></span><p>我在项目中主要用到两个api，</p><table><thead><tr><th align="center">Num</th><th align="left">API</th><th align="center">Method</th><th align="center">Param</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><a href="https://www.pgyer.com/apiv2/app/install">https://www.pgyer.com/apiv2/app/install</a></td><td align="center">GET</td><td align="center">_api_key&#x2F;app_key</td></tr><tr><td align="center">2</td><td align="left"><a href="https://www.pgyer.com/apiv2/app/check">https://www.pgyer.com/apiv2/app/check</a></td><td align="center">POST</td><td align="center">_api_key&#x2F;app_key</td></tr></tbody></table><p>第一个API用来下载最新版本的apk。<br>第二个API用来获取apk最新的版本信息，请求此API返回数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;buildBuildVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;14&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;downloadURL&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://www.pgyer.com/app/installUpdate/15556274e739c7c95961eb876ac8ed6c?sig=PYk7Mx4oeX3R2D4UxhPJApAQxK38WL89jX1azMriRNrDuijlFtS7sWZvVgWRUgrP&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;haveNewVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;buildVersionNo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;315&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;buildVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;72c7316&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;buildShortcutUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://www.pgyer.com/shanju_smartdoor&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;buildUpdateDescription&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1. 优化主题配色，提升用户体验&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;buildHaveNewVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我通过比较版本号检查是否有更新，获取app当前的版本号versionCode(float)与返回字段buildVersionNo(int)比较，若buildVersionNo&lt;buildVersionNo，说明有版本更新。获取versionCode的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getVersionCode</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">float</span> <span class="hljs-variable">versionCode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> DeviceApplication.getContext();<br>versionCode = context.getPackageManager().getPackageInfo(<br>context.getPackageName(), <span class="hljs-number">0</span>).versionCode;<br>&#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> versionCode;<br>&#125;<br></code></pre></td></tr></table></figure><p>若有更新则进行下载安装，下载链接包含在返回信息中，即为downloadURL。也可使用第二个API直接下载最新版本的apk。</p><h4 id="okHTTP实现下载"><a href="#okHTTP实现下载" class="headerlink" title="okHTTP实现下载"></a>okHTTP实现下载</h4>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>android</tag>
      
      <tag>发布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android JNI开发</title>
    <link href="/2018-04-14-Android-NDK/"/>
    <url>/2018-04-14-Android-NDK/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>NDK</tag>
      
      <tag>JNI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo博客</title>
    <link href="/2018-04-07-note-hexo-blog/"/>
    <url>/2018-04-07-note-hexo-blog/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><hr><p>在 <a href="https://hexo.io/themes/">HexoTheme</a> 查找主题，并找到对应的 github 地址，hexo 主题资源放置在 themes 下，所以要先将主题项目clone到这里， 以Maupassant为例</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">git clone git@github.com:tufu9441/maupassant-hexo.git    themes\maupassant<br><br></code></pre></td></tr></table></figure><p>更换主题只需在根目录的_config.yml中更改theme的值即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">concises</span><br><br></code></pre></td></tr></table></figure><span id="more"></span><p>不过多数主题需要依赖其他库来编译安装，Maupaasant需要先安装两个依赖</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install hexo-renderer-pug --save<br>npm install hexo-renderer-sass --save<br><br></code></pre></td></tr></table></figure><p>通过主题的_config.yml来个性化自己的博客样式，主题可能需要一并提交到代码库，这是需要删除主题项目下的git配置文件夹，否则git不能将含有git配置的文件夹提交到博客项目。</p><p><img src="https://blogres.blackist.org/note-hexo-themegit.png"></p><h3 id="添加文章浏览量（基于LeanCloud）"><a href="#添加文章浏览量（基于LeanCloud）" class="headerlink" title="添加文章浏览量（基于LeanCloud）"></a>添加文章浏览量（基于LeanCloud）</h3><hr><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在<a href="https://leancloud.cn/">LeanCloud</a> 注册账号，实名认证开发者，进入控制台创建应用</p><p><img src="https://blogres.blackist.org/note-hexo-views-newleancloud.png"></p><p>新创建的应用如下，进入应用，为我们的博客创建文章浏览统计Class</p><p><img src="https://blogres.blackist.org/note-hexo-views-leancloudapp.png"></p><p>创建名为Counter的类，权限设置为无限制，否则文章被浏览时阅读量增加会出问题</p><p><img src="https://blogres.blackist.org/note-hexo-views-newleancloudclass.png"></p><p>在应用的设置里拿到此应用的AppID&#x2F;AppKey,在配置博客来控制这个应用的时候需要使用此key，</p><p><img src="https://blogres.blackist.org/note-hexo-views-leancloudappkey.png"></p><p>在blog-&gt;设置-&gt;安全中心，设置Web安全域名，即当通过域名访问文章时，可从leancloud的容器读取文章的浏览量或写入浏览量，</p><p><img src="https://blogres.blackist.org/note-hexo-themeviewcounterweburl.png"></p><p>至此，博客添加浏览量功能的准备工作基本完成。当文章被访问，counter类容器会新增记录</p><p><img src="https://blogres.blackist.org/note-hexo-themeviewcounter.png"></p><h4 id="浏览量配置"><a href="#浏览量配置" class="headerlink" title="浏览量配置"></a>浏览量配置</h4><p>在当前theme的_config.yml添加leancloud节点，并写入 AppID&#x2F;AppKey</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># add post views</span><br><span class="hljs-attr">leancloud:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">app_id:</span> <span class="hljs-string">Sow*******************Hsz</span><br>  <span class="hljs-attr">app_key:</span> <span class="hljs-string">9Lo****************WOf3</span><br></code></pre></td></tr></table></figure><h4 id="·基于-ejs"><a href="#·基于-ejs" class="headerlink" title="·基于 .ejs"></a>·基于 .ejs</h4><p>在 theme&#x2F;layout&#x2F;_partial&#x2F;article.ejs中，找到header之类的标签，在适当位置加入如下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;% if (theme.leancloud.enable) &#123; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span>| view<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&lt;%- url_for(post.path) %&gt;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;leancloud_visitors&quot;</span> <span class="hljs-attr">data-title</span>=<span class="hljs-string">&quot;&lt;%= post.title %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>&lt;% &#125; %&gt;<br><br></code></pre></td></tr></table></figure><p>即在标题位置下加入浏览量标签，大致效果如下</p><p> | ——<img src="https://blogres.blackist.org/note-hexo-themetitleviews.png"></p><p>在 theme&#x2F;layout&#x2F;_widget下新建leancloud.ejs文件，加入如下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;% if (theme.leancloud.enable)&#123; %&gt;<br><span class="hljs-comment">&lt;!-- leancloud支持js文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 初始化应用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable constant_">AV</span>.<span class="hljs-title function_">initialize</span>(<span class="hljs-string">&quot;&lt;%= theme.leancloud.app_id %&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;%= theme.leancloud.app_key %&gt;&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showTime</span>(<span class="hljs-params">Counter</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> query = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">AV</span>.<span class="hljs-title class_">Query</span>(<span class="hljs-title class_">Counter</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;.leancloud_visitors&quot;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item.<span class="hljs-property">id</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> url = item.<span class="hljs-property">id</span>.<span class="hljs-title function_">trim</span>();</span><br><span class="language-javascript">        query.<span class="hljs-title function_">equalTo</span>(<span class="hljs-string">&quot;url&quot;</span>, url);</span><br><span class="language-javascript">        query.<span class="hljs-title function_">find</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">if</span> (results.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(url).<span class="hljs-property">innerHTML</span> = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">                    <span class="hljs-keyword">return</span>;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; results.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">var</span> object = results[i];</span><br><span class="language-javascript">                    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(url).<span class="hljs-property">innerHTML</span> = object.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;time&#x27;</span>);</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">object, error</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Error: &quot;</span> + error.<span class="hljs-property">code</span> + <span class="hljs-string">&quot; &quot;</span> + error.<span class="hljs-property">message</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addCount</span>(<span class="hljs-params">Counter</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = <span class="hljs-variable constant_">AV</span>.<span class="hljs-property">Object</span>.<span class="hljs-title function_">extend</span>(<span class="hljs-string">&quot;Counter&quot;</span>);</span><br><span class="language-javascript"><span class="hljs-comment">// url 和 title 为AV.query的两个参数，用来指定读取或新增指定文章的浏览量</span></span><br><span class="language-javascript">    url = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.leancloud_visitors&quot;</span>).<span class="hljs-property">id</span>.<span class="hljs-title function_">trim</span>();</span><br><span class="language-javascript">    title = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.leancloud_visitors&quot;</span>).<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-title&#x27;</span>).<span class="hljs-title function_">trim</span>();</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> query = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">AV</span>.<span class="hljs-title class_">Query</span>(<span class="hljs-title class_">Counter</span>);</span><br><span class="language-javascript">    query.<span class="hljs-title function_">equalTo</span>(<span class="hljs-string">&quot;url&quot;</span>, url);</span><br><span class="language-javascript">    query.<span class="hljs-title function_">find</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (results.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> counter = results[<span class="hljs-number">0</span>];</span><br><span class="language-javascript">                counter.<span class="hljs-title function_">fetchWhenSave</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript">                counter.<span class="hljs-title function_">increment</span>(<span class="hljs-string">&quot;time&quot;</span>);</span><br><span class="language-javascript">                counter.<span class="hljs-title function_">save</span>(<span class="hljs-literal">null</span>, &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">counter</span>) &#123;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(url).<span class="hljs-property">innerHTML</span> = counter.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;time&#x27;</span>);</span><br><span class="language-javascript">                    &#125;,</span><br><span class="language-javascript">                    <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">counter, error</span>) &#123;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Failed to save Visitor num, with error message: &#x27;</span> + error.<span class="hljs-property">message</span>);</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;);</span><br><span class="language-javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> newcounter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();</span><br><span class="language-javascript">                newcounter.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;title&quot;</span>, title);</span><br><span class="language-javascript">                newcounter.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;url&quot;</span>, url);</span><br><span class="language-javascript">                newcounter.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;time&quot;</span>, <span class="hljs-number">1</span>);</span><br><span class="language-javascript">                newcounter.<span class="hljs-title function_">save</span>(<span class="hljs-literal">null</span>, &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newcounter</span>) &#123;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;newcounter.get(&#x27;time&#x27;)=&quot;</span>+newcounter.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;time&#x27;</span>));</span><br><span class="language-javascript">                        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(url).<span class="hljs-property">innerHTML</span> = newcounter.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;time&#x27;</span>);</span><br><span class="language-javascript">                    &#125;,</span><br><span class="language-javascript">                    <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newcounter, error</span>) &#123;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Failed to create&#x27;</span>);</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error:&#x27;</span> + error.<span class="hljs-property">code</span> + <span class="hljs-string">&quot; &quot;</span> + error.<span class="hljs-property">message</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = <span class="hljs-variable constant_">AV</span>.<span class="hljs-property">Object</span>.<span class="hljs-title function_">extend</span>(<span class="hljs-string">&quot;Counter&quot;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 如果页面只有一个 leancloud_visitors 则认为它是文章页面</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 如果有多个，认为它是列表页</span></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.leancloud_visitors&#x27;</span>).<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;increase view&#x27;</span>)</span><br><span class="language-javascript">        <span class="hljs-title function_">addCount</span>(<span class="hljs-title class_">Counter</span>);</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.leancloud_visitors&#x27;</span>).<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;show views&#x27;</span>)</span><br><span class="language-javascript">        <span class="hljs-title function_">showTime</span>(<span class="hljs-title class_">Counter</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;)();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>&lt;% &#125; %&gt;<br><br></code></pre></td></tr></table></figure><p>在 theme&#x2F;layout&#x2F;layout.js引入此.ejs文件，即可实现单个文章的浏览量功能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%- partial(&#x27;_widget/leancloud&#x27;) %&gt;<br><br></code></pre></td></tr></table></figure><h3 id="部署到coding、github"><a href="#部署到coding、github" class="headerlink" title="部署到coding、github"></a>部署到coding、github</h3><hr><p>(待更…)</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>写作</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中文技术文档的写作规范</title>
    <link href="/2018-02-28-public-doc-rule/"/>
    <url>/2018-02-28-public-doc-rule/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自 <a href="https://github.com/ruanyf/document-style-guide/blob/ff59d51e10f1dbc293d898c37c25fac5fd5e250e/README.md">https://github.com/ruanyf/document-style-guide/blob/ff59d51e10f1dbc293d898c37c25fac5fd5e250e/README.md</a> 仅供自己学习备忘。</p><ul><li>标题</li><li>文本</li><li>段落</li><li>数值</li><li>标点符号</li><li>文档体系</li><li>参考链接</li></ul><span id="more"></span><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><p>标题分为四级。</p><ul><li>一级标题：文章的标题</li><li>二级标题：文章主要部分的大标题</li><li>三级标题：二级标题下面一级的小标题</li><li>四级标题：三级标题下面某一方面的小标题</li></ul><p>下面是示例。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><br><span class="hljs-section">## 二级标题</span><br><br><span class="hljs-section">### 三级标题</span><br><br><span class="hljs-section">#### 四级标题</span><br></code></pre></td></tr></table></figure><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>（1）一级标题下，不能直接出现三级标题。</p><p>示例：下面的文章结构，缺少二级标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><br><span class="hljs-section">### 三级标题</span><br></code></pre></td></tr></table></figure><p>（2）标题要避免孤立编号（即同级标题只有一个）。</p><p>示例：下面的文章结构，<code>二级标题 A</code>只包含一个三级标题，完全可以省略<code>三级标题 A</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 二级标题 A</span><br><br><span class="hljs-section">### 三级标题 A</span><br><br><span class="hljs-section">## 二级标题 B</span><br></code></pre></td></tr></table></figure><p>（3）下级标题不重复上一级标题的名字。</p><p>示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 概述</span><br><br><span class="hljs-section">### 概述</span><br></code></pre></td></tr></table></figure><p>（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</p><p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p><p>示例：下面的结构二要好于结构一。后者适用的场景，主要是较长篇幅的内容。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown">结构一<br><br><span class="hljs-section">### 三级标题</span><br><br><span class="hljs-section">#### 四级标题 A</span><br><br><span class="hljs-section">#### 四级标题 B</span><br><br><span class="hljs-section">#### 四级标题 C</span><br><br>结构二<br><br><span class="hljs-section">### 三级标题</span><br><br><span class="hljs-strong">**（1）A**</span><br><br><span class="hljs-strong">**（2）B**</span><br><br><span class="hljs-strong">**（3）C**</span><br></code></pre></td></tr></table></figure><h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><h2 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h2><p>全角中文字符与半角英文字符之间，应有一个半角空格。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：本文介绍如何快速启动Windows系统。<br><br>正确：本文介绍如何快速启动 Windows 系统。<br></code></pre></td></tr></table></figure><p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。<br><br>正确：2011 年<span class="hljs-number"> 5 </span>月<span class="hljs-number"> 15 </span>日，我订购了<span class="hljs-number"> 5 </span>台笔记本电脑与<span class="hljs-number"> 10 </span>台平板电脑。<br></code></pre></td></tr></table></figure><p>半角的百分号，视同阿拉伯数字。</p><p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">错误：一部容量为<span class="hljs-number"> 16 </span>GB 的智能手机<br><br>正确：一部容量为 16GB 的智能手机<br></code></pre></td></tr></table></figure><p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：他的电脑是 MacBook Air 。<br><br>正确：他的电脑是 MacBook Air。<br></code></pre></td></tr></table></figure><h2 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h2><ul><li>避免使用长句。句子内部不使用逗号时，总长度不应该超过 40 个字；使用逗号时，总长度不应该超过 100 字或者正文的 3 行。</li><li>尽量使用简单句和并列句，避免使用复合句。</li></ul><h2 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h2><p>1、尽量不使用被动语态，改为使用主动语态。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：假如此软件尚未被安装，<br><br>正确：假如尚未安装这个软件，<br></code></pre></td></tr></table></figure><p>2、不使用非正式的语言风格。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！<br><br>正确：无法参加本次活动，我深感遗憾。<br></code></pre></td></tr></table></figure><p>3、不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：这是唯二的快速启动的方法。<br><br>正确：这是仅有的两种快速启动的方法。<br></code></pre></td></tr></table></figure><p>4、用对“的”、“地”、“得”。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">她露出了开心的笑容。<br>（形容词＋的＋名词）<br><br>她开心地笑了。<br>（副词＋地＋动词）<br><br>她笑得很开心。<br>（动词＋得＋副词）<br></code></pre></td></tr></table></figure><p>5、使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。<br><br>正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。<br></code></pre></td></tr></table></figure><p>6、名词前不要使用过多的形容词。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。<br><br>正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。<br></code></pre></td></tr></table></figure><p>7、不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。<br><br>正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。<br></code></pre></td></tr></table></figure><p>8、同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：请确认没有接通装置的电源。<br><br>正确：请确认装置的电源已关闭。<br></code></pre></td></tr></table></figure><p>9、避免使用双重否定句。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：没有删除权限的用户，不能删除此文件。<br><br>正确：用户必须拥有删除权限，才能删除此文件。<br></code></pre></td></tr></table></figure><h2 id="英文处理"><a href="#英文处理" class="headerlink" title="英文处理"></a>英文处理</h2><p>英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">英文：⋯information stored <span class="hljs-keyword">in</span> random <span class="hljs-keyword">access</span> memory (RAMs)⋯<br><br>中文：……存储在随机存取存储器（RAM）里的信息……<br></code></pre></td></tr></table></figure><p>外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">U.S.A.<br>Apple, Inc.<br></code></pre></td></tr></table></figure><p>表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">英文：<span class="hljs-number">5</span> minutes <span class="hljs-keyword">later</span>⋯<br><br>中文：<span class="hljs-number">5</span> 分钟过去了⋯⋯<br></code></pre></td></tr></table></figure><p>英文书名或电影名改用中文表达时，双引号应改为书名号。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">英文：<span class="hljs-keyword">He</span> published <span class="hljs-keyword">an</span> article entitled <span class="hljs-string">&quot;The Future of the Aviation&quot;</span>.<br><br>中文：他发表了一篇名为《航空业的未来》的文章。<br></code></pre></td></tr></table></figure><p>第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。<br></code></pre></td></tr></table></figure><p>专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">“American Association <span class="hljs-keyword">of</span> Physicists <span class="hljs-keyword">in</span> Medicine”（美国医学物理学家协会）是专有名词，需要大写。<br><br>“online <span class="hljs-keyword">transaction</span> processing”（在线事务处理）不是专有名词，不应大写。<br></code></pre></td></tr></table></figure><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><h2 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h2><ul><li>一个段落只能有一个主题，或一个中心句子。</li><li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li><li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li><li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li><li>段落之间使用一个空行隔开。</li><li>段落开头不要留出空白字符。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用第三方内容时，应注明出处。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">One <span class="hljs-keyword">man</span>’s constant <span class="hljs-keyword">is</span> another <span class="hljs-keyword">man</span>’s variable. — Alan Perlis<br></code></pre></td></tr></table></figure><p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本文转载自 WikiQuote<br></code></pre></td></tr></table></figure><p>使用外部图片时，必须在图片下方或文末标明来源。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">本文部分图片来自 Wikipedia<br></code></pre></td></tr></table></figure><h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h2 id="半角数字"><a href="#半角数字" class="headerlink" title="半角数字"></a>半角数字</h2><p>数字一律使用半角形式，不得使用全角形式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">错误：</span> <span class="hljs-string">这件商品的价格是１０００元。</span><br><br><span class="hljs-string">正确：</span> <span class="hljs-string">这件商品的价格是</span> <span class="hljs-number">1000</span> <span class="hljs-string">元。</span><br></code></pre></td></tr></table></figure><h2 id="千分号"><a href="#千分号" class="headerlink" title="千分号"></a>千分号</h2><p>数值为千位以上，应添加千分号（半角逗号）。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">XXX</span> 公司的实收资本为 RMB1,<span class="hljs-number">258</span>,<span class="hljs-number">000</span>。<br></code></pre></td></tr></table></figure><p>对于 4 ～ 6 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于7位及以上的数值，千分号是必须的。</p><p>多位小数要从小数点后从左向右添加千分号，比如<code>4.234,345</code>。</p><h2 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h2><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$1</span>,000</span><br><span class="hljs-number">1</span>,<span class="hljs-number">000</span> 美元<br></code></pre></td></tr></table></figure><h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p><p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">错误：<span class="hljs-number">132</span>～<span class="hljs-number">234</span>kg<br>正确：<span class="hljs-number">132</span>kg～<span class="hljs-number">234</span>kg<br><br>错误：<span class="hljs-number">67</span>～<span class="hljs-number">89</span><span class="hljs-meta">%</span><br>正确：<span class="hljs-number">67</span><span class="hljs-meta">%</span>～<span class="hljs-number">89</span><span class="hljs-meta">%</span><br></code></pre></td></tr></table></figure><h2 id="变化程度的表示法"><a href="#变化程度的表示法" class="headerlink" title="变化程度的表示法"></a>变化程度的表示法</h2><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">增加到过去的两倍<br>（过去为一，现在为二）<br><br>增加了两倍<br>（过去为一，现在为三）<br></code></pre></td></tr></table></figure><p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">降低到百分之八十<br>（定额是一百，现在是八十）<br><br>降低了百分之八十<br>（原来是一百，现在是二十）<br></code></pre></td></tr></table></figure><p>不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p><h1 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h1><h2 id="原则-2"><a href="#原则-2" class="headerlink" title="原则"></a>原则</h2><ul><li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li><li>如果整句为英文，则该句使用英文&#x2F;半角标点。</li><li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li></ul><h2 id="句号"><a href="#句号" class="headerlink" title="句号"></a>句号</h2><p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p><p>句子末尾用括号加注时，句号应在括号之外。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">错误：关于文件的输出，请参照第 1.3 节（见第<span class="hljs-number"> 26 </span>页。）<br><br>正确：关于文件的输出，请参照第 1.3 节（见第<span class="hljs-number"> 26 </span>页）。<br></code></pre></td></tr></table></figure><h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><p>逗号<code>，</code>表示句子内部的一般性停顿。</p><p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p><h2 id="顿号"><a href="#顿号" class="headerlink" title="顿号"></a>顿号</h2><p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。<br><br>正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。<br></code></pre></td></tr></table></figure><p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">例句：Microsoft Office <span class="hljs-built_in">includes</span> Word, Excel, PowerPoint, Outlook and other components.<br></code></pre></td></tr></table></figure><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">例句：许多人都认为客户服务的核心是“友好”和“专业”。<br></code></pre></td></tr></table></figure><p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”<br></code></pre></td></tr></table></figure><h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">例句：请确认所有的连接（电缆和接插件）均安装牢固。<br></code></pre></td></tr></table></figure><h2 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h2><p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。<br></code></pre></td></tr></table></figure><p>表示时间时，应使用半角冒号（<code>:</code>）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">例句：早上 8:00<br></code></pre></td></tr></table></figure><h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p><p>省略号不应与“等”这个词一起使用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。<br><br>正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……<br><br>正确：我们为会餐准备了香蕉、苹果、梨等各色水果。<br></code></pre></td></tr></table></figure><h2 id="感叹号"><a href="#感叹号" class="headerlink" title="感叹号"></a>感叹号</h2><p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p><p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p><h2 id="破折号"><a href="#破折号" class="headerlink" title="破折号"></a>破折号</h2><p>破折号<code>————</code>一般用于进一步解释。</p><p>破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。<br><br>例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。<br></code></pre></td></tr></table></figure><h2 id="连接号"><a href="#连接号" class="headerlink" title="连接号"></a>连接号</h2><p>连接号用于连接两个类似的词。</p><p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p><ul><li>两个名词的复合</li><li>图表编号</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">例句：氧化-还原反应<br><br>例句：图 1<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p><ul><li>数值范围（例如日期、时间或数字）</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">例句：2009 年～2011 年<br></code></pre></td></tr></table></figure><p>注意，波浪连接号前后两个值都应该加上单位。</p><p>波浪连接号也可以用汉字“至”代替。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">例句：周围温度：<span class="hljs-operator">-</span><span class="hljs-number">20</span>°<span class="hljs-built_in">C</span> 至 <span class="hljs-operator">-</span><span class="hljs-number">10</span>°<span class="hljs-built_in">C</span><br></code></pre></td></tr></table></figure><h1 id="文档体系"><a href="#文档体系" class="headerlink" title="文档体系"></a>文档体系</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>软件手册是一部完整的书，建议采用下面的结构。</p><ul><li><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li><li><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</li><li><strong>入门篇</strong>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程<ul><li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li><li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li><li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li></ul></li><li><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li><li><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</li><li><strong>FAQ</strong>：[可选] [文件] 常见问题解答</li><li><strong>附录</strong>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容<ul><li><strong>Glossary</strong>：[可选] [文件] 名词解释</li><li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li><li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li><li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li><li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li></ul></li></ul><p>下面是两个真实范例，可参考。</p><ul><li><a href="http://redux.js.org/index.html">Redux 手册</a></li><li><a href="http://flight-manual.atom.io/">Atom 手册</a></li></ul><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos">错误： 名词解释.<span class="hljs-built_in">md</span><br><br>正确： glossary.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos">错误：TroubleShooting.<span class="hljs-built_in">md</span><br><br>正确：troubleshooting.<span class="hljs-built_in">md</span> <br></code></pre></td></tr></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos">不佳：advanced_usage.<span class="hljs-built_in">md</span><br><br>正确：advanced-usage.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html">产品手册中文写作规范</a>, by 华为</li><li><a href="http://docs.daocloud.io/write-docs/format">写作规范和格式规范</a>, by DaoCloud</li><li><a href="http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf">技术写作技巧在日汉翻译中的应用</a>, by 刘方</li><li><a href="https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf">简体中文规范指南</a>, by lengoo</li><li><a href="https://open.leancloud.cn/copywriting-style-guide.html">文档风格指南</a>, by LeanCloud</li><li><a href="https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit">豌豆荚文案风格指南</a>, by 豌豆荚</li><li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines">中文文案排版指北</a>, by sparanoid</li><li><a href="http://w3c.github.io/clreq/">中文排版需求</a>, by W3C</li><li><a href="http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html">为什么文件名要小写？</a>, by 阮一峰</li><li><a href="https://developers.google.com/style/">Google Developer Documentation Style Guide</a>, by Google</li></ul><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>公共领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>公共领域</tag>
      
      <tag>文档规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开启写作之旅</title>
    <link href="/2017-12-25-HexoWriting/"/>
    <url>/2017-12-25-HexoWriting/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hello Everyone!</p><p>曾今思考为什么写作，也曾为了写作折腾过博客，于是把自己淹没在为学习做准备的长河里，但从未学习过（笑自己三秒）。</p><p>现在渐渐懂得，写作最重要的就是【记录】。</p><span id="more"></span><p>记录自己的学习过程；<br>记录自己的成长历程；<br>记录自己转瞬即逝的想法；<br>记录自己的感情；<br>记录自己的爱情；<br>记录自己的亲情和家人；<br>记录没什么比这些更可贵的东西…</p><p>其次重要的是【分享】。</p><p>分享自己的学习心得；<br>分享自己的人生感悟；<br>分享自己的喜怒哀乐；<br>分享自己平凡但精彩的人生…</p><p>记录与分享，从今天开始！</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长之路</tag>
      
      <tag>写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux SSH 免密访问</title>
    <link href="/2017-10-08-Build-Ubuntu-Server/"/>
    <url>/2017-10-08-Build-Ubuntu-Server/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Linux-ssh"><a href="#Linux-ssh" class="headerlink" title="Linux ssh"></a>Linux ssh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>sudo apt-get install  ssh <span class="hljs-comment"># install ssh-server</span><br>ps -e|grep ssh <span class="hljs-comment"># 看到sshd那说明ssh-server已经启动了</span><br>sudo /etc/init.d/ssh start <span class="hljs-comment"># start ssh service</span><br>sudo /etc/init.d/ssh restart <span class="hljs-comment"># restart ssh service</span><br><br></code></pre></td></tr></table></figure><p> ssh-server配置文件位于&#x2F; etc&#x2F;ssh&#x2F;sshd_config:</p><ul><li>默认端口是22，可自定义其他端口号</li></ul><p>首先，您刚才实验远程登录的时候可能会发现，在输入完用户名后需要等很长一段时间才会提示输入密码。其实这是由于 sshd 需要反查客户端的 dns 信息导致的。我们可以通过禁用这个特性来大幅提高登录的速度。首先，打开 sshd_config 文件：</p><p>　　sudo nano &#x2F;etc&#x2F;ssh&#x2F;sshd_config</p><p>　　找到 GSSAPI options 这一节，将下面两行注释掉：</p><p>　　# GSSAPIAuthentication yes<br>    # GSSAPIDelegateCredentials no</p><p> 然后重新启动 ssh 服务即可：</p><p>　　sudo &#x2F;etc&#x2F;init.d&#x2F;ssh restart</p><p>　　再登录试试，应该非常快了吧</p><p>　　利用 PuTTy 通过证书认证登录服务器</p><p>　　SSH 服务中，所有的内容都是加密传输的，安全性基本有保证。但是如果能使用证书认证的话，安全性将会更上一层楼，而且经过一定的设置，还能实现证书认证自动登录的效果。</p><p>　　首先修改 sshd_config 文件，开启证书认证选项：</p><p>　　RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile %h&#x2F;.ssh&#x2F;authorized_keys修改完成后重新启动 ssh 服务。</p><p>　　下一步我们需要为 SSH 用户建立私钥和公钥。首先要登录到需要建立密钥的账户下，这里注意退出 root 用户，需要的话用 su 命令切换到其它用户下。然后运行：</p><p>　　ssh-keygen</p><p>　　这里，我们将生成的 key 存放在默认目录下即可。建立的过程中会提示输入 passphrase，这相当于给证书加个密码，也是提高安全性的措施，这样即使证书不小心被人拷走也不怕了。当然如果这个留空的话，后面即可实现 PuTTy 通过证书认证的自动登录。</p><p>　　ssh-keygen 命令会生成两个密钥，首先我们需要将公钥改名留在服务器上：</p><p>　　cd ~&#x2F;.ssh mv id_rsa.pub authorized_keys然后将私钥 id_rsa 从服务器上复制出来，并删除掉服务器上的 id_rsa 文件。</p><p>　　服务器上的设置就做完了，下面的步骤需要在客户端电脑上来做。首先，我们需要将 id_rsa 文件转化为 PuTTy 支持的格式。这里我们需要利用 PuTTyGEN 这个工具：</p><p>　　点击 PuTTyGen 界面中的 Load 按钮，选择 id_rsa 文件，输入 passphrase（如果有的话），然后再点击 Save PrivateKey 按钮，这样 PuTTy 接受的私钥就做好了。</p><p>　　打开 PuTTy，在 Session 中输入服务器的 IP 地址，在 Connection-&gt;SSH-&gt;Auth 下点击 Browse 按钮，选择刚才生成好的私钥。然后回到 Connection 选项，在 Auto-login username 中输入证书所属的用户名。回到 Session 选项卡，输入个名字点 Save 保存下这个 Session。点击底部的 Open 应该就可以通过证书认证登录到服务器了。如果有 passphrase 的话，登录过程中会要求输入 passphrase，否则将会直接登录到服务器上，非常的方便。</p><h3 id="Stop-Linux-Firewall"><a href="#Stop-Linux-Firewall" class="headerlink" title="Stop Linux Firewall"></a>Stop Linux Firewall</h3><p>检查Linux是否有防火墙的方法是:</p><pre><code class="hljs">iptables -L # 命令查看当前Linux系统的策略。iptables -F # 清空当前防火墙规则iptables -X # 删除系统配置的所有防火墙规则iptables -P INPUT ACCEPTiptables -P OUTPUT ACCEPTiptables -P FORWARD ACCEPT</code></pre><p>关闭Linux 防火墙之后其策略如下:</p><p><img src="https://blogres.blackist.org/202002011056_86.png"></p><h3 id="Ubuntu-configure-static-IP"><a href="#Ubuntu-configure-static-IP" class="headerlink" title="Ubuntu configure static IP"></a>Ubuntu configure static IP</h3><p> 编辑interfaces:</p><pre><code class="hljs">sudo gedit /etc/network/interfaces</code></pre><p> 添加ip信息:</p><pre><code class="hljs"># primary network interfacesauto eth0 iface eth0 inet staticaddress 192.168.11.138netmask 255.255.255.0gateway 192.168.11.1</code></pre><p> 配置DNS，编辑 resolve.conf</p><pre><code class="hljs">sudo gedit /etc/resolve.conf</code></pre><p> 添加：</p><pre><code class="hljs">nameserver 192.168.1.1nameserver 220.170.64.68</code></pre><p> 保存ip配置,防止重启失效，编辑base:</p><pre><code class="hljs">sudo gedit /etc/resolvconf/resolv.conf.d/base</code></pre><p> 添加：</p><pre><code class="hljs">nameserver 192.168.1.1nameserver 220.170.64.68</code></pre><p> 然后还是不能连上网，要将&#x2F;etc&#x2F;NetworkManager&#x2F;目录下的system-connections删除，或者移动到其他目录下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>Server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端实习生面试</title>
    <link href="/2017-10-07-%E8%BD%AC%E8%BD%BD-%E8%81%8C%E5%9C%BA%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E8%AF%95/"/>
    <url>/2017-10-07-%E8%BD%AC%E8%BD%BD-%E8%81%8C%E5%9C%BA%E4%B9%8B%E8%B7%AF-%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[转载]<a href="https://github.com/SimplyY/blog/search?utf8=%E2%9C%93&q=%E9%98%BF%E9%87%8C%E5%AE%9E%E4%B9%A0%E7%94%9F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%83%E5%BE%97&type=">阿里实习生前端面试心得</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>总之呢，我觉得面试这东西，绝对不可能100%发挥，我发挥大概是一面60%，二面80%，三面70%。</p><p>可见，我一面几乎差点崩掉 orz。</p><p>一般而言，第一次面试都会很紧张的，然后要挑个好位置，保持好心态，深呼吸都很有用，不紧张最少增加10%的发挥，碰到对胃口的面试官也能至少增加10%发挥。</p><p>我这边的阿里面试经验就是</p><ul><li>内容上：一面基础，二面项目，三面架构、框架分析。</li><li>形式上：阿里大多是3轮技术电面，一轮 hr，有时候会有视频面试，写代码之类。</li></ul><p>然后分点回答很重要，思路清晰很重要，<strong>没听懂问题问一下很重要</strong>，有些问题假如能结合自己项目经历谈可以加分。</p><p>接下来我简略写一写三次技术面试吧。</p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>3.8 晚上 53min</p><p>第一个面试紧张的不得了，然后还选择了一个不好的地点，，吹风，当时我还在想，别人一面很快来着，所以吹吹风精神一点，然后我就被吹成了 dog，面了将近一小时&#x3D; &#x3D;</p><h3 id="如何判断一个变量是字符串"><a href="#如何判断一个变量是字符串" class="headerlink" title="如何判断一个变量是字符串"></a>如何判断一个变量是字符串</h3><p>我在玉伯的 github 博客里看到过一篇叫做 sea.js 源码剖析的文章，上面提到一个方法，其实适用于任何类型的检测</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;str&#x27;</span>) <span class="hljs-comment">// &#x27;[object String]&#x27;</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-comment">// &#x27;string&#x27;</span><br><br><span class="hljs-comment">// 常见的错误写法（我只答了上面俩，多机智）</span><br>&gt; <span class="hljs-string">&#x27;cads&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="apply-的作用，类似的更改-this-的方法有哪些"><a href="#apply-的作用，类似的更改-this-的方法有哪些" class="headerlink" title="apply 的作用，类似的更改 this 的方法有哪些"></a>apply 的作用，类似的更改 this 的方法有哪些</h3><p>apply 可以动态更改函数对象内部的 this，可以用于将 DOMList arguments 等伪数组变成数组，这样就可以，对它们使用数组的方法来操作。</p><p>call、bind</p><h3 id="性能优化的方法"><a href="#性能优化的方法" class="headerlink" title="性能优化的方法"></a>性能优化的方法</h3><p><a href="http://simplyy.space/article/56d8377063fac2a8175b41f4#%E4%BD%A0%E6%9C%89%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F">#你有用过哪些前端性能优化的方法？</a></p><h3 id="性能优化，除了雅虎13条军规，还有哪些"><a href="#性能优化，除了雅虎13条军规，还有哪些" class="headerlink" title="性能优化，除了雅虎13条军规，还有哪些"></a>性能优化，除了雅虎13条军规，还有哪些</h3><p>我没答出符合要求的 orz（还是13条里面）</p><p>面试官说了，寻找最短链路（用户到美国服务器），缓存大有可为（服务器端）</p><h3 id="let-、var-区别"><a href="#let-、var-区别" class="headerlink" title="let 、var 区别"></a>let 、var 区别</h3><p>let 块级作用域，var 函数作用域</p><h3 id="let-暂时性死区的原因"><a href="#let-暂时性死区的原因" class="headerlink" title="let 暂时性死区的原因"></a>let 暂时性死区的原因</h3><p>var 会变量提升，let 不会。</p><h3 id="浏览器事件传递机制，有没有停止冒泡的使用经验"><a href="#浏览器事件传递机制，有没有停止冒泡的使用经验" class="headerlink" title="浏览器事件传递机制，有没有停止冒泡的使用经验"></a>浏览器事件传递机制，有没有停止冒泡的使用经验</h3><p>冒泡、捕捉。</p><p>我在我的博客项目的导航栏里面使用了，其中二级 menu 被一级 menu 包起来了，点击二级 menu 的事件会冒泡到一级上，但是实际上应该一级不响应二级目录的点击事件，所以在二级的事件监听里面应该调用 e.stopPropagation()</p><p>ps：因为当时没有用 a 标签，而是用的监听 li 标签的 onclick 事件才导致的这个问题，实际上用 a 标签无需停止冒泡。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><a href="http://simplyy.space/article/56da6d841795204c56032e21#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85">#如何理解闭包</a></p><h3 id="闭包与函数作用域的联系"><a href="#闭包与函数作用域的联系" class="headerlink" title="闭包与函数作用域的联系"></a>闭包与函数作用域的联系</h3><p>函数作用域是产生闭包的原因</p><blockquote><p>如果你看题目也愣住了，就和我一样，答案或许和我一样都知道，然而。。。</p></blockquote><h3 id="说一说你擅长和不擅长的方面"><a href="#说一说你擅长和不擅长的方面" class="headerlink" title="说一说你擅长和不擅长的方面"></a>说一说你擅长和不擅长的方面</h3><blockquote><p>切记不要说不擅长 js，以及这道题几乎每个面试官都问我了，出现概率很大，可以提前准备</p></blockquote><p>擅长 js，css 不擅长。</p><h3 id="谈一谈-promise"><a href="#谈一谈-promise" class="headerlink" title="谈一谈 promise"></a>谈一谈 promise</h3><p><a href="http://simplyy.space/article/56da6d841795204c56032e21#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Promise%E7%9A%84%E7%90%86%E8%A7%A3">#说说你对Promise的理解</a></p><h3 id="使用选择器查找页面内所有-div-元素"><a href="#使用选择器查找页面内所有-div-元素" class="headerlink" title="使用选择器查找页面内所有 div 元素"></a>使用选择器查找页面内所有 div 元素</h3><p>一开始我以为是 css orz，然后和面试官楞半天。。（最佳反映应该是直接问是 css 还是 js orz</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>) <span class="hljs-comment">// ie9+</span><br></code></pre></td></tr></table></figure><h3 id="如何优化-DOM-操作的性能"><a href="#如何优化-DOM-操作的性能" class="headerlink" title="如何优化 DOM 操作的性能"></a>如何优化 DOM 操作的性能</h3><ul><li>不要反复使用 DOM 查询操作，应该用变量缓存</li><li>避免大量使用会造成重绘的 DOM 操作</li><li>多使用 id 选择器</li></ul><h3 id="影响页面重绘的操作"><a href="#影响页面重绘的操作" class="headerlink" title="影响页面重绘的操作"></a>影响页面重绘的操作</h3><p>改变 width height、offset 等值</p><p>其中 js 动画影响显著，我以前项目写过 js 长动画，性能很差，cpu 飙升，长动画应该用 css 动画。</p><h3 id="前端渲染和后端渲染的优缺点"><a href="#前端渲染和后端渲染的优缺点" class="headerlink" title="前端渲染和后端渲染的优缺点"></a>前端渲染和后端渲染的优缺点</h3><ul><li>前端渲染不利于 seo，可能会增加HTTP请求</li><li>后端当一分钟访问量几百万对服务器有压力</li></ul><h4 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h4><p>from 司徒正美博客 <a href="http://www.cnblogs.com/rubylouvre/p/4128500.html">http://www.cnblogs.com/rubylouvre/p/4128500.html</a></p><ul><li>服务器为了前端渲染，对对象的字符串化所消耗的时间，远远大于服务器直接渲染模板生成HTML所花费的时间。</li><li>我的建议是前后端模板同时使用。</li><li>后端渲染完了之后，需要进行网络传输的体积大了，带来的网络损耗和网络传输时间问题<br>很多场景，尤其是在移动端，我们通常不会把渲染工作交给后端，一方面后端渲染需要时间，一方面庞大的渲染数据传输也有时延，所以就会出现白屏问题。</li><li>nodejs 的出现让模板复用方便了不少，很多时候，让后端渲染一部分（比如首屏部分），后面的工作就交给前端异步去处理。两者结合起来效果才是最佳的。</li><li>SEO 问题嘛，看产品需求，很多产品优化了 SEO 也没多大作用，如果实在要考虑：可以使用 pjax &#x2F; quickling &#x2F; hash bang 等技术,或服务器端根据 UA 输出内容</li></ul><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p><a href="http://simplyy.space/article/56da6d841795204c56032e21#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">#如何解决跨域问题</a></p><h3 id="对我的评价"><a href="#对我的评价" class="headerlink" title="对我的评价"></a>对我的评价</h3><p>回答问题的时候不要一听到自己会的，就想这个我会，然后抢着答，要把题目挺清楚。学的比较杂，比较新，需要挖深。</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>3.11 下午 24min</p><h3 id="平时怎么学习-web-前端"><a href="#平时怎么学习-web-前端" class="headerlink" title="平时怎么学习 web 前端"></a>平时怎么学习 web 前端</h3><p>微博、github、看书</p><p>我整理的大牛列表（然而面试的时候没说出几个 orz，紧张面试之大敌）</p><p><a href="https://github.com/CoderUnion/coderunion-github-talk/issues/87">https://github.com/CoderUnion/coderunion-github-talk/issues/87</a></p><p><a href="https://github.com/CoderUnion/coderunion-github-talk/issues/86">https://github.com/CoderUnion/coderunion-github-talk/issues/86</a></p><h3 id="学编程每天花的时间"><a href="#学编程每天花的时间" class="headerlink" title="学编程每天花的时间"></a>学编程每天花的时间</h3><p>至少5小时，放假更多（有点 sad 的是还有没说的，寒假我几乎是每天8小时编程，所以之后问到的，博客学了一个多星期，开发了一个多星期，惊讶于我开发的很快的时候，我还是忘记说这个了，因为寒假我花了 double 的时间编程呀。。）</p><h3 id="介绍项目"><a href="#介绍项目" class="headerlink" title="介绍项目"></a>介绍项目</h3><p>博客，组件，etc 此处省略200字</p><p>hybird app etc 此处省略200字</p><h3 id="性能优化效果最好的几个方面"><a href="#性能优化效果最好的几个方面" class="headerlink" title="性能优化效果最好的几个方面"></a>性能优化效果最好的几个方面</h3><p>减少 http 请求，gzip</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>很不错，等</p><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>3.12 星期六下午2点 43min</p><h3 id="简单介绍一下，不用常规介绍（简历上的东西），可以说一说你最有意思、或者有点难度值得一说的开发经历"><a href="#简单介绍一下，不用常规介绍（简历上的东西），可以说一说你最有意思、或者有点难度值得一说的开发经历" class="headerlink" title="简单介绍一下，不用常规介绍（简历上的东西），可以说一说你最有意思、或者有点难度值得一说的开发经历"></a>简单介绍一下，不用常规介绍（简历上的东西），可以说一说你最有意思、或者有点难度值得一说的开发经历</h3><p>昨天晚上，使用 nginx 将一个 ip 对应多个域名。今天上午在帮别人搭建博客时，线上操作失误，把数据库数据弄坏了 orz</p><p>补充，当天晚上通过回滚磁盘弄好了没有备份的数据库 orz（我是一个不合格的运维）</p><h3 id="单向数据流和双向数据流，MVC，MVVM，flux-系列的特点和区别"><a href="#单向数据流和双向数据流，MVC，MVVM，flux-系列的特点和区别" class="headerlink" title="单向数据流和双向数据流，MVC，MVVM，flux 系列的特点和区别"></a>单向数据流和双向数据流，MVC，MVVM，flux 系列的特点和区别</h3><p>略（我答是答了，不过感觉自己把自己说混乱了，，大概就是说，单向的更清晰，写的累、复杂，但是维护更容易，双向和 MVC 写着快，但是维护起来对于大型项目比较吃力，其实我觉得面试官是要我说痛点，，但是那些痛点实际上我都是听说的，自己遇到的少，所以印象不深）</p><h3 id="django-这种重后端类型的架构和-react-或-spa-等这种重前端的架构的区别，和适用特点"><a href="#django-这种重后端类型的架构和-react-或-spa-等这种重前端的架构的区别，和适用特点" class="headerlink" title="django 这种重后端类型的架构和 react 或 spa 等这种重前端的架构的区别，和适用特点"></a>django 这种重后端类型的架构和 react 或 spa 等这种重前端的架构的区别，和适用特点</h3><ul><li>看团队结构，如果团队里面后端比较多，就重后端，假如前端人多，就轻后端，将业务逻辑放到前端</li><li>性能上，特别是移动端 webview 里面，一个新的交互，不可能去新加载一个 html，这太慢了，所以应该用 ajax，局部更改页面内容。</li></ul><p>其实也没打全 orz，其实和前端渲染和后端渲染的题，有很多类似的地方。</p><h3 id="react-研究的怎么样，说一说它的一些特性"><a href="#react-研究的怎么样，说一说它的一些特性" class="headerlink" title="react 研究的怎么样，说一说它的一些特性"></a>react 研究的怎么样，说一说它的一些特性</h3><p>组件化说了一堆。。 还说了单向数据流，flux，immutablejs</p><h3 id="提示你一下，vitrual-DOM-方面"><a href="#提示你一下，vitrual-DOM-方面" class="headerlink" title="提示你一下，vitrual DOM 方面"></a>提示你一下，vitrual DOM 方面</h3><ul><li>性能非常好</li><li>由于脱离了浏览器 DOM，所以可以很方便的多端迁移，比如服务器端渲染，react native 移动端开发。</li></ul><h3 id="vitrual-DOM-算法实现有研究过吗"><a href="#vitrual-DOM-算法实现有研究过吗" class="headerlink" title="vitrual DOM 算法实现有研究过吗"></a>vitrual DOM 算法实现有研究过吗</h3><p>我看过一个博客，里面提到了 Facebook 工程师根据几个策略</p><p>拥有相同类的两个组件将会生成相似的结构，拥有不同类的两个组件将会生成不同的结构。将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题</p><p>实际上我少说了俩策略。</p><ol><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li><li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li></ol><p>问我深入的具体实现，我说之前的了解是在学习 react 的时候看的，后来去写博客了。。</p><h4 id="详情链接"><a href="#详情链接" class="headerlink" title="详情链接"></a>详情链接</h4><p><a href="http://zhuanlan.zhihu.com/purerender/20346379">http://zhuanlan.zhihu.com/purerender/20346379</a></p><h3 id="说一说你觉得自己什么时候技术提高最快"><a href="#说一说你觉得自己什么时候技术提高最快" class="headerlink" title="说一说你觉得自己什么时候技术提高最快"></a>说一说你觉得自己什么时候技术提高最快</h3><p>做项目，省略50字</p><h3 id="为什么想来我们这边实习，你认为可以收获什么"><a href="#为什么想来我们这边实习，你认为可以收获什么" class="headerlink" title="为什么想来我们这边实习，你认为可以收获什么"></a>为什么想来我们这边实习，你认为可以收获什么</h3><ul><li>我认为有人（很多）用的东西，会把问题暴露出来，再小的问题都会变成大问题，解决这些问题就会深入研究很多东西</li><li>团队方面，省略50字</li></ul><h3 id="假如当你开始工作后，发现工作时间没有提高怎么办"><a href="#假如当你开始工作后，发现工作时间没有提高怎么办" class="headerlink" title="假如当你开始工作后，发现工作时间没有提高怎么办"></a>假如当你开始工作后，发现工作时间没有提高怎么办</h3><ul><li>在工作中，肯定要总结，不断精进，从做项目中收益，而不是错了一次再错第二次（我这里只针对了 bug，应该更广，比如架构啊，编码风格啊等等）</li><li>回家肯定至少花一个小时看书，还要关注社区的一些动态，平时我在微博 github 上面那些工作了的大牛，他们每天传播的新技术新思想知识，我都是挑着看的</li></ul><h3 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h3><p>你现在知道框架架构怎么用、用途不够，还要知道什么时候用，为什么用，像 angular 啊、react 啊等等，这些框架的核心，解决了什么痛点。</p><blockquote><p>这个评价估计是因为之前问我为什么用 vue啊 react 啊，我当时之前都是说为了学习而用，然后 react 深入的问题我没答好。</p></blockquote><p>不过你条理比较清晰，也热爱做项目，这点不错。</p><h2 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h2><p><a href="http://zhangwenli.com/blog/2015/04/01/2015-front-end-engineer-interview/">http://zhangwenli.com/blog/2015/04/01/2015-front-end-engineer-interview/</a></p><p><a href="http://www.cnblogs.com/joyeecheung/p/5003980.html">http://www.cnblogs.com/joyeecheung/p/5003980.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>职业</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows常用命令</title>
    <link href="/2017-10-01-command-debug/"/>
    <url>/2017-10-01-command-debug/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Socket-Address-Conflict"><a href="#Socket-Address-Conflict" class="headerlink" title="Socket Address Conflict"></a>Socket Address Conflict</h3><p>Description:通常每个套接字地址(协议&#x2F;网络地址&#x2F;端口)只允许使用<br>一次。</p><pre><code class="hljs">$ netstat$ netstat -aon|findstr 9000$ tasklist /fi &quot;pid eq 9000&quot;$ taskkill /pid 276 /f </code></pre><h3 id="windows-useful-command"><a href="#windows-useful-command" class="headerlink" title="windows useful command"></a>windows useful command</h3><p>1.make file</p><pre><code class="hljs">$ type NUL &gt; test.py</code></pre><p>2.list files</p><pre><code class="hljs">$ dir /s /b/ /o:gn # files and dir$ tree /f   # files</code></pre>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android UI库</title>
    <link href="/2017-09-11-android-awesome-ui/"/>
    <url>/2017-09-11-android-awesome-ui/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>声明：本文转载自<a href="https://github.com/opendigg">opendigg</a>的gituhb项目<a href="https://github.com/opendigg/awesome-github-android-ui">awesome-github-android-ui</a>.</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li><a href="#%E6%8A%BD%E5%B1%89%E8%8F%9C%E5%8D%95">抽屉菜单</a> </li><li><a href="#ListView">ListView</a> </li><li><a href="#WebView">WebView</a> </li><li><a href="#SwitchButton">SwitchButton</a> </li><li><a href="#%E6%8C%89%E9%92%AE">按钮</a> </li><li><a href="#%E7%82%B9%E8%B5%9E%E6%8C%89%E9%92%AE">点赞按钮</a> </li><li><a href="#%E8%BF%9B%E5%BA%A6%E6%9D%A1">进度条</a> </li><li><a href="#TabLayout">TabLayout</a> </li><li><a href="#%E5%9B%BE%E6%A0%87">图标</a> </li><li><a href="#%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0">下拉刷新</a> </li><li><a href="#ViewPager">ViewPager</a> </li><li><a href="#%E5%9B%BE%E8%A1%A8(Chart)">图表(Chart)</a> </li><li><a href="#%E8%8F%9C%E5%8D%95(Menu)">菜单(Menu)</a> </li><li><a href="#%E6%B5%AE%E5%8A%A8%E8%8F%9C%E5%8D%95">浮动菜单</a> </li><li><a href="#%E5%AF%B9%E8%AF%9D%E6%A1%86">对话框</a> </li><li><a href="#%E7%A9%BA%E7%99%BD%E9%A1%B5">空白页</a> </li><li><a href="#%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4">滑动删除</a> </li><li><a href="#%E6%89%8B%E5%8A%BF%E6%93%8D%E4%BD%9C">手势操作</a> </li><li><a href="#RecyclerView">RecyclerView</a> </li><li><a href="#Card">Card</a> </li><li><a href="#Color">Color</a> </li><li><a href="#Drawable">Drawable</a> </li><li><a href="#Spinner">Spinner</a> </li><li><a href="#%E5%B8%83%E5%B1%80">布局</a> </li><li><a href="#%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C">模糊效果</a> </li><li><a href="#TabBar">TabBar</a> </li><li><a href="#AppBar">AppBar</a> </li><li><a href="#%E9%80%89%E6%8B%A9%E5%99%A8(Picker)">选择器(Picker)</a> </li><li><a href="#%E8%B7%91%E9%A9%AC%E7%81%AF">跑马灯</a> </li><li><a href="#%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4">日历时间</a> </li><li><a href="#%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F">主题样式</a> </li><li><a href="#ImageView">ImageView</a> </li><li><a href="#%E9%80%9A%E7%9F%A5">通知</a> </li><li><a href="#%E8%81%8A%E5%A4%A9%E8%A7%86%E5%9B%BE">聊天视图</a> </li><li><a href="#Header">Header</a> </li><li><a href="#%E5%BC%95%E5%AF%BC%E5%9B%BE(Intro)">引导图(Intro)</a> </li><li><a href="#%E5%9B%BE%E7%89%87">图片</a> </li><li><a href="#%E5%BE%BD%E7%AB%A0(Badge)">徽章(Badge)</a> </li><li><a href="#RatingView">RatingView</a> </li><li><a href="#%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C(Scroll)">滚动效果(Scroll)</a> </li><li><a href="#%E6%97%B6%E9%97%B4%E8%BD%B4">时间轴</a> </li><li><a href="#TreeView">TreeView</a> </li><li><a href="#SearchView">SearchView</a> </li><li><a href="#TagView">TagView</a> </li><li><a href="#TextView">TextView</a> </li><li><a href="#EditText">EditText</a> </li><li><a href="#Sliding">Sliding</a> </li><li><a href="#%E8%A1%A8%E5%8D%95">表单</a> </li><li><a href="#%E5%88%86%E6%AE%B5%E6%8E%A7%E4%BB%B6">分段控件</a> </li><li><a href="#%E8%BD%AE%E6%92%AD%E5%9B%BE">轮播图</a> </li><li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">文件操作</a> </li><li><a href="#%E5%90%AF%E5%8A%A8%E9%A1%B5">启动页</a> </li><li><a href="#MD">MD</a> </li><li><a href="#BottomNavigation">BottomNavigation</a> </li><li><a href="#Toast">Toast</a> </li><li><a href="#CreditCard">CreditCard</a> </li><li><a href="#ActionSheet">ActionSheet</a> </li><li><a href="#Wave">Wave</a> </li><li><a href="#Snackbar">Snackbar</a> </li><li><a href="#%E7%94%A8%E6%88%B7%E5%BC%95%E5%AF%BC">用户引导</a> </li><li><a href="#Popup">Popup</a> </li><li><a href="#%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E">滑动返回</a> </li><li><a href="#TV%E7%BB%84%E4%BB%B6">TV组件</a> </li><li><a href="#%E8%BD%AF%E9%94%AE%E7%9B%98">软键盘</a> </li><li><a href="#%E7%8A%B6%E6%80%81%E6%A0%8F">状态栏</a> </li><li><a href="#StepView">StepView</a> </li><li><a href="#%E8%A1%A8%E6%A0%BC(Table)">表格(Table)</a> </li><li><a href="#%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%B7%AE(Parallex)">滚动视差(Parallex)</a> </li><li><a href="#SideBar">SideBar</a> </li><li><a href="#%E5%85%B3%E4%BA%8E%E9%A1%B5%E9%9D%A2">关于页面</a> </li><li><a href="#%E8%AF%A6%E6%83%85%E9%A1%B5">详情页</a> </li><li><a href="#FAB">FAB</a> </li><li><a href="#Indicator">Indicator</a> </li><li><a href="#%E5%88%86%E4%BA%AB%E7%BB%84%E4%BB%B6">分享组件</a> </li><li><a href="#%E5%8D%87%E7%BA%A7%E6%9B%B4%E6%96%B0">升级更新</a> </li><li><a href="#Toolbar">Toolbar</a> </li><li><a href="#Sort&Drag">Sort&amp;Drag</a> </li><li><a href="#Emoji">Emoji</a> </li><li><a href="#Label">Label</a> </li><li><a href="#WheelView">WheelView</a> </li><li><a href="#PinCode">PinCode</a> </li><li><a href="#CoordinatorLayout">CoordinatorLayout</a> </li><li><a href="#%E9%A1%B5%E9%9D%A2%E5%88%87%E6%8D%A2">页面切换</a> </li><li><a href="#%E6%82%AC%E6%B5%AE%E7%AA%97">悬浮窗</a> </li><li><a href="#%E5%9C%B0%E5%9B%BE">地图</a> </li><li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a> </li><li><a href="#SeekBar">SeekBar</a> </li><li><a href="#DownloadView">DownloadView</a> </li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li></ul><h2 id="抽屉菜单"><a href="#抽屉菜单" class="headerlink" title="抽屉菜单"></a>抽屉菜单</h2><ul><li><a href="https://github.com/mikepenz/MaterialDrawer">MaterialDrawer</a> ★7582 - 安卓抽屉效果实现方案 </li><li><a href="https://github.com/Yalantis/Side-Menu.Android">Side-Menu.Android</a> ★3979 - 创意边侧菜单 </li><li><a href="https://github.com/mxn21/FlowingDrawer">FlowingDrawer</a> ★1784 - 向右滑动流动抽屉效果 </li><li><a href="https://github.com/yarolegovich/SlidingRootNav">SlidingRootNav</a> ★1589 - 仿DrawerLayout的ViewGroup </li><li><a href="https://github.com/mzule/FantasySlide">FantasySlide</a> ★1084 - 单手势滑出侧边栏与选择菜单 </li><li><a href="https://github.com/andremion/Floating-Navigation-View">Floating-Navigation-View</a> ★806 - 浮动菜单显示锚导航视图 </li><li><a href="https://github.com/heinrichreimer/material-drawer">material-drawer</a> ★538 - MD风格的自定义抽屉实现 </li><li><a href="https://github.com/Brioal/SwipeMenuDemo">SwipeMenuDemo</a> ★533 - 侧滑菜单动画效果库 </li><li><a href="https://github.com/rom4ek/ArcNavigationView">ArcNavigationView</a> ★353 - 具有曲线边缘的NavigationView </li><li><a href="https://github.com/drakeet/QQSliddingMenu">QQSliddingMenu</a> ★111 - 与QQ5.0 完全一模一样的侧滑菜单 </li><li><a href="https://github.com/lemonade-hq/SlideSideMenu">SlideSideMenu</a> ★69 - 滑动侧菜单的布局部件</li></ul><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><ul><li><a href="https://github.com/hongyangAndroid/baseAdapter">baseAdapter</a> ★2685 - Android 万能的Adapter </li><li><a href="https://github.com/beworker/pinned-section-listview">Pinned Section Listview</a> ★2393 - 便于使用的ListView </li><li><a href="https://github.com/felipecsl/AsymmetricGridView">AsymmetricGridView</a> ★1410 - Android自定义列表视图 </li><li><a href="https://github.com/pedrovgs/Renderers">Renderers</a> ★1036 - 创建适配器的Android库 </li><li><a href="https://github.com/Kelin-Hong/CalendarListView">CalendarListView</a> ★766 - 可互动的ListView+CalendarView </li><li><a href="https://github.com/diegodobelo/AndroidExpandingViewLibrary">AndroidExpandingViewLibrary</a> ★528 - 创建Android动画折叠视图 </li><li><a href="https://github.com/lurbas/ListItemView">ListItemView</a> ★501 - 基于MD风格的列表item实现 </li><li><a href="https://github.com/venshine/WheelView">WheelView</a> ★462 - 基于ListView实现的Android滚轮控件 </li><li><a href="https://github.com/yll2wcf/YLListView">YLListView</a> ★216 - 仿IOS弹簧效果的ListView </li><li><a href="https://github.com/vivian8725118/SearchListView">SearchListView</a> ★152 - 带搜索栏的 listview </li><li><a href="https://github.com/ruzhan123/ScollZoomListView">ScollZoomListView</a> ★40 - 优雅的漫画阅读器插件</li></ul><h2 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h2><ul><li><a href="https://github.com/lzyzsd/JsBridge">JsBridge</a> ★3073 - Android的Java和JavaScript桥接 </li><li><a href="https://github.com/JackyAndroid/AndroidChromium">AndroidChromium</a> ★1532 - 谷歌浏览器安卓版源码项目 </li><li><a href="https://github.com/TheFinestArtist/FinestWebView-Android">FinestWebView-Android</a> ★1478 - 可自定义webview </li><li><a href="https://github.com/cprcrack/VideoEnabledWebView">VideoEnabledWebView</a> ★622 - Android的WebView和WebChromeClint类扩展 </li><li><a href="https://github.com/Justson/AgentWeb">AgentWeb</a> ★455 - 一个高度封装的 WebView </li><li><a href="https://github.com/RameshBhupathi/CollapsingToolbar-With-Webview">CollapsingToolbar-With-Webview</a> ★190 - 带有可折叠toolbar的Webview </li><li><a href="https://github.com/wendux/DSBridge-Android">DSBridge-Android</a> ★162 - 目前地球上最好的IOS及Android javascript bridge </li><li><a href="https://github.com/wendux/DSBridge-IOS">DSBridge-IOS</a> ★135 - 目前地球上最好的IOS javascript bridge </li><li><a href="https://github.com/slm/WebViewNativeBridge">WebViewNativeBridge</a> ★29 - 从WebView向Java通过url发送数据 </li><li><a href="https://github.com/AhmadNemati/ClickableWebView">ClickableWebView</a> ★22 - 检测图片上的点击</li></ul><h2 id="SwitchButton"><a href="#SwitchButton" class="headerlink" title="SwitchButton"></a>SwitchButton</h2><ul><li><a href="https://github.com/zcweng/ToggleButton">ToggleButton</a> ★1770 - Android上类似iOS的开关控件 </li><li><a href="https://github.com/zagum/Android-SwitchIcon">Android-SwitchIcon</a> ★1470 - Switch图标的Google启动器风格实现 </li><li><a href="https://github.com/glomadrian/material-animated-switch">material-animated-switch</a> ★974 - 带有图标动画和颜色转换的Switch </li><li><a href="https://github.com/polyak01/IconSwitch">IconSwitch</a> ★580 - 自定义切换部件 </li><li><a href="https://github.com/zcweng/SwitchButton">SwitchButton</a> ★399 - 优美的轻量级自定义样式的Switch按钮 </li><li><a href="https://github.com/7heaven/SHSwitchView">SHSwitchView</a> ★322 - iOS7风格的Switch开关 </li><li><a href="https://github.com/xiaopansky/SwitchButton">SwitchButton</a> ★284 - 安卓开关按钮 </li><li><a href="https://github.com/799536960/switchView">switchView</a> ★19 - 带有文字的switch</li></ul><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><ul><li><a href="https://github.com/medyo/Fancybuttons">FancyButtons</a> ★1148 - 创建花式按钮 </li><li><a href="https://github.com/fenjuly/ArrowDownloadButton">ArrowDownloadButton</a> ★790 - 超酷的下载按钮 </li><li><a href="https://github.com/mcxtzhang/AnimShopButton">AnimShopButton</a> ★788 - 带伸缩位移旋转动画的购物车按钮 </li><li><a href="https://github.com/venshine/GoodView">GoodView</a> ★774 - Android点赞+1效果 </li><li><a href="https://github.com/niniloveyou/StateButton">StateButton</a> ★768 - 不必为每种类型的button写一个drawable </li><li><a href="https://github.com/Scalified/fab">fab</a> ★764 - 浮动按钮 </li><li><a href="https://github.com/Nightonke/JellyToggleButton">JellyToggleButton</a> ★706 - 果冻动态效果及缓动类型开关按钮 </li><li><a href="https://github.com/varunest/SparkButton">SparkButton</a> ★693 - 创建一个带动画效果的按钮 </li><li><a href="https://github.com/ckurtm/FabButton">FabButton</a> ★671 - 带有进度条指示器的环形浮动动作按钮 </li><li><a href="https://github.com/cctanfujun/ProgressRoundButton">ProgressRoundButton</a> ★634 - 显示进度的流畅下载按钮 </li><li><a href="https://github.com/dewarder/HoldingButton">HoldingButton</a> ★471 - 控制录音状态的按钮 </li><li><a href="https://github.com/SparkYuan/SubmitButton">SubmitButton</a> ★356 - 实用酷炫又优雅的提交按钮 </li><li><a href="https://github.com/ishaan1995/ButtonProgressBar">ButtonProgressBar</a> ★329 - 下载按钮进度条 </li><li><a href="https://github.com/gjiazhe/MultiChoicesCircleButton">MultiChoicesCircleButton</a> ★312 - 带3d视差效果的多选按钮 </li><li><a href="https://github.com/rubensousa/RaiflatButton">RaiflatButton</a> ★290 - 凸起的按钮 </li><li><a href="https://github.com/jiang111/CProgressButton">CProgressButton</a> ★255 - 仿iOS环形进度按钮 </li><li><a href="https://github.com/czy1121/roundbutton">roundbutton</a> ★243 - 可设置圆角背景边框的的按钮 </li><li><a href="https://github.com/recruit-lifestyle/PlayPauseButton">PlayPauseButton</a> ★233 - 制作动画播放状态的视图 </li><li><a href="https://github.com/ebanx/swipe-button">swipe-button</a> ★216 - swipe button </li><li><a href="https://github.com/Someonewow/SubmitButton">SubmitButton</a> ★189 - 带有进度动画的自定义提交按钮 </li><li><a href="https://github.com/HomHomLin/Android-DivergeView">Android-DivergeView</a> ★170 - 仿美拍直播的点赞动画 </li><li><a href="https://github.com/BeppiMenozzi/TriStateToggleButton">TriStateToggleButton</a> ★134 - 完全可自定义3态切换按钮 </li><li><a href="https://github.com/ceryle/SegmentedButton">SegmentedButton</a> ★107 - 类似IOS的带动画分割按钮 </li><li><a href="https://github.com/StevenDXC/DxLoadingButton">DxLoadingButton</a> ★83 - 带有动画的Android加载按钮 </li><li><a href="https://github.com/laocaixw/SuspendButtonLayout">SuspendButtonLayout</a> ★73 - 带浮动按钮的布局 </li><li><a href="https://github.com/dimorinny/floating-text-button">floating-text-button</a> ★49 - 带动作文本的简单浮动按钮 </li><li><a href="https://github.com/developer-shivam/PentagonFloatingActionButton">PentagonFloatingActionButton</a> ★43 - 浮动点击动画按钮 </li><li><a href="https://github.com/Sbingo/FreeRadioGroup">FreeRadioGroup</a> ★33 - 类似于苹果的虚拟辅助按钮 </li><li><a href="https://github.com/LongDinhF/Hamburger-Button">Hamburger-Button</a> ★32 - 完全定制的汉堡按钮 </li><li><a href="https://github.com/hcs-xph/BadgeRadioButton">BadgeRadioButton</a> ★25 - 仿QQ底部Tab切换RadioButton </li><li><a href="https://github.com/LinXiaoTao/OrderButton">OrderButton</a> ★21 - 仿饿了么下单按钮</li></ul><h2 id="点赞按钮"><a href="#点赞按钮" class="headerlink" title="点赞按钮"></a>点赞按钮</h2><ul><li><a href="https://github.com/ChadCSong/ShineButton">ShineButton</a> ★2533 - 安卓闪光UI库 </li><li><a href="https://github.com/jd-alexander/LikeButton">LikeButton</a> ★1897 - 仿Twitter点赞时的的heart </li><li><a href="https://github.com/venshine/GoodView">GoodView</a> ★774 - Android点赞+1效果 </li><li><a href="https://github.com/varunest/SparkButton">SparkButton</a> ★693 - 创建一个带动画效果的按钮 </li><li><a href="https://github.com/ldoublem/ThumbUp">ThumbUp</a> ★559 - 精致的点赞控件 </li><li><a href="https://github.com/yanbober/MagicFloatView">MagicFloatView</a> ★232 - 自定义拓展漂浮路径的MagicFlyLinearLayout 控件 </li><li><a href="https://github.com/HomHomLin/Android-DivergeView">Android-DivergeView</a> ★170 - 仿美拍直播的点赞动画 </li><li><a href="https://github.com/zFxiang/LikeView">LikeView</a> ★34 - 仿即刻APP点赞桃心的效果 </li><li><a href="https://github.com/alex5241/TumblrLikeAnimView">TumblrLikeAnimView</a> ★15 - 仿Tumblr点赞动画效果</li></ul><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><ul><li><a href="https://github.com/81813780/AVLoadingIndicatorView">AVLoadingIndicatorView</a> ★5055 - 安卓载入动画合集 </li><li><a href="https://github.com/daimajia/NumberProgressBar">NumberProgressBar</a> ★4026 - 多彩进度条 </li><li><a href="https://github.com/ybq/Android-SpinKit">Android-SpinKit</a> ★3305 - Android加载动画 </li><li><a href="https://github.com/dinuscxj/LoadingDrawable">LoadingDrawable</a> ★2630 - 安卓工具动画集合 </li><li><a href="https://github.com/lzyzsd/CircleProgress">CircleProgress</a> ★2415 - 三种圆形进度视图 </li><li><a href="https://github.com/Todd-Davies/ProgressWheel">ProgressWheel</a> ★2260 - 圆形旋转效果 </li><li><a href="https://github.com/ozodrukh/CircularReveal">CircularReveal</a> ★2034 - 创建加载动画效果 </li><li><a href="https://github.com/ldoublem/LoadingView">LoadingView</a> ★1719 - 简单的带有动画效果的加载控件 </li><li><a href="https://github.com/JorgeCastilloPrz/AndroidFillableLoaders">AndroidFillableLoaders</a> ★1603 - 有趣的填充型进程视图 </li><li><a href="https://github.com/Tibolte/ElasticDownload">ElasticDownload</a> ★1442 - 下载动画效果 </li><li><a href="https://github.com/dodola/MetaballLoading">MetaballLoading</a> ★1352 - 一个2d圆球加载 </li><li><a href="https://github.com/zzz40500/android-shapeLoadingView">android-shapeLoadingView</a> ★1321 - 高仿新版58 加载动画 </li><li><a href="https://github.com/akexorcist/Android-RoundCornerProgressBar">Android-RoundCornerProgressBar</a> ★1252 - Android圆角进度条库 </li><li><a href="https://github.com/DreaminginCodeZH/MaterialProgressBar">MaterialProgressBar</a> ★1213 - MD风格的进度条 </li><li><a href="https://github.com/tangqi92/WaveLoadingView">WaveLoadingView</a> ★1176 - 仿真波浪加载效果 </li><li><a href="https://github.com/race604/WaveLoading">WaveLoading</a> ★1094 - 能够提供波浪动画的Drawable </li><li><a href="https://github.com/nntuyen/mkloader">mkloader</a> ★1028 - 优美又流畅的自定义加载视图 </li><li><a href="https://github.com/Rogero0o/GifLoadingView">GifLoadingView</a> ★978 - webpage中的简单动画方法 </li><li><a href="https://github.com/Devlight/ArcProgressStackView">ArcProgressStackView</a> ★938 - arc模式进度条 </li><li><a href="https://github.com/jlmd/AnimatedCircleLoadingView">AnimatedCircleLoadingView</a> ★937 - 加载视图动画 </li><li><a href="https://github.com/yankai-victor/Loading">Loading</a> ★912 - 多个Android加载效果 </li><li><a href="https://github.com/lopspower/CircularFillableLoaders">CircularFillableLoaders</a> ★871 - 精致的环形填充加载效果 </li><li><a href="https://github.com/vlonjatg/progress-activity">progress-activity</a> ★793 - 进度条空视图及错误视图库 </li><li><a href="https://github.com/Kaopiz/KProgressHUD">KProgressHUD</a> ★757 - 安卓ProgressHUD实现 </li><li><a href="https://github.com/Rogero0o/CatLoadingView">CatLoadingView</a> ★756 - Android猫头像加载视图 </li><li><a href="https://github.com/Fichardu/CircleProgress">CircleProgress</a> ★755 - 带旋转动画的环形进度视图 </li><li><a href="https://github.com/jakob-grabner/Circle-Progress-View">CircleView</a> ★708 - 动画环形视图 </li><li><a href="https://github.com/aliab/circular-music-progressbar">Circular Music ProgressBar</a> ★627 - Android环形音乐进度条 </li><li><a href="https://github.com/Shinelw/ColorArcProgressBar">ColorArcProgressBar</a> ★616 - 可定制的圆形进度条 </li><li><a href="https://github.com/d-max/spots-dialog">spots-dialog</a> ★612 - Android提示对话框 </li><li><a href="https://github.com/rahatarmanahmed/CircularProgressView">CircularProgressView</a> ★605 - 环形进度条安卓视图 </li><li><a href="https://github.com/JeasonWong/SlackLoadingView">SlackLoadingView</a> ★604 - 模仿Slack加载动画 </li><li><a href="https://github.com/JustZak/DilatingDotsProgressBar">DilatingDotsProgressBar</a> ★598 - 自定义模糊进度条 </li><li><a href="https://github.com/HotBitmapGG/RingProgressBar">RingProgressBar</a> ★546 - MD风格的环形进度条 </li><li><a href="https://github.com/lingochamp/MagicProgressWidget">MagicProgressWidget</a> ★501 - 圆形进度条与横向进度条 </li><li><a href="https://github.com/SaeedMasoumi/FAB-Loading">FAB-Loading</a> ★482 - 浮动加载动画 </li><li><a href="https://github.com/pavlospt/CircleView">CircleView</a> ★480 - 包含标题和子标题的环形视图 </li><li><a href="https://github.com/ldoublem/RingProgress">RingProgress</a> ★472 - 带效果的环形进度条 </li><li><a href="https://github.com/TomWithJerry/CoolAndroidAnim">CoolAndroidAnim</a> ★472 - 酷炫的android loading效果 </li><li><a href="https://github.com/saiwu-bigkoo/Android-SVProgressHUD">Android-SVProgressHUD</a> ★464 - 精仿iOS的提示库 SVProgressHUD </li><li><a href="https://github.com/LineChen/FlickerProgressBar">FlickerProgressBar</a> ★444 - 安卓仿应用宝下载进度条 </li><li><a href="https://github.com/arieridwan8/pageloader">pageloader</a> ★346 - 轻松自定义加载页面 </li><li><a href="https://github.com/yingLanNull/CircleAlarmTimerView">CircleAlarmTimerView</a> ★306 - 圆形进度条 </li><li><a href="https://github.com/yuweiguocn/SquareLoading">SquareLoading</a> ★292 - 一个方形动画加载器 </li><li><a href="https://github.com/yxping/AdhesiveLoadingView">AdhesiveLoadingView</a> ★262 - 具有粘性的滑动小球loading </li><li><a href="https://github.com/zhangyuChen1991/OverWatchLoading">OverWatchLoading</a> ★250 - 守望先锋的加载动画效果 </li><li><a href="https://github.com/VictorAlbertos/SwipeCoordinator">SwipeCoordinator</a> ★218 - 简化动画滑动视图进程 </li><li><a href="https://github.com/xiprox/MarkView">MarkView</a> ★208 - 彩色圆弧的环形进度条 </li><li><a href="https://github.com/YangShaoXiong/LikeSinaSportProgress">LikeSinaSportProgress</a> ★204 - 仿新浪体育客户端的进度条 </li><li><a href="https://github.com/tingyik90/snackprogressbar">snackprogressbar</a> ★180 - 带有ProgressBar的增强型Snackbar </li><li><a href="https://github.com/niniloveyou/BounceLoadingView">BounceLoadingView</a> ★173 - 模仿饿了么加载效果 </li><li><a href="https://github.com/WhiteDG/ProgressView">ProgressView</a> ★156 - 多种样式的进度条 </li><li><a href="https://github.com/peng8350/LoadingProgress">LoadingProgress</a> ★148 - 加载进度条 </li><li><a href="https://github.com/biodunalfet/SlidingSquaresLoader">SlidingSquaresLoader</a> ★147 - 简单的进度加载 </li><li><a href="https://github.com/andyxialm/CutoLoadingView">CutoLoadingView</a> ★127 - 自定义加载视图 </li><li><a href="https://github.com/alex5241/AwesomeProgressbar">AwesomeProgressbar</a> ★108 - 支持左右两边同时滚动的进度条 </li><li><a href="https://github.com/ForgetAll/LoadingDialog">LoadingDialog</a> ★95 - 简单好用的LoadingDialog </li><li><a href="https://github.com/zhangyuChen1991/ZYDownloading">ZYDownloading</a> ★94 - 一个蛮酷的加载进度条 </li><li><a href="https://github.com/jineshfrancs/LazyLoadingViews">LazyLoadingViews</a> ★81 - Adapter视图中子视图加载效果 </li><li><a href="https://github.com/XBeats/and_cube_progress">and_cube_progress</a> ★74 - 正方体样式的loadingView </li><li><a href="https://github.com/niniloveyou/GradeProgressView">GradeProgressView</a> ★67 - 用来评估移动电话的进度条视图 </li><li><a href="https://github.com/DamanSingh4321/ProProgressViews">ProProgressViews</a> ★56 - Android精致进度视图收集库 </li><li><a href="https://github.com/zjywill/OverwatchProgress">OverwatchProgress</a> ★50 - 模仿Overwatch的进度条 </li><li><a href="https://github.com/eralpyucel/CircleProgressView">CircleProgressView</a> ★44 - 显示百分比进度的安卓组件 </li><li><a href="https://github.com/AlexMofer/CircleProgressBar">CircleProgressBar</a> ★36 - 带载入动画的环形进度条 </li><li><a href="https://github.com/bingoogolapple/BGAProgressBar-Android">BGAProgressBar-Android</a> ★31 - 安卓进度条 </li><li><a href="https://github.com/XuDeveloper/VideoLoadingView">VideoLoadingView</a> ★30 - 加载界面 </li><li><a href="https://github.com/anderson9/LovelyProgressBar">LovelyProgressBar</a> ★27 - 漂亮的加载动画 </li><li><a href="https://github.com/linglongxin24/BaiduProgressBar">BaiduProgressBar</a> ★23 - 仿百度加载动画 </li><li><a href="https://github.com/android-jian/customprogressbar">customprogressbar</a> ★19 - 自定义ProgressBar </li><li><a href="https://github.com/lvleo/DataLoadingLayoutAndroid">DataLoadingLayoutAndroid</a> ★15 - 展示当前数据加载状态的库</li></ul><h2 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a>TabLayout</h2><ul><li><a href="https://github.com/ogaclejapan/SmartTabLayout">SmartTabLayout</a> ★4416 - 在用户滚动时给出连续的反馈 </li><li><a href="https://github.com/H07000223/FlycoTabLayout">FlycoTabLayout</a> ★4126 - Android的TabLayout库 </li><li><a href="https://github.com/hackware1993/MagicIndicator">MagicIndicator</a> ★2310 - 强大易扩展的ViewPager指示器框架 </li><li><a href="https://github.com/hugeterry/CoordinatorTabLayout">CoordinatorTabLayout</a> ★2021 - 自定义组合控件 </li><li><a href="https://github.com/DevLight-Mobile-Agency/NavigationTabStrip">NavigationTabStrip</a> ★1413 - 平滑可交互导航标签条 </li><li><a href="https://github.com/Andy671/Dachshund-Tab-Layout">Dachshund-Tab-Layout</a> ★568 - 增强型Android标签布局 </li><li><a href="https://github.com/HomHomLin/AdvancedPagerSlidingTabStrip">AdvancedPagerSlidingTabStrip</a> ★318 - 安卓导航控件 </li><li><a href="https://github.com/simplezhli/ChangeTabLayout">ChangeTabLayout</a> ★185 - 模仿乐视LIVEApp主界面TabLayout效果 </li><li><a href="https://github.com/myinnos/SlidingTabWithColorIcons">SlidingTabWithColorIcons</a> ★22 - 带彩色图标的滑动标签 </li><li><a href="https://github.com/q805699513/PagerSlidingTabStrip">PagerSlidingTabStrip</a> ★21 - 指示器TabLayout、PagerSlidingTabStrip</li></ul><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><ul><li><a href="https://github.com/google/material-design-icons">Material design icons</a> ★30013 - 谷歌官方图标 </li><li><a href="https://github.com/JoanZapata/android-iconify">android-iconify</a> ★2966 - 多个图标供应商的图标整合 </li><li><a href="https://github.com/mikepenz/Android-Iconics">Android-Iconics</a> ★2825 - 在应用中使用图标字体或矢量 </li><li><a href="https://github.com/code-mc/material-icon-lib">material-icon-lib</a> ★1947 - 1500个MD风格矢量图标 </li><li><a href="https://github.com/tarek360/Animated-Icons">Animated-Icons</a> ★144 - 安卓动画图标 </li><li><a href="https://github.com/Livin21/DroidAwesome">DroidAwesome</a> ★25 - 视图或者菜单中显示FontAwesome图标</li></ul><h2 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h2><ul><li><a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh">android-Ultra-Pull-To-Refresh</a> ★7947 - 下拉刷新项目的替代方案 </li><li><a href="https://github.com/Yalantis/Phoenix">Phoenix</a> ★3296 - 可自定义滑动刷新实现 </li><li><a href="https://github.com/bingoogolapple/BGARefreshLayout-Android">BGARefreshLayout-Android</a> ★2998 - 多种下拉刷新和上拉加载插件 </li><li><a href="https://github.com/race604/FlyRefresh">FlyRefresh</a> ★2762 - 最有特色的下拉刷新 </li><li><a href="https://github.com/lcodecorex/TwinklingRefreshLayout">TwinklingRefreshLayout</a> ★2111 - 下拉刷新和上拉加载的RefreshLayout </li><li><a href="https://github.com/recruit-lifestyle/WaveSwipeRefreshLayout">WaveSwipeRefreshLayout</a> ★1595 - Android刷新控件 </li><li><a href="https://github.com/Aspsine/SwipeToLoadLayout">SwipeToLoadLayout</a> ★1522 - 可重用下拉刷新及上拉加载更多组件 </li><li><a href="https://github.com/Yalantis/Taurus">Taurus</a> ★1441 - 简单和可定制的下拉刷新实现 </li><li><a href="https://github.com/dinuscxj/RecyclerRefreshLayout">RecyclerRefreshLayout</a> ★1391 - 通过垂直滑动手势刷新当前view内容 </li><li><a href="https://github.com/Yalantis/pull-to-make-soup">pull-to-make-soup</a> ★1254 - 自定义动画下拉刷新 </li><li><a href="https://github.com/Hitomis/FunGameRefresh">FunGameRefresh</a> ★1098 - 有趣好玩的下拉刷新库 </li><li><a href="https://github.com/WuXiaolong/PullLoadMoreRecyclerView">PullLoadMoreRecyclerView</a> ★962 - 上拉刷新加载 </li><li><a href="https://github.com/huxq17/XRefreshView">XRefreshView</a> ★902 - android下拉上拉刷新框架 </li><li><a href="https://github.com/Chanven/CommonPullToRefresh">CommonPullToRefresh</a> ★884 - 下拉刷新 </li><li><a href="https://github.com/OrangeGangsters/SwipyRefreshLayout">SwipyRefreshLayout</a> ★832 - 在两个方向上滑动的SwipeRefreshLayout扩展 </li><li><a href="https://github.com/ashqal/ChromeLikeSwipeLayout">ChromeLikeSwipeLayout</a> ★636 - 执行更多事件的下拉事件 </li><li><a href="https://github.com/imallan/JellyRefreshLayout">JellyRefreshLayout</a> ★608 - 下拉刷新布局 </li><li><a href="https://github.com/shichaohui/AnimRefreshRecyclerView">AnimRefreshRecyclerView</a> ★534 - 下拉刷新和上拉加载更多的RecyclerView </li><li><a href="https://github.com/lubeast/PullToRefresh">PullToRefresh</a> ★516 - 下拉刷新实现 </li><li><a href="https://github.com/hougr/SmartisanPull">SmartisanPull</a> ★506 - 最优雅的下拉控件 </li><li><a href="https://github.com/pengjianbo/LoadingViewFinal">LoadingViewFinal</a> ★269 - 实现了下拉刷新&#x2F;加载更多的android组件 </li><li><a href="https://github.com/dinuscxj/ShootRefreshView">ShootRefreshView</a> ★263 - 快手Android客户端刷新动画 </li><li><a href="https://github.com/Y-bao/PullRefreshView">PullRefreshView</a> ★241 - 为滑动控件添加上拉刷新下拉加载等功能 </li><li><a href="https://github.com/songixan/SmileRefresh">SmileRefresh</a> ★191 - 微笑下拉刷新 </li><li><a href="https://github.com/leoleohan/RecyclerRefresh">RecyclerRefresh</a> ★172 - 仿简书安卓端 </li><li><a href="https://github.com/LuckyJayce/CoolRefreshView">CoolRefreshView</a> ★128 - 安卓刷新视图库 </li><li><a href="https://github.com/anzaizai/EasyRefreshLayout">EasyRefreshLayout</a> ★116 - 轻松实现下拉刷新和上拉加载 </li><li><a href="https://github.com/linuxjava/RefreshLayout">RefreshLayout</a> ★77 - 实现下拉刷新和上拉加载 </li><li><a href="https://github.com/ileelay/VRefreshLayout">VRefreshLayout</a> ★67 - 竖直方向的下拉刷新控件 </li><li><a href="https://github.com/borneywpf/TLRLoadRefresh">TLRLoadRefresh</a> ★63 - 下拉刷新和上拉加载的UI组件 </li><li><a href="https://github.com/genius158/RefreshLayout">RefreshLayout</a> ★48 - 下拉刷新、上拉加载，支持回弹效果 </li><li><a href="https://github.com/lovejjfg/PowerRefresh">PowerRefresh</a> ★36 - 实现嵌套滑动机制的通用下拉刷新和加载更多 </li><li><a href="https://github.com/linuxjava/HorizontalRefreshLayout">HorizontalRefreshLayout</a> ★36 - 实现左右刷新 </li><li><a href="https://github.com/StevenDXC/DxWaveRefresh">DxWaveRefresh</a> ★34 - 波浪效果的下拉刷新 </li><li><a href="https://github.com/Ilya-Gh/Typewriter">Typewriter</a> ★28 - 打印机效果的下拉刷新控件 </li><li><a href="https://github.com/REBOOTERS/UltimateRefreshView">UltimateRefreshView</a> ★25 - 下拉刷新组件 </li><li><a href="https://github.com/sangenan/DonkeyRefresh">DonkeyRefresh</a> ★16 - 仿赶集下拉刷新</li></ul><h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><ul><li><a href="https://github.com/florent37/MaterialViewPager">MaterialViewPager</a> ★6124 - 安卓选项卡插件 </li><li><a href="https://github.com/DevLight-Mobile-Agency/InfiniteCycleViewPager">InfiniteCycleViewPager</a> ★3807 - 无限循环的视图页 </li><li><a href="https://github.com/lsjwzh/RecyclerViewPager">RecyclerViewPager</a> ★2372 - 基于RecyclerView的ViewPager替代品 </li><li><a href="https://github.com/rubensousa/ViewPagerCards">ViewPagerCards</a> ★2297 - 视图页卡片 </li><li><a href="https://github.com/ongakuer/CircleIndicator">CircleIndicator</a> ★2283 - 轻量级ViewPager指示器 </li><li><a href="https://github.com/romandanylyk/PageIndicatorView">PageIndicatorView</a> ★1971 - 能够指示选定页的ViewPage </li><li><a href="https://github.com/alibaba/UltraViewPager">UltraViewPager</a> ★1833 - 封装多种特性的ViewPager </li><li><a href="https://github.com/githubwing/ZoomHeader">ZoomHeader</a> ★1797 - 模仿饿了么详情页的例子 </li><li><a href="https://github.com/xmuSistone/android-page-transition">android-page-transition</a> ★1641 - 带有垂直滑动效果和Activity过渡的ViewPager </li><li><a href="https://github.com/LuckyJayce/ViewPagerIndicator">ViewPagerIndicator</a> ★1586 - 布局插件 </li><li><a href="https://github.com/ToxicBakery/ViewPagerTransforms">ViewPagerTransforms</a> ★1542 - 包含视图页滚动常见动画的库 </li><li><a href="https://github.com/qs-lll/ExpandingPager">ExpandingPager</a> ★1489 - 卡片peek及pop控件 </li><li><a href="https://github.com/kmshack/Android-ParallaxHeaderViewPager">Android-ParallaxHeaderViewPager</a> ★1307 - 带标题头的左右滑动 </li><li><a href="https://github.com/Pixplicity/MultiViewPager">MultiViewPager</a> ★855 - 支持V4库的ViewPager的扩展 </li><li><a href="https://github.com/chengdazhi/DecentBanner">DecentBanner</a> ★812 - 基于安卓Banner的ViewPager </li><li><a href="https://github.com/Telenav/ExpandablePager">ExpandablePager</a> ★684 - 两个状态（展开和滑动）间的垂直滑动切换 </li><li><a href="https://github.com/voghDev/PdfViewPager">PdfViewPager</a> ★590 - 在Activities或Fragments中显示PDF文档 </li><li><a href="https://github.com/antonyt/InfiniteViewPager">InfiniteViewPager</a> ★587 - 环绕实现首页末页跳转 </li><li><a href="https://github.com/ybq/ParallaxViewPager">ParallaxViewPager</a> ★497 - 安卓视差视图页 </li><li><a href="https://github.com/qdxxxx/BezierViewPager">BezierViewPager</a> ★494 - 触摸贝塞尔圆球式图片展示 </li><li><a href="https://github.com/lightSky/InfiniteIndicator">InfiniteIndicator</a> ★469 - 视图回收适配器 </li><li><a href="https://github.com/hongyangAndroid/MagicViewPager">MagicViewPager</a> ★420 - 单页ViewPager炫酷切换效果 </li><li><a href="https://github.com/jeasonlzy/HeaderViewPager">HeaderViewPager</a> ★341 - 具有共同头部的 ViewPager </li><li><a href="https://github.com/youngkaaa/YViewPagerDemo">YViewPagerDemo</a> ★247 - 水平竖直方向上滑动 </li><li><a href="https://github.com/StylingAndroid/ViewPagerAnimator">ViewPagerAnimator</a> ★240 - ViewPager动画库 </li><li><a href="https://github.com/githubwing/ExpandableViewpager">ExpandableViewpager</a> ★232 - 可展开缩小的Viewpager </li><li><a href="https://github.com/chaossss/PianoView">PianoView</a> ★230 - 有趣的类似钢琴键盘的 ViewPager Indicator </li><li><a href="https://github.com/BCsl/GalleryLayoutManager">GalleryLayoutManager</a> ★151 - Android中Gallery或ViewPager控件的效果 </li><li><a href="https://github.com/ZuYun/JPagerSlidingTabStrip">JPagerSlidingTabStrip</a> ★90 - 修改自astuetz&#x2F;PagerSlidingTabStrip的tablayout </li><li><a href="https://github.com/xingstarx/InkeVerticalViewPagerLive">InkeVerticalViewPagerLive</a> ★83 - 仿映客上下滑动切换直播demo </li><li><a href="https://github.com/demoNo/ParallaxViewPager">ParallaxViewPager</a> ★63 - 带视差效果的简单ViewPager </li><li><a href="https://github.com/BeppiMenozzi/ArcPageIndicator">ArcPageIndicator</a> ★40 - 全自定义超简单的页面指示器</li></ul><h2 id="图表-Chart"><a href="#图表-Chart" class="headerlink" title="图表(Chart)"></a>图表(Chart)</h2><ul><li><a href="https://github.com/PhilJay/MPAndroidChart">MPAndroidChart</a> ★16070 - 安卓图表解决方案 </li><li><a href="https://github.com/lecho/hellocharts-android">hellocharts-android</a> ★4332 - Android图表库 </li><li><a href="https://github.com/diogobernardino/WilliamChart">WilliamChart</a> ★3145 - 在应用程序中实现图表的Android库 </li><li><a href="https://github.com/jjoe64/GraphView">GraphView</a> ★1630 - 通过编程创建灵活好看的图表 </li><li><a href="https://github.com/ZuYun/Jgraph">Jgraph</a> ★1063 - 可自定义图表 </li><li><a href="https://github.com/HackPlan/AndroidCharts">AndroidCharts</a> ★935 - 一个简单的Android图表库 </li><li><a href="https://github.com/bmarrdev/android-DecoView-charting">android-DecoView-charting</a> ★780 - 实现高度可配置动画环形图表 </li><li><a href="https://github.com/robinhood/spark">spark</a> ★651 - 将任何规模xy点绘制为sparkline图表 </li><li><a href="https://github.com/whataa/SuitLines">SuitLines</a> ★650 - 小巧且高效的线性图表组件 </li><li><a href="https://github.com/DmitriyZaitsev/RadarChartView">RadarChartView</a> ★419 - 渲染径向图的Android视图 </li><li><a href="https://github.com/hrules6872/Charter">Charter</a> ★198 - 简易图表 </li><li><a href="https://github.com/qstumn/RadarChart">RadarChart</a> ★195 - 自由定制旋转交互的Android雷达图 </li><li><a href="https://github.com/JeasonWong/AndroidChart">AndroidChart</a> ★157 - 简单的安卓分时行情页 </li><li><a href="https://github.com/danimahardhika/candybar-library">candybar-library</a> ★107 - Android图表包装材料面板 </li><li><a href="https://github.com/mancj/SlimChart">SlimChart</a> ★80 - 轻量级便于使用的图表库 </li><li><a href="https://github.com/Cuieney/BarChart-master">BarChart-master</a> ★26 - 自动伸缩的chart </li><li><a href="https://github.com/Andy671/PianoChartView">PianoChartView</a> ★21 - 显示钢琴和弦比例尺图</li></ul><h2 id="菜单-Menu"><a href="#菜单-Menu" class="headerlink" title="菜单(Menu)"></a>菜单(Menu)</h2><ul><li><a href="https://github.com/levey/AwesomeMenu">AwesomeMenu</a> ★5086 - 与Path的故事菜单具有相同外观的菜单 </li><li><a href="https://github.com/Yalantis/Context-Menu.Android">Context-Menu.Android</a> ★2965 - 独特的动画内容菜单 </li><li><a href="https://github.com/dongjunkun/DropDownMenu">DropDownMenu</a> ★2010 - 多条件筛选菜单 </li><li><a href="https://github.com/ShamylZakariya/FlyoutMenus">FlyoutMenus</a> ★821 - Android简易MD风格弹出菜单 </li><li><a href="https://github.com/michaldrabik/TapBarMenu">TapBarMenu</a> ★803 - Tap Bar菜单布局 </li><li><a href="https://github.com/Hitomis/CircleMenu">CircleMenu</a> ★723 - 具有设计感的菜单 </li><li><a href="https://github.com/Hitomis/SpinMenu">SpinMenu</a> ★656 - 轮播样式的Fragment菜单选择空间 </li><li><a href="https://github.com/baiiu/DropDownMenu">DropDownMenu</a> ★632 - 完整的筛选器解决方案 </li><li><a href="https://github.com/gotokatsuya/BlurredGridMenu">BlurredGridMenu</a> ★470 - 酷炫网格菜单 </li><li><a href="https://github.com/Hitomis/ThumbnailMenu">ThumbnailMenu</a> ★422 - 简单而精致的Fragment菜单控件 </li><li><a href="https://github.com/zaaach/TopRightMenu">TopRightMenu</a> ★349 - 仿手机QQ界面右上角的弹出菜单 </li><li><a href="https://github.com/Cleveroad/CycleMenu">CycleMenu</a> ★251 - 圆形菜单 </li><li><a href="https://github.com/stewForAni/CircleProgressMenu">CircleProgressMenu</a> ★108 - 带有进度效果的简单环形菜单 </li><li><a href="https://github.com/kareluo/PopupMenuView">PopupMenuView</a> ★67 - iOS中弹框气泡菜单的控件 </li><li><a href="https://github.com/desnyki/InfinityMenu">InfinityMenu</a> ★66 - 实现手风琴样式菜单的Android库 </li><li><a href="https://github.com/cpacm/FloatingMusicMenu">FloatingMusicMenu</a> ★57 - 用于音乐播放器的悬浮菜单按钮 </li><li><a href="https://github.com/AlexLiuSheng/CircleMenuView">CircleMenuView</a> ★44 - 自定义圆形菜单 </li><li><a href="https://github.com/lichenyu10/SlidMenu">SlidMenu</a> ★29 - 轮盘样式的Fragment菜单选择控件 </li><li><a href="https://github.com/Rance935/SectorMenu">SectorMenu</a> ★18 - 炫酷的扇形菜单</li></ul><h2 id="浮动菜单"><a href="#浮动菜单" class="headerlink" title="浮动菜单"></a>浮动菜单</h2><ul><li><a href="https://github.com/Nightonke/BoomMenu">BoomMenu</a> ★3617 - 具有炸裂效果的菜单按钮 </li><li><a href="https://github.com/oguzbilgener/CircularFloatingActionMenu">CircularFloatingActionMenu</a> ★1995 - 自定义圆形浮动动画菜单 </li><li><a href="https://github.com/michaldrabik/TapBarMenu">TapBarMenu</a> ★803 - Tap Bar菜单布局 </li><li><a href="https://github.com/ImangazalievM/CircleMenu">CircleMenu</a> ★649 - 简单的优雅的菜单 </li><li><a href="https://github.com/Karumi/ExpandableSelector">ExpandableSelector</a> ★578 - 动画的折叠或展开按钮列表 </li><li><a href="https://github.com/kakajika/RelativePopupWindow">RelativePopupWindow</a> ★554 - 轻松对锚视图相对定位 </li><li><a href="https://github.com/gjiazhe/MultiChoicesCircleButton">MultiChoicesCircleButton</a> ★312 - 带3d视差效果的多选按钮 </li><li><a href="https://github.com/tiancaiCC/SpringFloatingActionMenu">SpringFloatingActionMenu</a> ★282 - 点击FAB弹出菜单 </li><li><a href="https://github.com/crosg/FloatMenuSample">FloatMenuSample</a> ★264 - android 悬浮窗菜单 </li><li><a href="https://github.com/rjsvieira/floatingMenu">floatingMenu</a> ★196 - 一个像orbit的action button </li><li><a href="https://github.com/xue5455/SmartMenu">SmartMenu</a> ★179 - 一个优美的浮动菜单 </li><li><a href="https://github.com/joelan/WeiboPopupMenu">WeiboPopupMenu</a> ★20 - 仿微博添加按钮弹出菜单</li></ul><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><ul><li><a href="https://github.com/afollestad/material-dialogs">Material Dialogs</a> ★9911 - 安卓Material风格对话框 </li><li><a href="https://github.com/orhanobut/dialogplus">dialogplus</a> ★3217 - 对话框动画 </li><li><a href="https://github.com/sd6352051/NiftyDialogEffects">NiftyDialogEffects</a> ★2054 - Nifty模式对话框效果 </li><li><a href="https://github.com/yipianfengye/android-adDialog">android-adDialog</a> ★1734 - 简单强大的广告活动弹窗控件 </li><li><a href="https://github.com/tvbarthel/BlurDialogFragment">BlurDialogFragment</a> ★1539 - 背景模糊效果的DialogFragment </li><li><a href="https://github.com/saiwu-bigkoo/Android-AlertView">Android-AlertView</a> ★879 - 仿iOS的AlertViewController </li><li><a href="https://github.com/Meetic/MaryPopup">MaryPopup</a> ★817 - 无忧扩展视图 </li><li><a href="https://github.com/javiersantos/MaterialStyledDialogs">MaterialStyledDialogs</a> ★804 - 显示优美可定制的Android对话框 </li><li><a href="https://github.com/shaohui10086/BottomDialog">BottomDialog</a> ★756 - 底部弹窗布局 </li><li><a href="https://github.com/kakajika/SwipeAwayDialog">SwipeAwayDialog</a> ★703 - 实现滑动取消对话框 </li><li><a href="https://github.com/yarolegovich/LovelyDialog">LovelyDialog</a> ★646 - 帮助你轻松的创建流行的MD风格对话框 </li><li><a href="https://github.com/michaelye/EasyDialog">EasyDialog</a> ★549 - Android轻量级提示对话框 </li><li><a href="https://github.com/hss01248/DialogUtil">DialogUtil</a> ★401 - 任意界面弹出框 </li><li><a href="https://github.com/geniusforapp/fancyDialog">fancyDialog</a> ★310 - Android自定义提示框 </li><li><a href="https://github.com/weavey/NormalSelectDialog">NormalSelectDialog</a> ★237 - 常见布局封装 </li><li><a href="https://github.com/Zhaoss/HintPopupWindow">HintPopupWindow</a> ★222 - 仿qq弹出方式 </li><li><a href="https://github.com/jiang111/IndicatorDialog">IndicatorDialog</a> ★211 - 使用箭头指示器和不同位置的对话框 </li><li><a href="https://github.com/SpikeKing/BottomDialogDemo">BottomDialogDemo</a> ★206 - 使用 DialogFragment 实现底部弹窗布局 </li><li><a href="https://github.com/codemybrainsout/PlaceSearchDialog">PlaceSearchDialog</a> ★161 - 位置自动搜索对话框 </li><li><a href="https://github.com/jjdxmashl/jjdxm_dialogui">jjdxm_dialogui</a> ★122 - 多种弹出框样式 </li><li><a href="https://github.com/1em0nsOft/LemonHello4Android">LemonHello4Android</a> ★93 - 内置多种主题提示框 </li><li><a href="https://github.com/limxing/Android-PromptDialog">Android-PromptDialog</a> ★79 - 正在加载中确认对话框轻量View </li><li><a href="https://github.com/kngfrhzs/panter-dialog">panter-dialog</a> ★71 - 丰富样式的Android对话框 </li><li><a href="https://github.com/t-kurimura/flickabledialog">flickabledialog</a> ★52 - 通过轻滑实现取消效果 </li><li><a href="https://github.com/GitPhoenix/WheelDialogFragment">WheelDialogFragment</a> ★17 - 用于时间选择城市选择的对话框 </li><li><a href="https://github.com/loonggg/BottomSheetPopupDialog">BottomSheetPopupDialog</a> ★8 - 底部弹出框</li></ul><h2 id="空白页"><a href="#空白页" class="headerlink" title="空白页"></a>空白页</h2><ul><li><a href="https://github.com/vlonjatg/progress-activity">progress-activity</a> ★793 - 进度条空视图及错误视图库 </li><li><a href="https://github.com/Kennyc1012/MultiStateView">MultiStateView</a> ★779 - 基于状态显示不同内容的Android视图 </li><li><a href="https://github.com/gturedi/StatefulLayout">StatefulLayout</a> ★610 - 显示最常见的状态模板 </li><li><a href="https://github.com/qyxxjd/MultipleStatusView">MultipleStatusView</a> ★604 - 支持多种状态的自定义View </li><li><a href="https://github.com/iammert/StatusView">StatusView</a> ★574 - Android自定义状态视图 </li><li><a href="https://github.com/xiprox/ErrorView">ErrorView</a> ★521 - 显示错误信息的自定义视图 </li><li><a href="https://github.com/weavey/LoadingLayoutDemo">LoadingLayoutDemo</a> ★510 - 加载中&#x2F;无网络&#x2F;无数据&#x2F;出错四种情况效果封装 </li><li><a href="https://github.com/barryhappy/TEmptyView">TEmptyView</a> ★428 - 更简单地设置EmptyView </li><li><a href="https://github.com/fingdo/stateLayout">stateLayout</a> ★359 - 快速switch布局 </li><li><a href="https://github.com/czy1121/loadinglayout">loadinglayout</a> ★321 - 简单实用的页面多状态布局 </li><li><a href="https://github.com/WassimBenltaief/FlowLayout">FlowLayout</a> ★219 - 非常常见的安卓视图流 </li><li><a href="https://github.com/WangGanxin/LoadDataLayout">LoadDataLayout</a> ★186 - 加载数据Layout </li><li><a href="https://github.com/XuDaojie/MultiStateView">MultiStateView</a> ★179 - 用于切换不同View的各种状态 </li><li><a href="https://github.com/nguyenhoanglam/ProgressLayout">ProgressLayout</a> ★98 - 展示加载布局空白布局和error布局 </li><li><a href="https://github.com/hss01248/PageStateManager">PageStateManager</a> ★89 - 页面状态管理 </li><li><a href="https://github.com/hcs-xph/HHEmptyView">HHEmptyView</a> ★35 - 网络加载提示进度封装View </li><li><a href="https://github.com/lvleo/DataLoadingLayoutAndroid">DataLoadingLayoutAndroid</a> ★15 - 展示当前数据加载状态的库</li></ul><h2 id="滑动删除"><a href="#滑动删除" class="headerlink" title="滑动删除"></a>滑动删除</h2><ul><li><a href="https://github.com/daimajia/AndroidSwipeLayout">AndroidSwipeLayout</a> ★8066 - 安卓滑动出现子菜单 </li><li><a href="https://github.com/yanzhenjie/SwipeRecyclerView">SwipeRecyclerView</a> ★1742 - RecyclerView侧滑菜单 </li><li><a href="https://github.com/kikoso/Swipeable-Cards">Swipeable-Cards</a> ★1375 - 提供类似Tinder卡片效果 </li><li><a href="https://github.com/HoneyNeutrons/RecyclerViewUndoSwipe">RecyclerViewUndoSwipe</a> ★1276 - 本地ItemTouch助手 </li><li><a href="https://github.com/flschweiger/SwipeStack">SwipeStack</a> ★1142 - 安卓纸质视图栈 </li><li><a href="https://github.com/mcxtzhang/SwipeDelMenuLayout">SwipeDelMenuLayout</a> ★1033 - 仿IOS侧滑Item删除菜单 </li><li><a href="https://github.com/loopeer/itemtouchhelper-extension">itemtouchhelper-extension</a> ★814 - 添加滑动条目处理 </li><li><a href="https://github.com/TUBB/SwipeMenu">SwipeMenu</a> ★662 - 滑动菜单 </li><li><a href="https://github.com/wenchaojiang/AndroidSwipeableCardStack">AndroidSwipeableCardStack</a> ★563 - 流畅的纸质卡片组件 </li><li><a href="https://github.com/chthai64/SwipeRevealLayout">SwipeRevealLayout</a> ★517 - 通过swipe及slide显示另一个布局 </li><li><a href="https://github.com/Qiaoidea/QQTipsView">QQTipsView</a> ★482 - 仿QQ消息未读拖拽清除 </li><li><a href="https://github.com/huxq17/SwipeCardsView">SwipeCardsView</a> ★370 - Android高仿秒拍热榜的卡片滑动和左右飞出效果 </li><li><a href="https://github.com/HalfStackDeveloper/SwipeCardRecyclerView">SwipeCardRecyclerView</a> ★238 - 炫酷滑动卡片 </li><li><a href="https://github.com/yuqirong/CardSwipeLayout">CardSwipeLayout</a> ★199 - RecyclerView卡片滑动布局 </li><li><a href="https://github.com/yanbober/SlideLayout">SlideLayout</a> ★182 - 全方向完美滑动处理侧滑控件 </li><li><a href="https://github.com/alexandrius/accordion-swipe-layout">accordion-swipe-layout</a> ★71 - Android手风琴滑动布局</li></ul><h2 id="手势操作"><a href="#手势操作" class="headerlink" title="手势操作"></a>手势操作</h2><ul><li><a href="https://github.com/nisrulz/sensey">sensey</a> ★1953 - 手势交互Android库 </li><li><a href="https://github.com/alexvasilkov/GestureViews">GestureViews</a> ★1243 - 手势控制和位置动画 </li><li><a href="https://github.com/zhaozhentao/InboxLayout">InboxLayout</a> ★648 - 仿谷歌下拉返回效果 </li><li><a href="https://github.com/pkarira/Swipper">Swipper</a> ★47 - 控制亮度的自定义视图</li></ul><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><ul><li><a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper">BaseRecyclerViewAdapterHelper</a> ★7640 - 强大灵活的RecyclerAdapter </li><li><a href="https://github.com/wasabeef/recyclerview-animators">recyclerview-animators</a> ★6236 - 轻松创建动画RecyclerView </li><li><a href="https://github.com/cymcsg/UltimateRecyclerView">UltimateRecyclerView</a> ★5544 - 功能强大的Recyclerview </li><li><a href="https://github.com/alibaba/vlayout">vlayout</a> ★4665 - 布局方案和布局间的组件复用 </li><li><a href="https://github.com/h6ah4i/android-advancedrecyclerview">android-advancedrecyclerview</a> ★3304 - 提供高级特性的RecyclerView扩展 </li><li><a href="https://github.com/jianghejie/XRecyclerView">XRecyclerView</a> ★2972 - 下拉刷新和加载更多 </li><li><a href="https://github.com/airbnb/epoxy">epoxy</a> ★2896 - Airbnb安卓视图架构 </li><li><a href="https://github.com/hongyangAndroid/baseAdapter">baseAdapter</a> ★2685 - Android 万能的Adapter </li><li><a href="https://github.com/yarolegovich/DiscreteScrollView">DiscreteScrollView</a> ★2494 - 基于RecyclerView的滚动列表实现 </li><li><a href="https://github.com/Malinskiy/SuperRecyclerView">SuperRecyclerView</a> ★2463 - 轻松制作可使用的RecyclerView </li><li><a href="https://github.com/lsjwzh/RecyclerViewPager">RecyclerViewPager</a> ★2372 - 基于RecyclerView的ViewPager替代品 </li><li><a href="https://github.com/drakeet/MultiType">MultiType</a> ★1998 - 快速清晰的开发复杂列表页面 </li><li><a href="https://github.com/yanzhenjie/SwipeRecyclerView">SwipeRecyclerView</a> ★1742 - RecyclerView侧滑菜单 </li><li><a href="https://github.com/mikepenz/FastAdapter">FastAdapter</a> ★1612 - 简化RecyclerView配置过程 </li><li><a href="https://github.com/Jude95/EasyRecyclerView">EasyRecyclerView</a> ★1476 - 常用的RecyclerView的各种需求封装 </li><li><a href="https://github.com/kanytu/android-parallax-recyclerview">android-parallax-recyclerview</a> ★1460 - Android 视差 RecycleView </li><li><a href="https://github.com/huazhiyuan2008/RecyclerViewCardGallery">RecyclerViewCardGallery</a> ★1443 - RecyclerView实现Card Gallery效果 </li><li><a href="https://github.com/jdsjlzx/LRecyclerView">LRecyclerView</a> ★1366 - 多功能RecyclerView </li><li><a href="https://github.com/zhouchaoyuan/excelPanel">excelPanel</a> ★1305 - 仿Excel表格的RecyclerView </li><li><a href="https://github.com/HoneyNeutrons/RecyclerViewUndoSwipe">RecyclerViewUndoSwipe</a> ★1276 - 本地ItemTouch助手 </li><li><a href="https://github.com/sharish/ShimmerRecyclerView">ShimmerRecyclerView</a> ★1175 - 展现视图加载中的视图 </li><li><a href="https://github.com/EverythingMe/overscroll-decor">overscroll-decor</a> ★1100 - Android的仿iOS滚动效果 </li><li><a href="https://github.com/blipinsk/RecyclerViewHeader">RecyclerViewHeader</a> ★1094 - 为安卓RecyclerView创建header </li><li><a href="https://github.com/afollestad/drag-select-recyclerview">drag-select-recyclerview</a> ★1036 - 实现GooglePhoto样式多选择 </li><li><a href="https://github.com/pedrovgs/Renderers">Renderers</a> ★1036 - 创建适配器的Android库 </li><li><a href="https://github.com/WuXiaolong/PullLoadMoreRecyclerView">PullLoadMoreRecyclerView</a> ★962 - 上拉刷新加载 </li><li><a href="https://github.com/danoz73/RecyclerViewFastScroller">RecyclerViewFastScroller</a> ★887 - 连接到RecyclerView实现快速滚动 </li><li><a href="https://github.com/jiang111/IndexRecyclerView">IndexRecyclerView</a> ★869 - 使用Recyclerview实现的联系人列表 </li><li><a href="https://github.com/jaychang0917/SimpleRecyclerView">SimpleRecyclerView</a> ★859 - 轻松创建列表的RecyclerView扩展 </li><li><a href="https://github.com/Genius/groupie">groupie</a> ★848 - 显示并管理复杂的RecyclerView布局 </li><li><a href="https://github.com/ShamylZakariya/StickyHeaders">StickyHeaders</a> ★784 - 安卓RecyclerView的适配器和布局管理器 </li><li><a href="https://github.com/nikhilpanju/RecyclerViewEnhanced">RecyclerViewEnhanced</a> ★774 - 条目滑动点击安卓库 </li><li><a href="https://github.com/Solartisan/WaveSideBar">WaveSideBar</a> ★750 - 快速跳跃分组的侧边栏控件 </li><li><a href="https://github.com/timusus/RecyclerView-FastScroll">RecyclerView-FastScroll</a> ★730 - 简单的FastScroller </li><li><a href="https://github.com/zaihuishou/ExpandableRecyclerview">ExpandableRecyclerview</a> ★716 - ExpandableRecycler适配器 </li><li><a href="https://github.com/Frank-Zhu/AndroidRecyclerViewDemo">AndroidRecyclerViewDemo</a> ★632 - 安卓RecyclerView 示例 </li><li><a href="https://github.com/AleBarreto/DragRecyclerView">DragRecyclerView</a> ★573 - 在RecyclerView中拖拽的简单实现 </li><li><a href="https://github.com/tumblr/Graywater">Graywater</a> ★544 - 改进RecyclerView布局的库 </li><li><a href="https://github.com/truizlop/SectionedRecyclerView">SectionedRecyclerView</a> ★540 - 安卓RecyclerView 适配器 </li><li><a href="https://github.com/drakeet/RecyclerViewWithHeaderNewPractice">RecyclerViewWithHeaderNewPractice</a> ★537 - 结合HeaderView的RecyclerView新实现 </li><li><a href="https://github.com/shichaohui/AnimRefreshRecyclerView">AnimRefreshRecyclerView</a> ★534 - 下拉刷新和上拉加载更多的RecyclerView </li><li><a href="https://github.com/L4Digital/FastScroll">FastScroll</a> ★532 - 类似列表视图的FastScroller </li><li><a href="https://github.com/radzio/android-data-binding-recyclerview">android-data-binding-recyclerview</a> ★489 - 配有Android数据绑定的RecyclerView </li><li><a href="https://github.com/bingoogolapple/BGAAdapter-Android">BGAAdapter-Android</a> ★454 - 通用的Adapter和ViewHolder </li><li><a href="https://github.com/kHRYSTAL/CircleRecyclerView">CircleRecyclerView</a> ★435 - 一个循环RecyclerView </li><li><a href="https://github.com/iwgang/FamiliarRecyclerView">FamiliarRecyclerView</a> ★357 - RecyclerView类库 </li><li><a href="https://github.com/LuckyJayce/MultiTypeView">MultiTypeView</a> ★316 - 复杂界面分多个模块开发 </li><li><a href="https://github.com/AlphaBoom/ClassifyView">ClassifyView</a> ★306 - 拖拽合并的RecyclerView </li><li><a href="https://github.com/wuapnjie/SuspensionBar">SuspensionBar</a> ★276 - Android轻松实现RecyclerView悬浮条 </li><li><a href="https://github.com/TellH/RecyclerStickyHeaderView">RecyclerStickyHeaderView</a> ★259 - RecyclerView的悬浮视图 </li><li><a href="https://github.com/HalfStackDeveloper/SwipeCardRecyclerView">SwipeCardRecyclerView</a> ★238 - 炫酷滑动卡片 </li><li><a href="https://github.com/MFlisar/DragSelectRecyclerView">DragSelectRecyclerView</a> ★227 - 简单的触摸监听类 </li><li><a href="https://github.com/songhanghang/Smart-HeaderFooter-RecyclerView">Smart-HeaderFooter-RecyclerView</a> ★214 - 将Recyclerview添加HeaderView和FooterView </li><li><a href="https://github.com/myinnos/AlphabetIndex-Fast-Scroll-RecyclerView">AlphabetIndex-Fast-Scroll-RecyclerView</a> ★180 - 强大的AlphabetIndex FastScroller </li><li><a href="https://github.com/leoleohan/RecyclerRefresh">RecyclerRefresh</a> ★172 - 仿简书安卓端 </li><li><a href="https://github.com/TellH/RecyclerTreeView">RecyclerTreeView</a> ★167 - 安卓的TreeView实现 </li><li><a href="https://github.com/ssseasonnn/PracticalRecyclerView">PracticalRecyclerView</a> ★156 - RecyclerView的一个封装 </li><li><a href="https://github.com/limedroid/ARecyclerView">ARecyclerView</a> ★112 - 一个库搞定recyclerview </li><li><a href="https://github.com/gjiazhe/SpringRecyclerView">SpringRecyclerView</a> ★90 - 具有弹簧效果的RecyclerView </li><li><a href="https://github.com/oubowu/StickyItemDecoration">StickyItemDecoration</a> ★83 - RecyclerView粘性头部 </li><li><a href="https://github.com/10clouds/InifiniteRecyclerView">InifiniteRecyclerView</a> ★65 - 实现无尽加载列表 </li><li><a href="https://github.com/IntruderShanky/Sectioned-RecyclerView">Sectioned-RecyclerView</a> ★57 - 带header和item的RecyclerView的简单实现方式 </li><li><a href="https://github.com/LinLshare/StickyRecyclerSettingView">StickyRecyclerSettingView</a> ★48 - 快速在Android上建立SettingActivity </li><li><a href="https://github.com/youngkaaa/RecyclerAnimations">RecyclerAnimations</a> ★47 - item滑动时的循环动画 </li><li><a href="https://github.com/tikivn/NoAdapter">NoAdapter</a> ★45 - 使用RecyclerView实现一个列表 </li><li><a href="https://github.com/rubengees/EasyHeaderFooterAdapter">EasyHeaderFooterAdapter</a> ★34 - 在RecyclerView中添加header或者footer </li><li><a href="https://github.com/laobie/RecyclerViewDivider">RecyclerViewDivider</a> ★29 - 为RecyclerView设置分频器 </li><li><a href="https://github.com/yuyuyu123/SwipeCardsRecyclerView">SwipeCardsRecyclerView</a> ★22 - 基于RecyclerView的Android组件 </li><li><a href="https://github.com/AndroidMsky/GlideScrollRecyclerView">GlideScrollRecyclerView</a> ★21 - RecyclerView优先加载可见item </li><li><a href="https://github.com/nukc/RecyclerAdapter">RecyclerAdapter</a> ★15 - 简化封装RecyclerView.Adapter</li></ul><h2 id="Card"><a href="#Card" class="headerlink" title="Card"></a>Card</h2><ul><li><a href="https://github.com/Ramotion/folding-cell-android">folding-cell-android</a> ★2670 - 安卓FoldingCell </li><li><a href="https://github.com/rubensousa/ViewPagerCards">ViewPagerCards</a> ★2297 - 视图页卡片 </li><li><a href="https://github.com/huazhiyuan2008/RecyclerViewCardGallery">RecyclerViewCardGallery</a> ★1443 - RecyclerView实现Card Gallery效果 </li><li><a href="https://github.com/kikoso/Swipeable-Cards">Swipeable-Cards</a> ★1375 - 提供类似Tinder卡片效果 </li><li><a href="https://github.com/flschweiger/SwipeStack">SwipeStack</a> ★1142 - 安卓纸质视图栈 </li><li><a href="https://github.com/xiepeijie/SwipeCardView">SwipeCardView</a> ★1027 - 基于Diolor的Swipecards控件改进实现 </li><li><a href="https://github.com/loopeer/CardStackView">CardStackView</a> ★962 - 以三种动画效果像卡片一样展示内容 </li><li><a href="https://github.com/jeasonlzy/NineGridView">NineGridView</a> ★886 - 展示图片的九宫格控件 </li><li><a href="https://github.com/BakerJQ/Android-InfiniteCards">Android-InfiniteCards</a> ★669 - 可自定义动效的卡片切换视图 </li><li><a href="https://github.com/mxn21/SlidingCard">SlidingCard</a> ★623 - 画廊效果的幻灯片卡片 </li><li><a href="https://github.com/ldoublem/GiftCard">GiftCard</a> ★580 - Android漂亮的礼物卡片 </li><li><a href="https://github.com/wenchaojiang/AndroidSwipeableCardStack">AndroidSwipeableCardStack</a> ★563 - 流畅的纸质卡片组件 </li><li><a href="https://github.com/lawloretienne/TinderStack">TinderStack</a> ★536 - 一叠类似Tinder的卡片 </li><li><a href="https://github.com/huxq17/SwipeCardsView">SwipeCardsView</a> ★370 - Android高仿秒拍热榜的卡片滑动和左右飞出效果 </li><li><a href="https://github.com/vivian8725118/CardView">CardView</a> ★220 - 类似小票效果的卡片列表 </li><li><a href="https://github.com/yuqirong/CardSwipeLayout">CardSwipeLayout</a> ★199 - RecyclerView卡片滑动布局 </li><li><a href="https://github.com/wensefu/StackCardsView">StackCardsView</a> ★50 - 堆叠滑动控件 </li><li><a href="https://github.com/czy1121/turncardlistview">turncardlistview</a> ★33 - 上下翻页的卡片列表 </li><li><a href="https://github.com/yuyuyu123/SwipeCardsRecyclerView">SwipeCardsRecyclerView</a> ★22 - 基于RecyclerView的Android组件</li></ul><h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><ul><li><a href="https://github.com/Taishi-Y/InstagramLikeColorTransitionAndroid">InstagramLikeColorTransitionAndroid</a> ★367 - 创建类似渐变颜色过渡的Instagram </li><li><a href="https://github.com/skydoves/ColorPickerView">ColorPickerView</a> ★290 - 从图片中获取颜色 </li><li><a href="https://github.com/zzhoujay/MaterialDesignColor">MaterialDesignColor</a> ★281 - 谷歌官方MaterialDesign颜色代码 </li><li><a href="https://github.com/kizitonwose/colorpreference">colorpreference</a> ★209 - 建立优秀的颜色选择器 </li><li><a href="https://github.com/mathiazhagan01/DrawableColorChange">DrawableColorChange</a> ★85 - drawable颜色修改工具 </li><li><a href="https://github.com/DingMouRen/ColorPicker">ColorPicker</a> ★79 - android取色器 </li><li><a href="https://github.com/bassaer/MaterialDesignColors">MaterialDesignColors</a> ★55 - 提供MD风格的Android库</li></ul><h2 id="Drawable"><a href="#Drawable" class="headerlink" title="Drawable"></a>Drawable</h2><ul><li><a href="https://github.com/nekocode/DividerDrawable">DividerDrawable</a> ★376 - 在存在的View上布局和画分割线 </li><li><a href="https://github.com/maoruibin/OneDrawable">OneDrawable</a> ★215 - 为View设置具有按下效果的背景 </li><li><a href="https://github.com/yuanwenbing/SelectorDrawable">SelectorDrawable</a> ★26 - 为按钮设置selector</li></ul><h2 id="Spinner"><a href="#Spinner" class="headerlink" title="Spinner"></a>Spinner</h2><ul><li><a href="https://github.com/arcadefire/nice-spinner">nice-spinner</a> ★1015 - Android spinner的重新实现 </li><li><a href="https://github.com/Lesilva/BetterSpinner">BetterSpinner</a> ★544 - 好用的Spinner </li><li><a href="https://github.com/Jasonchenlijian/MemorySpinner">MemorySpinner</a> ★129 - 可以记住历史选项的spinner</li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul><li><a href="https://github.com/google/flexbox-layout">flexbox-layout</a> ★8115 - Android盒式布局功能库 </li><li><a href="https://github.com/hongyangAndroid/AndroidAutoLayout">AndroidAutoLayout</a> ★5164 - Android屏幕适配方案 </li><li><a href="https://github.com/alibaba/vlayout">vlayout</a> ★4665 - 布局方案和布局间的组件复用 </li><li><a href="https://github.com/hongyangAndroid/FlowLayout">FlowLayout</a> ★2390 - Android流式布局 </li><li><a href="https://github.com/florent37/DiagonalLayout">DiagonalLayout</a> ★1860 - MD风格的新的样式和方法 </li><li><a href="https://github.com/Cleveroad/FanLayoutManager">FanLayoutManager</a> ★1477 - 扇形水平列表视图 </li><li><a href="https://github.com/henrytao-me/smooth-app-bar-layout">smooth-app-bar-layout</a> ★1434 - 视图布局 </li><li><a href="https://github.com/mmin18/FlexLayout">FlexLayout</a> ★1377 - 强大的Android布局视图 </li><li><a href="https://github.com/mcxtzhang/FlowLayoutManager">FlowLayoutManager</a> ★1152 - 利用自定义LayoutManager 的一些实战实例 </li><li><a href="https://github.com/facebookincubator/TextLayoutBuilder">TextLayoutBuilder</a> ★1124 - Facebook出品的在Android中轻松实现文字布局 </li><li><a href="https://github.com/AAkira/ExpandableLayout">ExpandableLayout</a> ★1041 - 带有各种动画的扩展布局 </li><li><a href="https://github.com/nex3z/FlowLayout">FlowLayout</a> ★952 - 让子视图自动浮动到下一行 </li><li><a href="https://github.com/florent37/ArcLayout">ArcLayout</a> ★864 - 使用ArcLayout探索新的MD风格的样式和方法 </li><li><a href="https://github.com/cachapa/ExpandableLayout">ExpandableLayout</a> ★818 - 实现动画扩展和子视图折叠 </li><li><a href="https://github.com/hanhailong/FlowTag">FlowTag</a> ★579 - Android流式布局 </li><li><a href="https://github.com/SilenceDut/ExpandableLayout">ExpandableLayout</a> ★414 - 节省空间的可扩展布局 </li><li><a href="https://github.com/Chacojack/HiveLayoutManager">HiveLayoutManager</a> ★373 - 蜂巢布局管理器 </li><li><a href="https://github.com/githubwing/ThreeDLayout">ThreeDLayout</a> ★366 - 让任何view拥有3D效果 </li><li><a href="https://github.com/HuanHaiLiuXin/ILayoutAnimationController">ILayoutAnimationController</a> ★256 - 一行代码搞定布局动画 </li><li><a href="https://github.com/ta893115871/StickyNavLayout">StickyNavLayout</a> ★254 - 悬浮控件 </li><li><a href="https://github.com/Qiang3570/LiveLayout">LiveLayout</a> ★227 - 关于直播布局与礼物特效的Demo </li><li><a href="https://github.com/liuguangqiang/RippleLayout">RippleLayout</a> ★208 - 实现波纹效果的布局 </li><li><a href="https://github.com/rantianhua/AssembleEssay">AssembleEssay</a> ★75 - 自定义LayoutManager实现流动布局 </li><li><a href="https://github.com/PingerOne/FlowLayoutDemo">FlowLayoutDemo</a> ★23 - 自定义View实现流式布局 </li><li><a href="https://github.com/CSnowStack/LikeELMLeftLoad">LikeELMLeftLoad</a> ★17 - 仿饿了么左滑跳转</li></ul><h2 id="模糊效果"><a href="#模糊效果" class="headerlink" title="模糊效果"></a>模糊效果</h2><ul><li><a href="https://github.com/kikoso/android-stackblur">Android StackBlur</a> ★2784 - 图片模糊效果 </li><li><a href="https://github.com/wasabeef/Blurry">Blurry</a> ★2624 - Android简易模糊库 </li><li><a href="https://github.com/wonderkiln/blurkit-android">blurkit-android</a> ★1992 - 类似iOS上的实时模糊效果 </li><li><a href="https://github.com/500px/500px-android-blur">500px-android-blur</a> ★1966 - Android模糊视图 </li><li><a href="https://github.com/Dimezis/BlurView">BlurView</a> ★1652 - Android底层视图动态仿iOS模糊 </li><li><a href="https://github.com/qiujuer/ImageBlurring">ImageBlurring</a> ★1104 - 通过 Java 与 JNI 分别进行图片模糊 </li><li><a href="https://github.com/mmin18/RealtimeBlurView">RealtimeBlurView</a> ★938 - 仿UIVisualEffectView实时模糊覆盖 </li><li><a href="https://github.com/wl9739/BlurredView">BlurredView</a> ★857 - Android图片视图动态模糊 </li><li><a href="https://github.com/Nightonke/BlurLockView">BlurLockView</a> ★857 - 毛玻璃效果的解锁界面 </li><li><a href="https://github.com/patrickfav/Dali">Dali</a> ★787 - Android图像模糊库 </li><li><a href="https://github.com/SmartDengg/RxBlur">RxBlur</a> ★519 - 毛玻璃（高斯模糊）效果 </li><li><a href="https://github.com/Manabu-GT/EtsyBlur">EtsyBlur</a> ★514 - 在Etsy应用添加仿玻璃模糊效果 </li><li><a href="https://github.com/jrvansuita/GaussianBlur">GaussianBlur</a> ★306 - 对图片应用高斯模糊 </li><li><a href="https://github.com/Hitomis/CrazyShadow">CrazyShadow</a> ★226 - 为 View 添加阴影效果</li></ul><h2 id="TabBar"><a href="#TabBar" class="headerlink" title="TabBar"></a>TabBar</h2><ul><li><a href="https://github.com/thelong1EU/SpaceTabLayout">SpaceTabLayout</a> ★1002 - RelativeLayout的自定义实现方式 </li><li><a href="https://github.com/nshmura/RecyclerTabLayout">RecyclerTabLayout</a> ★883 - 高效TabLayout库 </li><li><a href="https://github.com/huage2580/ZuiMeiTAG">ZuiMeiTAG</a> ★242 - 仿最美应用的底栏 </li><li><a href="https://github.com/jeasonlzy/AlphaIndicatorView">AlphaIndicatorView</a> ★218 - 仿微信底部tab标签</li></ul><h2 id="AppBar"><a href="#AppBar" class="headerlink" title="AppBar"></a>AppBar</h2><ul><li><a href="https://github.com/henrytao-me/smooth-app-bar-layout">smooth-app-bar-layout</a> ★1434 - 视图布局 </li><li><a href="https://github.com/ToDou/appbarlayout-spring-behavior">appbarlayout-spring-behavior</a> ★756 - 实现滚动弹簧效果 </li><li><a href="https://github.com/SpikeKing/TestAppBar">TestAppBar</a> ★272 - AppBar动画效果 </li><li><a href="https://github.com/zoonooz/simple-view-behavior">simple-view-behavior</a> ★255 - 简单视图行为</li></ul><h2 id="选择器-Picker"><a href="#选择器-Picker" class="headerlink" title="选择器(Picker)"></a>选择器(Picker)</h2><ul><li><a href="https://github.com/saiwu-bigkoo/Android-PickerView">Android-PickerView</a> ★4321 - 精仿iOS的PickerView控件 </li><li><a href="https://github.com/code-troopers/android-betterpickers">android-betterpickers</a> ★2488 - 选择器DialogFragments库 </li><li><a href="https://github.com/gzu-liyujiang/AndroidPicker">AndroidPicker</a> ★2207 - 安卓选择器类库 </li><li><a href="https://github.com/vikramkakkar/SublimePicker">SublimePicker</a> ★1795 - 提供选择器的自定义视图 </li><li><a href="https://github.com/DroidNinja/Android-FilePicker">Android-FilePicker</a> ★1103 - 灵活选择图片和视频的文件选择器 </li><li><a href="https://github.com/JZXiang/TimePickerDialog">TimePickerDialog</a> ★1031 - Android时间选择器 </li><li><a href="https://github.com/zaaach/CityPicker">CityPicker</a> ★955 - 仿美团等选择城市列表demo </li><li><a href="https://github.com/philliphsu/BottomSheetPickers">BottomSheetPickers</a> ★843 - ndroid的新的数据和时间选择器库 </li><li><a href="https://github.com/brucetoo/PickView">PickView</a> ★814 - 选择日期或者省份的辅助库 </li><li><a href="https://github.com/fishwjy/MultiType-FilePicker">MultiType-FilePicker</a> ★769 - 轻量级Android文件选择库 </li><li><a href="https://github.com/Carbs0126/NumberPickerView">NumberPickerView</a> ★652 - 灵活的安卓NumberPicker组件 </li><li><a href="https://github.com/ai212983/android-spinnerwheel">android-spinnerwheel</a> ★627 - 安卓轮式旋转部件 </li><li><a href="https://github.com/ImKarl/CharacterPickerView">CharacterPickerView</a> ★626 - 仿iOS的PickerView控件 </li><li><a href="https://github.com/GoodieBag/CarouselPicker">CarouselPicker</a> ★475 - 轮播图选择器 </li><li><a href="https://github.com/addappcn/android-pickers">android-pickers</a> ★303 - 安卓选择器类库 </li><li><a href="https://github.com/GoodieBag/HorizontalPicker">HorizontalPicker</a> ★300 - 支持文本和图标的水平选择器 </li><li><a href="https://github.com/florent37/SingleDateAndTimePicker">SingleDateAndTimePicker</a> ★294 - 在一个部件内选择一个数据和一个时间 </li><li><a href="https://github.com/aliab/Two-Step-Picker-Dialog">Two-Step-Picker-Dialog</a> ★241 - 两步选择器对话框 </li><li><a href="https://github.com/huzenan/EasyPickerView">EasyPickerView</a> ★194 - Android轻量级PickerView </li><li><a href="https://github.com/leonHua/LFilePicker">LFilePicker</a> ★178 - 轻量级的文件选择器 </li><li><a href="https://github.com/StephaneBg/SimpleNumberPicker">SimpleNumberPicker</a> ★157 - 十进制和十六进制选择器视图 </li><li><a href="https://github.com/adityagohad/HorizontalPicker">HorizontalPicker</a> ★131 - 一个简单的自定义的和容易使用的的picker </li><li><a href="https://github.com/myinnos/AwesomeImagePicker">AwesomeImagePicker</a> ★123 - 使用精致的接口选择images和gifs </li><li><a href="https://github.com/codbking/PickTime">PickTime</a> ★118 - 日期选择控件 </li><li><a href="https://github.com/jrvansuita/PickImage">PickImage</a> ★95 - 带有Camera和Gallery选项的DialogFragment </li><li><a href="https://github.com/polok/ClickNumberPicker">ClickNumberPicker</a> ★79 - 从给定范围内使用点击按钮或者触摸选定一个值 </li><li><a href="https://github.com/Airsaid/Android-PickerView-Library">Android-PickerView-Library</a> ★78 - 高仿 IOS PickerView 控件的库 </li><li><a href="https://github.com/dunwen/JDSelector">JDSelector</a> ★75 - 仿京东的地址多级选择器 </li><li><a href="https://github.com/BorealisAgency/NumberPicker">NumberPicker</a> ★41 - Android数字选择器视图 </li><li><a href="https://github.com/limxing/CityPickerWebView">CityPickerWebView</a> ★38 - JS实现的省市县三级联动 </li><li><a href="https://github.com/yudu233/PhotoPicker">PhotoPicker</a> ★24 - Android 照片选择器 </li><li><a href="https://github.com/yuruizhe/CityPicker">CityPicker</a> ★20 - 一个仿大众点评的城市快速选择器</li></ul><h2 id="跑马灯"><a href="#跑马灯" class="headerlink" title="跑马灯"></a>跑马灯</h2><ul><li><a href="https://github.com/sfsheng0322/MarqueeView">MarqueeView</a> ★1635 - 垂直翻页公告 </li><li><a href="https://github.com/gongwen/MarqueeViewDemo">MarqueeViewDemo</a> ★951 - 跑马灯View </li><li><a href="https://github.com/oubowu/MarqueeLayoutLibrary">MarqueeLayoutLibrary</a> ★395 - 支持四个方向循环滚动的自定义控件 </li><li><a href="https://github.com/czy1121/noticeview">noticeview</a> ★257 - 滚动播放的公告控件 </li><li><a href="https://github.com/guojunustb/VerticalBannerView">VerticalBannerView</a> ★211 - 安卓自定义控件 </li><li><a href="https://github.com/SumiMakito/AdvancedTextSwitcher">AdvancedTextSwitcher</a> ★199 - 卡片上滚动显示最新评论 </li><li><a href="https://github.com/chenpengfei88/VerticalMarqueeView">VerticalMarqueeView</a> ★13 - 新闻向上不断滚动跑马灯效果</li></ul><h2 id="日历时间"><a href="#日历时间" class="headerlink" title="日历时间"></a>日历时间</h2><ul><li><a href="https://github.com/square/android-times-square">android-times-square</a> ★3764 - 从日历视图选择一个单独日期 </li><li><a href="https://github.com/prolificinteractive/material-calendarview">material-calendarview</a> ★2944 - MD风格的日历视图 </li><li><a href="https://github.com/wdullaer/MaterialDateTimePicker">MaterialDateTimePicker</a> ★2540 - MD风格日期时间选择器 </li><li><a href="https://github.com/alamkanak/Android-Week-View">Android-Week-View</a> ★2390 - 在Android应用中显示日历 </li><li><a href="https://github.com/iwgang/CountdownView">CountdownView</a> ★1327 - 安卓倒计时控件 </li><li><a href="https://github.com/roomorama/Caldroid">Caldroid</a> ★1289 - 以月为单位的日历控件 </li><li><a href="https://github.com/JZXiang/TimePickerDialog">TimePickerDialog</a> ★1031 - Android时间选择器 </li><li><a href="https://github.com/SundeepK/CompactCalendarView">CompactCalendarView</a> ★967 - 简单的日历视图 </li><li><a href="https://github.com/Tibolte/AgendaCalendarView">AgendaCalendarView</a> ★944 - 仿Outloo和Google日历 </li><li><a href="https://github.com/borax12/MaterialDateRangePicker">MaterialDateRangePicker</a> ★860 - 日期选择控件库 </li><li><a href="https://github.com/philliphsu/BottomSheetPickers">BottomSheetPickers</a> ★843 - ndroid的新的数据和时间选择器库 </li><li><a href="https://github.com/Kelin-Hong/CalendarListView">CalendarListView</a> ★766 - 可互动的ListView+CalendarView </li><li><a href="https://github.com/nomanr/WeekCalendar">WeekCalendar</a> ★564 - 提供星期日历的库 </li><li><a href="https://github.com/Mulham-Raee/HorizontalCalendar">HorizontalCalendar</a> ★527 - MD风格的水平日历视图 </li><li><a href="https://github.com/codbking/CalendarExaple">CalendarExaple</a> ★503 - 高仿钉钉和小米的日历控件 </li><li><a href="https://github.com/shichaohui/EasyCalendar">EasyCalendar</a> ★379 - 快捷自定义日历UI </li><li><a href="https://github.com/myjoybar/android-calendar-view">android-calendar-view</a> ★332 - 易扩展的andorid日历控件库 </li><li><a href="https://github.com/memfis19/Cadar">Cadar</a> ★314 - 可以显示事件的日历视图 </li><li><a href="https://github.com/fashare2015/TimerView">TimerView</a> ★314 - 解耦良好的计时控件 </li><li><a href="https://github.com/florent37/SingleDateAndTimePicker">SingleDateAndTimePicker</a> ★294 - 在一个部件内选择一个数据和一个时间 </li><li><a href="https://github.com/henry-newbie/CalendarView">CalendarView</a> ★211 - 高度定制的日期选择器 </li><li><a href="https://github.com/MonkeyMushroom/MiClockView">MiClockView</a> ★194 - 高仿小米时钟 </li><li><a href="https://github.com/jMavarez/MaterialCalendar">MaterialCalendar</a> ★171 - 一个MD风格的日历 </li><li><a href="https://github.com/Carbs0126/GregorianLunarCalendar">GregorianLunarCalendar</a> ★160 - 农历+公历的日期选择模式 </li><li><a href="https://github.com/mahendramahi/CalendarView">CalendarView</a> ★130 - 简单的自定义日历视图 </li><li><a href="https://github.com/huanghaibin-dev/CalendarView">CalendarView</a> ★117 - 优雅且性能高效的日历控件 </li><li><a href="https://github.com/Ajian-studio/GAHonorClock">GAHonorClock</a> ★117 - 时钟动画 </li><li><a href="https://github.com/maning0303/MNCalendar">MNCalendar</a> ★100 - 一个简单的日历控件 </li><li><a href="https://github.com/Kunzisoft/Android-SwitchDateTimePicker">Android-SwitchDateTimePicker</a> ★97 - 日期时间选择器库 </li><li><a href="https://github.com/afinal/week-month-Calendar">week-month-Calendar</a> ★75 - 周月切换的日历 </li><li><a href="https://github.com/k0shk0sh/RetainedDateTimePickers">RetainedDateTimePickers</a> ★68 - 在手机方向改变时保持日期时间选择器 </li><li><a href="https://github.com/Yuncun/WeekViewSwipeable">WeekViewSwipeable</a> ★62 - 以周格式显示数据的Android视图 </li><li><a href="https://github.com/MedAmineTazarki/DateRangePicker">DateRangePicker</a> ★50 - 带数据选择器的Dialogo fragment </li><li><a href="https://github.com/iballan/TimelyView">TimelyView</a> ★42 - 时间动画视图 </li><li><a href="https://github.com/jiefly/NubiaTimer">NubiaTimer</a> ★36 - 高仿Nubia 定时器的自定义view </li><li><a href="https://github.com/wenzhihao123/Android-CalendarView-master">Android-CalendarView-master</a> ★30 - Android自定义日历日期选择控件</li></ul><h2 id="主题样式"><a href="#主题样式" class="headerlink" title="主题样式"></a>主题样式</h2><ul><li><a href="https://github.com/Bilibili/MagicaSakura">MagicaSakura</a> ★1931 - Android多主题库 </li><li><a href="https://github.com/ximsfei/Android-skin-support">Android-skin-support</a> ★1619 - 用心的Android 换肤框架 </li><li><a href="https://github.com/garretyoder/Colorful">Colorful</a> ★1523 - 轻松改变app的配色方案 </li><li><a href="https://github.com/afollestad/aesthetic">aesthetic</a> ★994 - 一个快速容易的即插即用的动态主题引擎 </li><li><a href="https://github.com/52inc/Scoops">Scoops</a> ★686 - 动态改变应用主题 </li><li><a href="https://github.com/zzz40500/ThemeDemo">ThemeDemo</a> ★386 - 日夜间模式切换 </li><li><a href="https://github.com/burgessjp/ThemeSkinning">ThemeSkinning</a> ★273 - Android 主题换肤的开源库 </li><li><a href="https://github.com/fython/Blackbulb">Blackbulb</a> ★158 - MD风格的夜间屏幕Android 应用 </li><li><a href="https://github.com/wutongke/AndroidSkinAnimator">AndroidSkinAnimator</a> ★150 - 仿网易云音乐换肤框架 </li><li><a href="https://github.com/zhangke3016/ChangeMode">ChangeMode</a> ★69 - Android动态切换夜间模式的实现库 </li><li><a href="https://github.com/qqliu10u/QSkinLoader">QSkinLoader</a> ★37 - QSkinLoader换肤框架</li></ul><h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><ul><li><a href="https://github.com/vinc3m1/RoundedImageView">RoundedImageView</a> ★3976 - 支持圆角的快速ImageView。 </li><li><a href="https://github.com/davemorrissey/subsampling-scale-image-view">subsampling-scale-image-view</a> ★2964 - 安卓自定义图片视图 </li><li><a href="https://github.com/gjiazhe/PanoramaImageView">PanoramaImageView</a> ★1526 - 可以随设备旋转自动滚动的imageView </li><li><a href="https://github.com/MostafaGazar/CustomShapeImageView">CustomShapeImageView</a> ★1412 - 自定义使用SVG和填充图的ImageView </li><li><a href="https://github.com/stfalcon-studio/FrescoImageViewer">FrescoImageViewer</a> ★1159 - 简单的自定义全屏图片视图 </li><li><a href="https://github.com/LuckyJayce/LargeImage">LargeImage</a> ★1067 - Android加载大图 </li><li><a href="https://github.com/yingLanNull/ShadowImageView">ShadowImageView</a> ★965 - 更加细腻的阴影效果 </li><li><a href="https://github.com/developer-shivam/Crescento">Crescento</a> ★902 - 图像视图和相关布局的下面添加曲线 </li><li><a href="https://github.com/lopspower/CircularImageView">CircularImageView</a> ★895 - 以简单的方法实现环形ImageView </li><li><a href="https://github.com/laobie/NineGridImageView">NineGridImageView</a> ★876 - 仿微信朋友圈或微博的九宫格图片 </li><li><a href="https://github.com/githubwing/DragPhotoView">DragPhotoView</a> ★871 - 高仿微信可拖拽返回PhotoView </li><li><a href="https://github.com/vikramkakkar/ImageTransition">ImageTransition</a> ★561 - Activity视图过渡 </li><li><a href="https://github.com/jineshfrancs/CaptchaImageView">CaptchaImageView</a> ★504 - 生成验证码图片的自定义ImageView </li><li><a href="https://github.com/kongnanlive/android-combination-avatar">android-combination-avatar</a> ★503 - 模仿QQ讨论组组合头像 </li><li><a href="https://github.com/akshay2211/Oblique">Oblique</a> ★414 - 探索新的显示图片样式 </li><li><a href="https://github.com/DingMouRen/PaletteImageView">PaletteImageView</a> ★404 - 动态提取图片的主要颜色 </li><li><a href="https://github.com/gjiazhe/ScrollParallaxImageView">ScrollParallaxImageView</a> ★402 - 滚动视差效果 </li><li><a href="https://github.com/IntruderShanky/Frisson">Frisson</a> ★320 - 在图片上提供时髦的剪裁 </li><li><a href="https://github.com/developer-shivam/Diagonalify">Diagonalify</a> ★283 - 创建图像视图的对角线切割 </li><li><a href="https://github.com/TangoAgency/avatar-view">avatar-view</a> ★208 - 带有用户名字的第一个字母的图片视图 </li><li><a href="https://github.com/jcodeing/AnchorImageView">AnchorImageView</a> ★197 - Android锚点定位ImageView </li><li><a href="https://github.com/zuoweitan/CircleImageView">CircleImageView</a> ★167 - 环形ImageView </li><li><a href="https://github.com/ihsanbal/Wiv">Wiv</a> ★160 - 窗口图片显示器 </li><li><a href="https://github.com/385841539/IdentityImageView">IdentityImageView</a> ★135 - 带进度条的图片框架 </li><li><a href="https://github.com/suzeyu1992/SImageView">SImageView</a> ★121 - 设置一个网址即可显示图片的控件 </li><li><a href="https://github.com/GitLqr/LQRNineGridImageView">LQRNineGridImageView</a> ★51 - 仿微信群头像九宫格控件 </li><li><a href="https://github.com/HuTianQi/CoolImageView">CoolImageView</a> ★51 - 可以上下移动的imageView </li><li><a href="https://github.com/IntruderShanky/Blaze">Blaze</a> ★41 - 提供移动图像和缩放图像的视图 </li><li><a href="https://github.com/EvilBT/HDImageView">HDImageView</a> ★34 - 加载高清大图支持缩放的控件 </li><li><a href="https://github.com/A-W-C-J/GridImageView">GridImageView</a> ★21 - 根据图片数量自动适配加载 </li><li><a href="https://github.com/gslovemy/RoundImageView">RoundImageView</a> ★13 - Android自定义圆角图片</li></ul><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><ul><li><a href="https://github.com/Tapadoo/Alerter">Alerter</a> ★2816 - 克服Toast和Snackbar的限制 </li><li><a href="https://github.com/wenmingvs/NotifyUtil">NotifyUtil</a> ★947 - 高仿淘宝微信等热门APP通知视图 </li><li><a href="https://github.com/halysongoncalves/Pugnotification">Pugnotification</a> ★691 - 通过一行代码实现通知功能 </li><li><a href="https://github.com/hss01248/NotifyUtil">NotifyUtil</a> ★140 - notification工具类 </li><li><a href="https://github.com/shaileshmamgain5/Carousel-Notification">Carousel-Notification</a> ★78 - 轮播框通知 </li><li><a href="https://github.com/linglongxin24/NotificationUtil">NotificationUtil</a> ★44 - 全新的Android通知栏</li></ul><h2 id="聊天视图"><a href="#聊天视图" class="headerlink" title="聊天视图"></a>聊天视图</h2><ul><li><a href="https://github.com/jpush/aurora-imui">aurora-imui</a> ★1703 - 通用的即时通讯UI 库 </li><li><a href="https://github.com/stfalcon-studio/ChatKit">ChatKit</a> ★1032 - 简化UI开发 </li><li><a href="https://github.com/himanshu-soni/ChatMessageView">ChatMessageView</a> ★559 - 快速创建聊天信息视图 </li><li><a href="https://github.com/bassaer/ChatMessageView">ChatMessageView</a> ★268 - Android聊天UI视图 </li><li><a href="https://github.com/Maxi-Mao/ChatDemo">ChatDemo</a> ★129 - 实现聊天界面</li></ul><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><ul><li><a href="https://github.com/sfsheng0322/StickyHeaderListView">StickyHeaderListView</a> ★1899 - 基于实际需求做出的灵活可定制的UI功能 </li><li><a href="https://github.com/githubwing/ZoomHeader">ZoomHeader</a> ★1797 - 模仿饿了么详情页的例子 </li><li><a href="https://github.com/kmshack/Android-ParallaxHeaderViewPager">Android-ParallaxHeaderViewPager</a> ★1307 - 带标题头的左右滑动 </li><li><a href="https://github.com/ShamylZakariya/StickyHeaders">StickyHeaders</a> ★784 - 安卓RecyclerView的适配器和布局管理器 </li><li><a href="https://github.com/drakeet/RecyclerViewWithHeaderNewPractice">RecyclerViewWithHeaderNewPractice</a> ★537 - 结合HeaderView的RecyclerView新实现 </li><li><a href="https://github.com/ta893115871/StickyNavLayout">StickyNavLayout</a> ★254 - 悬浮控件 </li><li><a href="https://github.com/songhanghang/Smart-HeaderFooter-RecyclerView">Smart-HeaderFooter-RecyclerView</a> ★214 - 将Recyclerview添加HeaderView和FooterView</li></ul><h2 id="引导图-Intro"><a href="#引导图-Intro" class="headerlink" title="引导图(Intro)"></a>引导图(Intro)</h2><ul><li><a href="https://github.com/PaoloRotolo/AppIntro">AppIntro</a> ★6281 - 制作一个很酷的app介绍页 </li><li><a href="https://github.com/amlcurran/ShowcaseView">ShowcaseView</a> ★4788 - 向用户突出app的特定部分 </li><li><a href="https://github.com/Nightonke/WoWoViewPager">WoWoViewPager</a> ★1949 - 优化App介绍&#x2F;引导页面 </li><li><a href="https://github.com/TangoAgency/material-intro-screen">material-intro-screen</a> ★1882 - MD风格的介绍页面 </li><li><a href="https://github.com/binIoter/GuideView">GuideView</a> ★1724 - 创建遮罩式导航页 </li><li><a href="https://github.com/eoinfogarty/Onboarding">Onboarding</a> ★1402 - 以一种漂亮的方式向用户介绍应用 </li><li><a href="https://github.com/Ramotion/paper-onboarding-android">paper-onboarding-android</a> ★1340 - MD风格的onboarding </li><li><a href="https://github.com/riggaroo/MaterialIntroTutorial">MaterialIntroTutorial</a> ★769 - MD风格介绍导航 </li><li><a href="https://github.com/faruktoptas/FancyShowCaseView">FancyShowCaseView</a> ★740 - 易于使用的自定义显示案例视图 </li><li><a href="https://github.com/codemybrainsout/ahoy-onboarding">ahoy-onboarding</a> ★528 - 可自定义背景的引导页面 </li><li><a href="https://github.com/jaydenxiao2016/HighLightGuideView">HighLightGuideView</a> ★359 - 用于 app 新功能高亮引导的库 </li><li><a href="https://github.com/ronaldsmartin/Material-ViewPagerIndicator">Material-ViewPagerIndicator</a> ★338 - 超级简单的页面指示器 </li><li><a href="https://github.com/armcha/Vertical-Intro">Vertical-Intro</a> ★243 - 在你的应用程序中整合material vertical </li><li><a href="https://github.com/yilylong/UserGuideView">UserGuideView</a> ★205 - 用户指引view </li><li><a href="https://github.com/Vexigon/Material-Onboarding">Material-Onboarding</a> ★182 - 轻松实现引导图 </li><li><a href="https://github.com/guangzq/StepDialog">StepDialog</a> ★125 - ofo应用首次注册时的步骤控件 </li><li><a href="https://github.com/ihsanbal/SlidingIntoView">SlidingIntoView</a> ★64 - 简单的滑动介绍视图</li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul><li><a href="https://github.com/bumptech/glide">glide</a> ★15851 - 媒体管理和图片加载框架 </li><li><a href="https://github.com/nostra13/Android-Universal-Image-Loader">Android-Universal-Image-Loader</a> ★15309 - 异步图像加载程序 </li><li><a href="https://github.com/square/picasso">picasso</a> ★13542 - 安卓图片缓存库 </li><li><a href="https://github.com/facebook/fresco">fresco</a> ★12823 - 在Android应用中显示图片 </li><li><a href="https://github.com/chrisbanes/PhotoView">PhotoView</a> ★10275 - 简单可用的放大安卓ImageView实现 </li><li><a href="https://github.com/hdodenhof/CircleImageView">CircleImageView</a> ★7172 - 圆形介绍头像 </li><li><a href="https://github.com/Yalantis/uCrop">uCrop</a> ★5243 - 极限且灵活的图像裁剪体验 </li><li><a href="https://github.com/wasabeef/glide-transformations">glide-transformations</a> ★3803 - 图像转换类库 </li><li><a href="https://github.com/jdamcd/android-crop">android-crop</a> ★3602 - 简单的图片裁剪功能的Android库项目 </li><li><a href="https://github.com/zhihu/Matisse">Matisse</a> ★3015 - Android本地图像选择器 </li><li><a href="https://github.com/crazycodeboy/TakePhoto">TakePhoto</a> ★2896 - Android设备上获取裁剪压缩图片 </li><li><a href="https://github.com/ArthurHub/Android-Image-Cropper">Android-Image-Cropper</a> ★2362 - Android图片裁剪库 </li><li><a href="https://github.com/lovetuzitong/MultiImageSelector">MultiImageSelector</a> ★2325 - 仿微信实现多图选择 </li><li><a href="https://github.com/donglua/PhotoPicker">PhotoPicker</a> ★1905 - 仿Wechat图片选择器 </li><li><a href="https://github.com/Bilibili/boxing">boxing</a> ★1772 - 基于MVP模式的Android多媒体选择器 </li><li><a href="https://github.com/flavioarfaria/KenBurnsView">KenBurnsView</a> ★1761 - 身临其境的动画拖拽 </li><li><a href="https://github.com/jeasonlzy/ImagePicker">ImagePicker</a> ★1696 - Android仿微信UI自定义相册 </li><li><a href="https://github.com/Piasy/BigImageViewer">BigImageViewer</a> ★1664 - 支持平移和缩放的大图像缩放器 </li><li><a href="https://github.com/lyft/scissors">scissors</a> ★1650 - Android图片裁剪库 </li><li><a href="https://github.com/Zomato/AndroidPhotoFilters">AndroidPhotoFilters</a> ★1644 - 快速强大灵活的图片处理器 </li><li><a href="https://github.com/IsseiAoki/SimpleCropView">SimpleCropView</a> ★1640 - Android图片裁剪库 </li><li><a href="https://github.com/LuckSiege/PictureSelector">PictureSelector</a> ★1537 - 多图选择上传 </li><li><a href="https://github.com/sephiroth74/ImageViewZoom">ImageViewZoom</a> ★1489 - 支持超大图片流畅缩放 </li><li><a href="https://github.com/steelkiwi/cropiwa">cropiwa</a> ★1363 - 实现图片剪裁的多配置部件 </li><li><a href="https://github.com/Sunzxyong/Tiny">Tiny</a> ★1307 - 图像压缩框架 </li><li><a href="https://github.com/bm-x/PhotoView">PhotoView</a> ★1296 - 图片浏览缩放控件 </li><li><a href="https://github.com/FinalTeam/RxGalleryFinal">RxGalleryFinal</a> ★1115 - android图片&#x2F;视频文件选择器 </li><li><a href="https://github.com/wingjay/BlurImageView">BlurImageView</a> ★1086 - 逐步加载图像 </li><li><a href="https://github.com/Hitomis/TransferImage">TransferImage</a> ★1051 - 仿qq 点击缩略图后预览高清图 </li><li><a href="https://github.com/TangXiaoLv/TelegramGallery">TelegramGallery</a> ★1044 - 快速高效低耗相册选择器 </li><li><a href="https://github.com/mrwonderman/android-square-progressbar">android-square-progressbar</a> ★976 - 围绕图片的进度条 </li><li><a href="https://github.com/jkwiecien/EasyImage">EasyImage</a> ★912 - 从gallery，相机或者文件中获取图片 </li><li><a href="https://github.com/boycy815/PinchImageView">PinchImageView</a> ★906 - 安卓图片手势控件 </li><li><a href="https://github.com/jeasonlzy/NineGridView">NineGridView</a> ★886 - 展示图片的九宫格控件 </li><li><a href="https://github.com/shaohui10086/AdvancedLuban">AdvancedLuban</a> ★861 - 方便简约的 Android 图片压缩工具库 </li><li><a href="https://github.com/yanzhenjie/album">album</a> ★857 - Android轻量级相册 </li><li><a href="https://github.com/jarlen/PhotoEditDemo">PhotoEditDemo</a> ★828 - 图片处理sdk </li><li><a href="https://github.com/wujingchao/SimpleTagImageView">SimpleTagImageView</a> ★822 - 安卓中带有标签的ImageView </li><li><a href="https://github.com/bingoogolapple/BGAPhotoPicker-Android">BGAPhotoPicker-Android</a> ★771 - Android图片选择 </li><li><a href="https://github.com/chengdazhi/StyleImageView">StyleImageView</a> ★724 - 图片相关视图的风格添加及亮度对比度设置 </li><li><a href="https://github.com/siwangqishiq/ImageEditor-Android">ImageEditor-Android</a> ★688 - 编辑图片 </li><li><a href="https://github.com/martin90s/ImagePicker">ImagePicker</a> ★687 - 图片选择控件 </li><li><a href="https://github.com/coomar2841/image-chooser-library">image-chooser-library</a> ★660 - 以很少的代码捕获图片&#x2F;视频 </li><li><a href="https://github.com/imablanco/Zoomy">Zoomy</a> ★648 - 缩放Android库 </li><li><a href="https://github.com/cesards/CropImageView">CropImageView</a> ★588 - 支持不同类型裁剪的ImageView </li><li><a href="https://github.com/lawloretienne/ImageGallery">ImageGallery</a> ★555 - 用于放置图像数组的gallery </li><li><a href="https://github.com/smuyyh/ImageSelector">ImageSelector</a> ★554 - Android图片选择器 </li><li><a href="https://github.com/hpfs0/DragScaleCircleView">DragScaleCircleView</a> ★485 - 能够拖拽和缩放及裁剪图片的环形窗口 </li><li><a href="https://github.com/wqandroid/wqgallery">wqgallery</a> ★387 - 微信样式相册选择器 </li><li><a href="https://github.com/Carbs0126/AvatarImageView">AvatarImageView</a> ★376 - 电话本联系人头像 </li><li><a href="https://github.com/MartinRGB/RapidInterpolator">RapidInterpolator</a> ★371 - 动态调整interpolator的Java库 </li><li><a href="https://github.com/andremion/Louvre">Louvre</a> ★361 - 自定义图片选择器 </li><li><a href="https://github.com/NodensN/MediaPickerInstagram">MediaPickerInstagram</a> ★344 - 仿Instagram的MediaPicker </li><li><a href="https://github.com/liuguangqiang/IPicker">IPicker</a> ★304 - Material Design 风格的图片选择器 </li><li><a href="https://github.com/imuhao/RxPicker">RxPicker</a> ★296 - 基于RxJava的Android图片选择器. </li><li><a href="https://github.com/yasharpm/InstaCropper">InstaCropper</a> ★294 - 仿Instagram图片裁剪 </li><li><a href="https://github.com/Werb/PickPhotoSample">PickPhotoSample</a> ★277 - 帮助你选择图片的库 </li><li><a href="https://github.com/sangcomz/FishBun">FishBun</a> ★273 - Android图片选择器 </li><li><a href="https://github.com/jeanboydev/Android-BitherCompress">Android-BitherCompress</a> ★272 - Android图片压缩目前最优解决方案 </li><li><a href="https://github.com/xyzxqs/XLowPoly">XLowPoly</a> ★242 - low poly图片的安卓实现 </li><li><a href="https://github.com/lijunguan/AlbumSelector">AlbumSelector</a> ★222 - 图片选择库 </li><li><a href="https://github.com/fengyongge/imagepickerdemo">imagepickerdemo</a> ★216 - 图片选择器 </li><li><a href="https://github.com/dreamlivemeng/HotImg">HotImg</a> ★211 - 图片不规则区域点击事件处理 </li><li><a href="https://github.com/YancyYe/GalleryPick">GalleryPick</a> ★207 - Android 自定义相册 </li><li><a href="https://github.com/newtonker/JigsawDemo">JigsawDemo</a> ★206 - Android的拼图Demo </li><li><a href="https://github.com/w4lle/PullDownView">PullDownView</a> ★198 - 下拉展示大图 </li><li><a href="https://github.com/lopei/collageview">collageview</a> ★181 - 创建简单照片拼贴 </li><li><a href="https://github.com/CarGuo/FrescoUtils">FrescoUtils</a> ★147 - 图片处理 </li><li><a href="https://github.com/ekimual/croperino">croperino</a> ★146 - 简单的图像裁剪工具 </li><li><a href="https://github.com/Jhuster/ImageCropper">ImageCropper</a> ★143 - 图片裁剪库 </li><li><a href="https://github.com/HomHomLin/FrescoImageView">FrescoImageView</a> ★141 - Android平台的图像控件 </li><li><a href="https://github.com/laomengzhu/MutiPhotoChoser">MutiPhotoChoser</a> ★139 - 支持多选的图片选择器 </li><li><a href="https://github.com/esafirm/android-image-picker">android-image-picker</a> ★112 - 选择图像的简单的库 </li><li><a href="https://github.com/soulrelay/ImageLoaderUtil">ImageLoaderUtil</a> ★96 - ImageLoaderUtil实现的图集功能 </li><li><a href="https://github.com/libin7278/ImageLoader">ImageLoader</a> ★90 - 基于Glide的二次封装 </li><li><a href="https://github.com/nshmura/SnappyImageViewer">SnappyImageViewer</a> ★80 - 安卓图片视图 </li><li><a href="https://github.com/charbgr/litho-picasso">litho-picasso</a> ★79 - 仿Picasso的图片组件兼容 </li><li><a href="https://github.com/hss01248/ImageLoader">ImageLoader</a> ★74 - 图片加载框架的api封装 </li><li><a href="https://github.com/hss01248/PicCrop">PicCrop</a> ★68 - 对ucrop的封装工具类 </li><li><a href="https://github.com/okaybroda/ImageZoom">ImageZoom</a> ★52 - 仿Instagram的视图缩放功能 </li><li><a href="https://github.com/Tofira/ImagePickerWithCrop">ImagePickerWithCrop</a> ★51 - 指定选择图片的库 </li><li><a href="https://github.com/vansikrishna/Multimager">Multimager</a> ★49 - 多图片选择器和多图片捕获 </li><li><a href="https://github.com/Mr-wangyong/ImageFrame">ImageFrame</a> ★48 - 高效省内存的播放序列帧控件 </li><li><a href="https://github.com/GitLqr/LQRImagePicker">LQRImagePicker</a> ★42 - 完全仿微信的图片选择 </li><li><a href="https://github.com/Idtk/IKNinePhotoView">IKNinePhotoView</a> ★42 - 开源的Android九宫格控件 </li><li><a href="https://github.com/huzhenjie/ImageSelector">ImageSelector</a> ★33 - 支持多图选择和图片预览的图片选择器 </li><li><a href="https://github.com/LuckSiege/PictureSelectorLight">PictureSelectorLight</a> ★26 - 多图选择器 </li><li><a href="https://github.com/chengzichen/KrGallery">KrGallery</a> ★26 - 图片处理库 </li><li><a href="https://github.com/AlexZhuo/AlxPicassoProgress">AlxPicassoProgress</a> ★26 - 图片下载进度实时显示 </li><li><a href="https://github.com/yangzhidan/ImageEditor">ImageEditor</a> ★16 - 仿QQ图片编辑器</li></ul><h2 id="徽章-Badge"><a href="#徽章-Badge" class="headerlink" title="徽章(Badge)"></a>徽章(Badge)</h2><ul><li><a href="https://github.com/bingoogolapple/BGABadgeView-Android">BGABadgeView-Android</a> ★1680 - Android 徽章控件 </li><li><a href="https://github.com/qstumn/BadgeView">BadgeView</a> ★1375 - 自由定制的BadgeView </li><li><a href="https://github.com/mikepenz/Android-ActionItemBadge">Android-ActionItemBadge</a> ★1094 - 为ActionItem添加标识 </li><li><a href="https://github.com/matrixxun/MaterialBadgeTextView">MaterialBadgeTextView</a> ★891 - 展示新的信息标识和新的特色标识 </li><li><a href="https://github.com/volders/Badger">Badger</a> ★722 - 添加徽章 </li><li><a href="https://github.com/nekocode/Badge">Badge</a> ★640 - 一系列徽章图片 </li><li><a href="https://github.com/AlexLiuSheng/BadgeView">BadgeView</a> ★473 - 基于Android的BadeView </li><li><a href="https://github.com/czy1121/badgebutton">badgebutton</a> ★347 - 带有徽标(数字，小红点)的按钮 </li><li><a href="https://github.com/nex3z/NotificationBadge">NotificationBadge</a> ★84 - 带有动画的通知标记 </li><li><a href="https://github.com/hcs-xph/BadgeRadioButton">BadgeRadioButton</a> ★25 - 仿QQ底部Tab切换RadioButton </li><li><a href="https://github.com/chendongde310/SuperBadge">SuperBadge</a> ★19 - 消息红点计数解决方案</li></ul><h2 id="RatingView"><a href="#RatingView" class="headerlink" title="RatingView"></a>RatingView</h2><ul><li><a href="https://github.com/DreaminginCodeZH/MaterialRatingBar">MaterialRatingBar</a> ★830 - 性能更好的MD风格的RatingBar </li><li><a href="https://github.com/FlyingPumba/SimpleRatingBar">SimpleRatingBar</a> ★639 - 简单但功能强大的RatingBar </li><li><a href="https://github.com/sujithkanna/SmileyRating">SmileyRating</a> ★638 - Android简单的评级栏 </li><li><a href="https://github.com/xiaopansky/SpiderWebScoreView">SpiderWebScoreView</a> ★574 - 蛛网评分控件 </li><li><a href="https://github.com/ome450901/SimpleRatingBar">SimpleRatingBar</a> ★370 - 一个简单的自定义动画的评分组件 </li><li><a href="https://github.com/xiprox/SimpleRatingView">SimpleRatingView</a> ★167 - Android的评价切换 </li><li><a href="https://github.com/AllenCoder/AndroidCustomView">AndroidCustomView</a> ★127 - 简单的投票排名对比图 </li><li><a href="https://github.com/iamhabib/rating-request">rating-request</a> ★24 - 简单的Android对话框</li></ul><h2 id="滚动效果-Scroll"><a href="#滚动效果-Scroll" class="headerlink" title="滚动效果(Scroll)"></a>滚动效果(Scroll)</h2><ul><li><a href="https://github.com/ksoichiro/Android-ObservableScrollView">Android-ObservableScrollView</a> ★7579 - 观察滚动事件和滚动视图的Android库 </li><li><a href="https://github.com/Q42/AndroidScrollingImageView">AndroidScrollingImageView</a> ★1208 - 安卓视差动画效果 </li><li><a href="https://github.com/noties/Scrollable">Scrollable</a> ★892 - 封装实现滚动条的滚动逻辑 </li><li><a href="https://github.com/satorufujiwara/material-scrolling">material-scrolling</a> ★580 - MD风格的滚动效果安卓库 </li><li><a href="https://github.com/turing-tech/MaterialScrollBar">MaterialScrollBar</a> ★568 - 为MD5.1之前的版本带来MD5.1的滚动条 </li><li><a href="https://github.com/yingLanNull/ScrollLayout">ScrollLayout</a> ★215 - 场景抽屉拖拽效果 </li><li><a href="https://github.com/LuckyJayce/HVScrollView">HVScrollView</a> ★46 - 配置水平和垂直滚动的HVScrollView</li></ul><h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><ul><li><a href="https://github.com/vipulasri/Timeline-View">Timeline-View</a> ★1220 - 时间线视图库 </li><li><a href="https://github.com/alorma/TimelineView">TimelineView</a> ★888 - 在应用程序添加时间轴的安卓视图 </li><li><a href="https://github.com/qapqap/TimelineView">TimelineView</a> ★409 - Android自定义时间线视图 </li><li><a href="https://github.com/razerdp/UnderLineLinearLayout">UnderLineLinearLayout</a> ★276 - 一个简单的时间轴实现 </li><li><a href="https://github.com/vienan/TimeLine">TimeLine</a> ★254 - 安卓时间轴</li></ul><h2 id="TreeView"><a href="#TreeView" class="headerlink" title="TreeView"></a>TreeView</h2><ul><li><a href="https://github.com/bmelnychuk/AndroidTreeView">AndroidTreeView</a> ★1692 - 安卓的目录视图 </li><li><a href="https://github.com/TellH/RecyclerTreeView">RecyclerTreeView</a> ★167 - 安卓的TreeView实现 </li><li><a href="https://github.com/shineM/TreeView">TreeView</a> ★102 - 树形结构组件</li></ul><h2 id="SearchView"><a href="#SearchView" class="headerlink" title="SearchView"></a>SearchView</h2><ul><li><a href="https://github.com/MiguelCatalan/MaterialSearchView">MaterialSearchView</a> ★2230 - 以MD风格实现SearchView </li><li><a href="https://github.com/arimorty/floatingsearchview">floatingsearchview</a> ★2074 - 带有搜索建议的浮动搜索栏 </li><li><a href="https://github.com/android-cjj/JJSearchViewAnim">JJSearchViewAnim</a> ★1968 - 炫酷的SearchView搜索动画库 </li><li><a href="https://github.com/lapism/SearchView">SearchView</a> ★1535 - 类似Play Store的SearchView </li><li><a href="https://github.com/renaudcerrato/FloatingSearchView">FloatingSearchView</a> ★1215 - 浮动的搜索视图实现 </li><li><a href="https://github.com/mancj/MaterialSearchBar">MaterialSearchBar</a> ★1014 - 安卓MD风格搜索栏 </li><li><a href="https://github.com/sahildave/Search-View-Layout">Search-View-Layout</a> ★891 - Lollipop+ Dialer和Google Maps的实现 </li><li><a href="https://github.com/Mauker1/MaterialSearchView">MaterialSearchView</a> ★731 - 基于MD风格的Android搜索视图 </li><li><a href="https://github.com/alexstyl/Material-SearchTransition">Material-SearchTransition</a> ★324 - 展示如何过渡到搜索的示例项目 </li><li><a href="https://github.com/cyrilmottier/QueryHighlighter">QueryHighlighter</a> ★254 - 在文本中突出搜索字词 </li><li><a href="https://github.com/mirrajabi/search-dialog">search-dialog</a> ★188 - 快速和自定义的搜索对话框 </li><li><a href="https://github.com/michaelprimez/searchablespinner">searchablespinner</a> ★97 - 搜索器 </li><li><a href="https://github.com/claudiodegio/MsvSearch">MsvSearch</a> ★94 - Material Design风格搜索视图 </li><li><a href="https://github.com/wenwenwen888/SearchDialog">SearchDialog</a> ★89 - 仿bilibili搜索框效果 </li><li><a href="https://github.com/onlynight/LSearchView">LSearchView</a> ★30 - Android L设计搜索视图</li></ul><h2 id="TagView"><a href="#TagView" class="headerlink" title="TagView"></a>TagView</h2><ul><li><a href="https://github.com/BelooS/ChipsLayoutManager">ChipsLayoutManager</a> ★1716 - 自定义RecyclerView布局管理器 </li><li><a href="https://github.com/nex3z/FlowLayout">FlowLayout</a> ★952 - 让子视图自动浮动到下一行 </li><li><a href="https://github.com/wujingchao/SimpleTagImageView">SimpleTagImageView</a> ★822 - 安卓中带有标签的ImageView </li><li><a href="https://github.com/whilu/AndroidTagView">AndroidTagView</a> ★798 - Android TagView库 </li><li><a href="https://github.com/robertlevonyan/materialChipView">materialChipView</a> ★684 - MD风格的Chip视图 </li><li><a href="https://github.com/DavidPizarro/AutoLabelUI">AutoLabelUI</a> ★591 - 将标签并排放置的Android库 </li><li><a href="https://github.com/kaedea/android-tagview">android-tagview</a> ★580 - 云标签控件 </li><li><a href="https://github.com/Frank-Zhu/TriangleRectangleLabelView">TriangleRectangleLabelView</a> ★448 - 标签视图 </li><li><a href="https://github.com/shellljx/TagViewGroup">TagViewGroup</a> ★434 - Android 仿小红书图片标签 </li><li><a href="https://github.com/wenhuaijun/EasyTagDragView">EasyTagDragView</a> ★228 - 仿网易新闻app下拉标签选择菜单 </li><li><a href="https://github.com/yilylong/ChannelTagView">ChannelTagView</a> ★51 - 一个频道管理view </li><li><a href="https://github.com/PingerOne/FlowLayoutDemo">FlowLayoutDemo</a> ★23 - 自定义View实现流式布局 </li><li><a href="https://github.com/paulyung541/LaybelLayout">LaybelLayout</a> ★22 - 标签布局</li></ul><h2 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h2><ul><li><a href="https://github.com/hanks-zyh/HTextView">HTextView</a> ★3129 - 支持自定义字体的TextView动画效果 </li><li><a href="https://github.com/grantland/android-autofittextview">android-autofittextview</a> ★2785 - 自动改变文字大小完美适应边界 </li><li><a href="https://github.com/robinhood/ticker">ticker</a> ★2463 - 显示滚动文本 </li><li><a href="https://github.com/Manabu-GT/ExpandableTextView">ExpandableTextView</a> ★2298 - 展开&#x2F;折叠TextView </li><li><a href="https://github.com/bluejamesbond/TextJustify-Android">TextJustify-Android</a> ★1490 - 文本处理库 </li><li><a href="https://github.com/zzhoujay/RichText">RichText</a> ★1472 - Android富文本解析器 </li><li><a href="https://github.com/lygttpod/SuperTextView">SuperTextView</a> ★1335 - 功能强大的TextView </li><li><a href="https://github.com/HeZaiJin/SlantedTextView">SlantedTextView</a> ★1258 - 倾斜的TextView </li><li><a href="https://github.com/klinker24/Android-TextView-LinkBuilder">Android-TextView-LinkBuilder</a> ★1165 - 创建可点击的链接 </li><li><a href="https://github.com/facebookincubator/TextLayoutBuilder">TextLayoutBuilder</a> ★1124 - Facebook出品的在Android中轻松实现文字布局 </li><li><a href="https://github.com/borjabravo10/ReadMoreTextView">ReadMoreTextView</a> ★1053 - 装饰文本的自定义TextView </li><li><a href="https://github.com/chenBingX/SuperTextView">SuperTextView</a> ★1000 - 提高构建项目的效率 </li><li><a href="https://github.com/splitwise/TokenAutoComplete">TokenAutoComplete</a> ★999 - 安卓Gmail风格的MultiAutoCompleteTextView </li><li><a href="https://github.com/SufficientlySecure/html-textview">html-textview</a> ★929 - 扩展的安卓TextView组件 </li><li><a href="https://github.com/rosenpin/FadingTextView">FadingTextView</a> ★866 - 自动改变其内容的TextView </li><li><a href="https://github.com/sdsmdg/RotatingText">RotatingText</a> ★845 - 周期性文本更新库 </li><li><a href="https://github.com/armcha/AutoLinkTextView">AutoLinkTextView</a> ★835 - 自动检测并处理点击事件 </li><li><a href="https://github.com/johnkil/Android-RobotoTextView">Android-RobotoTextView</a> ★760 - TextView及其直接间接子类的实现 </li><li><a href="https://github.com/AndroidDeveloperLB/AutoFitTextView">AutoFitTextView</a> ★674 - 自动适应字体和行计数的TextView </li><li><a href="https://github.com/quiqueqs/BabushkaText">BabushkaText</a> ★659 - 通过Spannables设置文本样式 </li><li><a href="https://github.com/UFreedom/FloatingText">FloatingText</a> ★626 - 执行漂浮效果动画的控件 </li><li><a href="https://github.com/shts/TriangleLabelView">TriangleLabelView</a> ★587 - 显示三角视图 </li><li><a href="https://github.com/ufo22940268/android-justifiedtextview">android-justifiedtextview</a> ★580 - 基于原生TextView实现合理的textview </li><li><a href="https://github.com/lawloretienne/Trestle">Trestle</a> ★542 - 在TextView上桥接span </li><li><a href="https://github.com/klinker41/android-chips">android-chips</a> ★531 - 基于Google的内部chip库的简易库 </li><li><a href="https://github.com/Chen-Sir/ExpandableTextView">ExpandableTextView</a> ★493 - 展开折叠TextView </li><li><a href="https://github.com/zzhoujay/Markdown">Markdown</a> ★485 - Android原生Markdown解析器 </li><li><a href="https://github.com/jrummyapps/html-builder">html-builder</a> ★435 - 为Android TextView建立有效的HTML </li><li><a href="https://github.com/yanbober/AvatarLabelView">AvatarLabelView</a> ★424 - 可配置的迷你版轻量级 Label 辅助类 </li><li><a href="https://github.com/jaychang0917/SimpleText">SimpleText</a> ★422 - 简化spannable字符串的创建 </li><li><a href="https://github.com/fourlastor/dante">dante</a> ★419 - 文本解析器 </li><li><a href="https://github.com/czy1121/cornerlabelview">cornerlabelview</a> ★396 - 视图角标 </li><li><a href="https://github.com/Bakumon/NumberAnimTextView">NumberAnimTextView</a> ★381 - 数字增加动画的 TextView </li><li><a href="https://github.com/nntuyen/text-decorator">text-decorator</a> ★367 - 轻松装饰TextView </li><li><a href="https://github.com/wangshaolei/UnderLineLinkTextView">UnderLineLinkTextView</a> ★327 - 使关键词带有可点击的下划线TextView </li><li><a href="https://github.com/limedroid/XRichText">XRichText</a> ★279 - 显示Html富文本的TextView </li><li><a href="https://github.com/androidessence/PinchZoomTextView">PinchZoomTextView</a> ★272 - 用手势缩放字体大小 </li><li><a href="https://github.com/Saketme/Better-Link-Movement-Method">Better-Link-Movement-Method</a> ★231 - 在TextView中处理RUL </li><li><a href="https://github.com/zhonghanwen/ColorTextView">ColorTextView</a> ★214 - 用颜色标记一些短语 </li><li><a href="https://github.com/daquexian/FlexibleRichTextView">FlexibleRichTextView</a> ★200 - 自行定义大部分标签 </li><li><a href="https://github.com/AAkira/CompoundIconTextView">CompoundIconTextView</a> ★183 - 带有icon的TextView </li><li><a href="https://github.com/burgessjp/GetWordTextView">GetWordTextView</a> ★168 - 通过点击获得词语 </li><li><a href="https://github.com/Xander1024/MoreTextView">MoreTextView</a> ★129 - TextView的“展开”和“收起” </li><li><a href="https://github.com/AndroidMsky/RandomTextView">RandomTextView</a> ★116 - 滚动显示TextView的数字 </li><li><a href="https://github.com/limedroid/TagEditText">TagEditText</a> ★115 - 显示类似微博中的活动标签 </li><li><a href="https://github.com/xbroak/CharCountTextView">CharCountTextView</a> ★114 - 仿Twitter剩余长度计数器 </li><li><a href="https://github.com/CarGuo/RickText">RickText</a> ★98 - 类似微博的编辑框 </li><li><a href="https://github.com/hootsuite/nachos">nachos</a> ★59 - 输入文本并创建MD风格的chip </li><li><a href="https://github.com/Morxander/Zaman">Zaman</a> ★54 - 将timestamp转化为时间String </li><li><a href="https://github.com/yombunker/SpanEZ">SpanEZ</a> ★39 - 从Spannable API完成提取 </li><li><a href="https://github.com/ithedan/TextViewDrawable">TextViewDrawable</a> ★37 - 仿大众点评的购买须知 </li><li><a href="https://github.com/githubwing/RichTextView">RichTextView</a> ★37 - 富文本textview </li><li><a href="https://github.com/loonggg/TextViewSpanLink">TextViewSpanLink</a> ★30 - TextView上展示超链接 </li><li><a href="https://github.com/zrq1060/SpanBuilder">SpanBuilder</a> ★19 - TextView可以生成的span样式</li></ul><h2 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h2><ul><li><a href="https://github.com/rengwuxian/MaterialEditText">MaterialEditText</a> ★4215 - MD风格的EditText </li><li><a href="https://github.com/vekexasia/android-edittext-validator">Android Form EditText</a> ★1234 - 为edittext带来数据有效性工具 </li><li><a href="https://github.com/florent37/MaterialTextField">MaterialTextField</a> ★1029 - 与众不同的漂亮的浮动可编辑文本框 </li><li><a href="https://github.com/bufferapp/BufferTextInputLayout">BufferTextInputLayout</a> ★818 - 简单的TextImputLayout定制化服务 </li><li><a href="https://github.com/xujinyang/BiuEditText">BiuEditText</a> ★600 - 一个有趣的EditText </li><li><a href="https://github.com/luckyandyzhang/MentionEditText">MentionEditText</a> ★352 - 为提及的字符串添加一些有用的功能特色 </li><li><a href="https://github.com/qinci/AndroidEdit">AndroidEdit</a> ★334 - EditText的撤销和恢复撤销操作 </li><li><a href="https://github.com/andyxialm/TyperEditText">TyperEditText</a> ★314 - 打字机效果 </li><li><a href="https://github.com/FTandJYQ/AnFQNumEditText">AnFQNumEditText</a> ★251 - 自定义EditText实现右下角计数控件 </li><li><a href="https://github.com/wangshaolei/AutoFillEmailEditText">AutoFillEmailEditText</a> ★247 - 自动对EditText添加自定义email </li><li><a href="https://github.com/chaychan/PowerfulViewLibrary">PowerfulViewLibrary</a> ★155 - 输入框功能 </li><li><a href="https://github.com/hanks-zyh/LineHeightEditText">LineHeightEditText</a> ★141 - 修复文本编辑行高和光标效果 </li><li><a href="https://github.com/Morxander/EditCard">EditCard</a> ★78 - 输入信用卡号码的自定义EditText </li><li><a href="https://github.com/rafakob/FloatingEditText">FloatingEditText</a> ★62 - TextInputLayout和TextInputEditText合并成一个类 </li><li><a href="https://github.com/wajahatkarim3/EasyMoney-Widgets">EasyMoney-Widgets</a> ★32 - 支持货币显示的部件 </li><li><a href="https://github.com/aishang5wpj/RichEditText">RichEditText</a> ★24 - 仿微博富文本编辑框 </li><li><a href="https://github.com/vacxe/PhoneMask">PhoneMask</a> ★22 - 添加手机号可读性的EditText </li><li><a href="https://github.com/AndroidMsky/EditTextTools">EditTextTools</a> ★13 - 输入整数小数位数限制自动加逗号</li></ul><h2 id="Sliding"><a href="#Sliding" class="headerlink" title="Sliding"></a>Sliding</h2><ul><li><a href="https://github.com/umano/AndroidSlidingUpPanel">AndroidSlidingUpPanel</a> ★6303 - 通过向上拖动添加额外面板 </li><li><a href="https://github.com/mancj/SlideUp-Android">SlideUp-Android</a> ★1263 - 对任何视图添加边侧效果 </li><li><a href="https://github.com/lawloretienne/DiscreteSlider">DiscreteSlider</a> ★542 - 让用户在指定的刻度线上选择一个值的滑块 </li><li><a href="https://github.com/MAXDeliveryNG/slideview">slideview</a> ★485 - 简单独特的Android滑动按钮 </li><li><a href="https://github.com/HomHomLin/SlidingLayout">SlidingLayout</a> ★384 - 安卓平台View控件 </li><li><a href="https://github.com/dalong982242260/SlidingBall">SlidingBall</a> ★199 - 仿QQ身边的人的效果</li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ul><li><a href="https://github.com/ragunathjawahar/android-saripaar">android-saripaar</a> ★2292 - 基于规则的AndroidUI输入验证库 </li><li><a href="https://github.com/google/hover">hover</a> ★2025 - Android浮动菜单实现 </li><li><a href="https://github.com/fanrunqi/MaterialLogin">MaterialLogin</a> ★1525 - MD风格的登录效果 </li><li><a href="https://github.com/pchmn/MaterialChipsInput">MaterialChipsInput</a> ★1502 - MD风格chip组件的实现 </li><li><a href="https://github.com/Jungerr/GridPasswordView">GridPasswordView</a> ★1262 - Android密码视图 </li><li><a href="https://github.com/AzimoLabs/AndroidKeyboardWatcher">AndroidKeyboardWatcher</a> ★770 - Android可开闭输入键盘 </li><li><a href="https://github.com/thyrlian/AwesomeValidation">AwesomeValidation</a> ★747 - 实现对Android的验证 </li><li><a href="https://github.com/shem8/MaterialLogin">MaterialLogin</a> ★695 - MD风格的登录注册视图 </li><li><a href="https://github.com/glomadrian/material-code-input">material-code-input</a> ★668 - MD样式的编码输入 </li><li><a href="https://github.com/lisawray/passwordview">passwordview</a> ★666 - Android密码视图 </li><li><a href="https://github.com/Rogero0o/PasswordLoadingView">PasswordLoadingView</a> ★537 - 当完成密码时显示一个动画 </li><li><a href="https://github.com/irfaan008/OnePageSigninSignup">OnePageSigninSignup</a> ★447 - 单页面实现注册登录 </li><li><a href="https://github.com/mcxtzhang/SwipeCaptcha">SwipeCaptcha</a> ★403 - Android 平台的滑动验证码 </li><li><a href="https://github.com/Ilhasoft/data-binding-validator">data-binding-validator</a> ★226 - 使验证字段变得简单而快速 </li><li><a href="https://github.com/Hamadakram/Ratifier">Ratifier</a> ★114 - Android表单验证库 </li><li><a href="https://github.com/sgaikar1/ValidationUtilsLibrary">ValidationUtilsLibrary</a> ★92 - 实现表单验证 </li><li><a href="https://github.com/xiong-it/AutoInputAuthCode">AutoInputAuthCode</a> ★41 - 自动填写验证码功能库 </li><li><a href="https://github.com/mukeshsolanki/social-login-helper">social-login-helper</a> ★33 - 将社交登录整合到应用中</li></ul><h2 id="分段控件"><a href="#分段控件" class="headerlink" title="分段控件"></a>分段控件</h2><ul><li><a href="https://github.com/Kaopiz/android-segmented-control">android-segmented-control</a> ★1363 - Android自定义视图 </li><li><a href="https://github.com/7heaven/SHSegmentControl">SHSegmentControl</a> ★471 - 一个简单的SegmentControl部件 </li><li><a href="https://github.com/czy1121/segmentedview">segmentedview</a> ★31 - ios 风格的分段控件 </li><li><a href="https://github.com/danledian/SegmentedControl">SegmentedControl</a> ★16 - 分段选择控件</li></ul><h2 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h2><ul><li><a href="https://github.com/saiwu-bigkoo/Android-ConvenientBanner">Android-ConvenientBanner</a> ★2733 - 通用的广告栏控件 </li><li><a href="https://github.com/youth5201314/banner">banner</a> ★2694 - Android广告图片轮播控件 </li><li><a href="https://github.com/bingoogolapple/BGABanner-Android">BGABanner-Android</a> ★1773 - 引导界面滑动导航 </li><li><a href="https://github.com/xmuSistone/android-pile-layout">android-pile-layout</a> ★1210 - 堆叠滑动控件 </li><li><a href="https://github.com/sayyam/carouselview">carouselview</a> ★608 - Android轮播框库 </li><li><a href="https://github.com/GoodieBag/CarouselPicker">CarouselPicker</a> ★475 - 轮播图选择器 </li><li><a href="https://github.com/hejunlin2013/SuperIndicator">SuperIndicator</a> ★397 - 首页推荐位轮播图 </li><li><a href="https://github.com/xiaohaibin/XBanner">XBanner</a> ★358 - 自定义图片无限轮播的控件 </li><li><a href="https://github.com/dongjunkun/BannerLayout">BannerLayout</a> ★280 - 简洁实用的android广告栏 </li><li><a href="https://github.com/czy1121/bannerview">bannerview</a> ★200 - 横幅广告图片轮播控件 </li><li><a href="https://github.com/pinguo-zhouwei/MZBannerView">MZBannerView</a> ★193 - 仿魅族BannerView </li><li><a href="https://github.com/loonggg/RecyclerViewBanner">RecyclerViewBanner</a> ★159 - 使用RecyclerView做的轮播图 </li><li><a href="https://github.com/dalong982242260/AndroidCarrouselLayout">AndroidCarrouselLayout</a> ★115 - 安卓轮播框布局 </li><li><a href="https://github.com/saeedsh92/Banner-Slider">Banner-Slider</a> ★66 - 在Android应用中便于使用的精致滑块 </li><li><a href="https://github.com/rtugeek/MaterialBanner">MaterialBanner</a> ★58 - MD风格的banner </li><li><a href="https://github.com/IntruderShanky/Flare">Flare</a> ★56 - 简单的循环指示器实现 </li><li><a href="https://github.com/13456961183/RecyclerBanner">RecyclerBanner</a> ★28 - 使用RecyclerView 实现的轮播图 </li><li><a href="https://github.com/genius158/simplebanner">simplebanner</a> ★16 - 基于adapter的轮播图实现</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul><li><a href="https://github.com/gotev/android-upload-service">Android Upload Service</a> ★1218 - 轻松实现后台上传文件 </li><li><a href="https://github.com/arpitkh96/AmazeFileManager">AmazeFileManager</a> ★1209 - 好用的文件管理源代码 </li><li><a href="https://github.com/DroidNinja/Android-FilePicker">Android-FilePicker</a> ★1103 - 灵活选择图片和视频的文件选择器 </li><li><a href="https://github.com/nbsp-team/MaterialFilePicker">MaterialFilePicker</a> ★613 - MD风格文件选择器库 </li><li><a href="https://github.com/smanikandan14/ThinDownloadManager">ThinDownloadManager</a> ★603 - Android下载文件库 </li><li><a href="https://github.com/spacecowboy/NoNonsense-FilePicker">NoNonsense-FilePicker</a> ★539 - 文件选择器库 </li><li><a href="https://github.com/lidong1665/AndroidPDF">AndroidPDF</a> ★62 - PDF文件打开方法 </li><li><a href="https://github.com/adityak368/Android-FileBrowser-FilePicker">Android-FileBrowser-FilePicker</a> ★27 - Android文件浏览器文件选择器</li></ul><h2 id="启动页"><a href="#启动页" class="headerlink" title="启动页"></a>启动页</h2><ul><li><a href="https://github.com/stephentuso/welcome-android">Welcome</a> ★1300 - 安卓欢迎屏效果 </li><li><a href="https://github.com/JeasonWong/Particle">Particle</a> ★1063 - 酷炫动画效果 </li><li><a href="https://github.com/githubwing/WowSplash">WowSplash</a> ★731 - 铁塔融云闪屏页 </li><li><a href="https://github.com/ViksaaSkool/AwesomeSplash">AwesomeSplash</a> ★584 - 令人叫绝的可自定义的飞溅效果屏幕 </li><li><a href="https://github.com/linglongxin24/WelcomeVideoPager">WelcomeVideoPager</a> ★93 - Android酷炫欢迎页播放视频</li></ul><h2 id="MD"><a href="#MD" class="headerlink" title="MD"></a>MD</h2><ul><li><a href="https://github.com/navasmdc/MaterialDesignLibrary">MaterialDesignLibrary</a> ★8213 - Material Design 安卓库 </li><li><a href="https://github.com/traex/RippleEffect">RippleEffect</a> ★4235 - MD风格的点击涟漪效果实现 </li><li><a href="https://github.com/balysv/material-ripple">material-ripple</a> ★1832 - Android视图的纹波效果封装 </li><li><a href="https://github.com/ZieIony/Carbon">Carbon</a> ★1654 - Android的MD风格实现案例 </li><li><a href="https://github.com/jfoenixadmin/JFoenix">JFoenix</a> ★1312 - 使用Java组件实现Google的MD风格 </li><li><a href="https://github.com/harjot-oberai/MaterialShadows">MaterialShadows</a> ★981 - 支持 convex material阴影库 </li><li><a href="https://github.com/AoDevBlue/MaterialValues">MaterialValues</a> ★711 - 将Material Design指南中的所有值在资源中定义 </li><li><a href="https://github.com/ozodrukh/RippleDrawable">RippleDrawable</a> ★498 - Android<ripple>效果端口 </li><li><a href="https://github.com/lurbas/MaterialMasterDetail">MaterialMasterDetail</a> ★242 - 实现Master及Detail模式 </li><li><a href="https://github.com/liuguangqiang/RippleLayout">RippleLayout</a> ★208 - 实现波纹效果的布局 </li><li><a href="https://github.com/takahirom/material-element">material-element</a> ★163 - MD风格动画示例APP </li><li><a href="https://github.com/Cutta/MaterialTransitionAnimation">MaterialTransitionAnimation</a> ★102 - MD风格动画实践</li></ul><h2 id="BottomNavigation"><a href="#BottomNavigation" class="headerlink" title="BottomNavigation"></a>BottomNavigation</h2><ul><li><a href="https://github.com/roughike/BottomBar">BottomBar</a> ★6349 - 自定义视图组件 </li><li><a href="https://github.com/DevLight-Mobile-Agency/NavigationTabBar">NavigationTabBar</a> ★3088 - 带有色彩交互的导航标签栏 </li><li><a href="https://github.com/aurelhubert/ahbottomnavigation">ahbottomnavigation</a> ★2098 - 实现MD风格的按钮导航组件库 </li><li><a href="https://github.com/Ashok-Varma/BottomNavigation">BottomNavigation</a> ★2047 - 从GooglePlay商店获取示例apk </li><li><a href="https://github.com/armcha/Space-Navigation-View">Space-Navigation-View</a> ★1305 - 仿GoogleSpaces的导航完全整合 </li><li><a href="https://github.com/sephiroth74/Material-BottomNavigation">Material-BottomNavigation</a> ★907 - 轻量级底部导航库组件 </li><li><a href="https://github.com/armcha/LuseenBottomNavigation">LuseenBottomNavigation</a> ★851 - 底部导航视图 </li><li><a href="https://github.com/bufferapp/AdaptableBottomNavigation">AdaptableBottomNavigation</a> ★528 - 又一个Bottom Navigation实现 </li><li><a href="https://github.com/yingLanNull/AlphaTabsIndicator">AlphaTabsIndicator</a> ★492 - 高仿微信底部状态栏的轻量级库 </li><li><a href="https://github.com/ittianyu/BottomNavigationViewEx">BottomNavigationViewEx</a> ★437 - 增强BottomNavigationView的安卓库 </li><li><a href="https://github.com/peng8350/JPTabBar">JPTabBar</a> ★412 - 安卓标签栏 </li><li><a href="https://github.com/RoyWallace/BottomNavigationBar">BottomNavigationBar</a> ★257 - MD更新的BottomNavigationbar的开源实现 </li><li><a href="https://github.com/adib2149/BottomNavBar">BottomNavBar</a> ★141 - 轻松添加四个选项卡的导航栏 </li><li><a href="https://github.com/ifmvo/BottomTabView">BottomTabView</a> ★27 - 自定义实现主流底部 Tab 菜单 View</li></ul><h2 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h2><ul><li><a href="https://github.com/GrenderG/Toasty">Toasty</a> ★2703 - 通常的Toast </li><li><a href="https://github.com/JohnPersano/SuperToasts">SuperToasts</a> ★2300 - 增强并创建立Android Toast库 </li><li><a href="https://github.com/yadav-rahul/TastyToast">TastyToast</a> ★1493 - 精致的原生安卓toast </li><li><a href="https://github.com/code-mc/loadtoast">loadtoast</a> ★1254 - Android可自定义toast </li><li><a href="https://github.com/Muddz/StyleableToast">StyleableToast</a> ★1124 - 标准安卓Toast </li><li><a href="https://github.com/Hamadakram/Sneaker">Sneaker</a> ★430 - 自定义alert的轻量级安卓库 </li><li><a href="https://github.com/HuanHaiLiuXin/SweetTips">SweetTips</a> ★59 - 快意灵动的提示库 </li><li><a href="https://github.com/anderson9/LovelyToast">LovelyToast</a> ★36 - 使你的Toast变得灵活而生动</li></ul><h2 id="CreditCard"><a href="#CreditCard" class="headerlink" title="CreditCard"></a>CreditCard</h2><ul><li><a href="https://github.com/HotBitmapGG/CreditSesameRingView">CreditSesameRingView</a> ★939 - 仿Ali芝麻信用新老环形界面 </li><li><a href="https://github.com/sharish/CreditCardView">CreditCardView</a> ★717 - 支付系统信用卡和签账卡视图 </li><li><a href="https://github.com/michelelacorte/SwipeableCard">SwipeableCard</a> ★592 - 仿StreetView磁卡实现 </li><li><a href="https://github.com/vinaygaba/CreditCardView">CreditCardView</a> ★590 - 仿真信用卡UI安卓库 </li><li><a href="https://github.com/dbachelder/CreditCardEntry">CreditCardEntry</a> ★456 - 进行信用卡输入的表单 </li><li><a href="https://github.com/adonixis/android-sumbit-credit-card-flow">android-sumbit-credit-card-flow</a> ★415 - MD风格的信用卡格式实现 </li><li><a href="https://github.com/Morxander/EditCard">EditCard</a> ★78 - 输入信用卡号码的自定义EditText </li><li><a href="https://github.com/geeckmc/CardForm">CardForm</a> ★23 - Android信用卡借记卡互动表单</li></ul><h2 id="ActionSheet"><a href="#ActionSheet" class="headerlink" title="ActionSheet"></a>ActionSheet</h2><ul><li><a href="https://github.com/kingideayou/SlideBottomPanel">SlideBottomPanel</a> ★687 - 实现知乎日报β版底部划出视图 </li><li><a href="https://github.com/baoyongzhang/android-ActionSheet">android-ActionSheet</a> ★664 - 仿照iOS UIActionSheet组件 </li><li><a href="https://github.com/ParkSangGwon/TedBottomPicker">TedBottomPicker</a> ★596 - 简单的图片选择器 </li><li><a href="https://github.com/Kennyc1012/BottomSheet">BottomSheet</a> ★508 - 安卓BottomSheet风格的对话框 </li><li><a href="https://github.com/android-cjj/BottomSheets">BottomSheets</a> ★334 - BottomSheets控件的使用 </li><li><a href="https://github.com/SpikeKing/BottomDialogDemo">BottomDialogDemo</a> ★206 - 使用 DialogFragment 实现底部弹窗布局</li></ul><h2 id="Wave"><a href="#Wave" class="headerlink" title="Wave"></a>Wave</h2><ul><li><a href="https://github.com/race604/WaveLoading">WaveLoading</a> ★1094 - 能够提供波浪动画的Drawable </li><li><a href="https://github.com/john990/WaveView">WaveView</a> ★1010 - Android波浪视图 </li><li><a href="https://github.com/gelitenight/WaveView">WaveView</a> ★957 - 显示波浪效果的视图 </li><li><a href="https://github.com/akshay2211/MusicWave">MusicWave</a> ★283 - 音乐的波纹 </li><li><a href="https://github.com/1139618418/WaveView">WaveView</a> ★108 - 有趣的水波纹效果的界面 </li><li><a href="https://github.com/SouthernBox/RippleLayout">RippleLayout</a> ★61 - 使用 drawBitmapMesh 实现仿真水波纹效果 </li><li><a href="https://github.com/StevenDXC/DxWaveRefresh">DxWaveRefresh</a> ★34 - 波浪效果的下拉刷新 </li><li><a href="https://github.com/Airsaid/DiffuseView">DiffuseView</a> ★30 - 自定义的圆形扩散View </li><li><a href="https://github.com/AndroidMsky/BitmapWaveView">BitmapWaveView</a> ★17 - 在bitmap中显示进度波浪</li></ul><h2 id="Snackbar"><a href="#Snackbar" class="headerlink" title="Snackbar"></a>Snackbar</h2><ul><li><a href="https://github.com/AndreiD/TSnackBar">TSnackBar</a> ★620 - 从顶部显示一个Snackbar </li><li><a href="https://github.com/HuanHaiLiuXin/SnackbarUtils">SnackbarUtils</a> ★379 - Snackbar工具类 </li><li><a href="https://github.com/liuguangqiang/CookieBar">CookieBar</a> ★354 - 屏幕的底部或者顶部显示短信息 </li><li><a href="https://github.com/matecode/Snacky">Snacky</a> ★336 - 在布局中添加Snackbar </li><li><a href="https://github.com/TonnyL/Light">Light</a> ★180 - 更好的Snackbar实现 </li><li><a href="https://github.com/HuanHaiLiuXin/SweetTips">SweetTips</a> ★59 - 快意灵动的提示库</li></ul><h2 id="用户引导"><a href="#用户引导" class="headerlink" title="用户引导"></a>用户引导</h2><ul><li><a href="https://github.com/KeepSafe/TapTargetView">TapTargetView</a> ★2663 - 用户引导功能的实现 </li><li><a href="https://github.com/worker8/TourGuide">TourGuide</a> ★2075 - 应用使用方法指导视图 </li><li><a href="https://github.com/barteksc/AndroidPdfViewer">AndroidPdfViewer</a> ★1978 - Android中显示PDF文档的库 </li><li><a href="https://github.com/Cleveroad/SlidingTutorial-Android">SlidingTutorial-Android</a> ★1894 - Android滑动引导页库 </li><li><a href="https://github.com/hongyangAndroid/Highlight">Highlight</a> ★1854 - app指向性功能高亮的库 </li><li><a href="https://github.com/deano2390/MaterialShowcaseView">MaterialShowcaseView</a> ★1793 - MD主题的ShowcaseView </li><li><a href="https://github.com/iammert/MaterialIntroView">MaterialIntroView</a> ★1732 - 给 Android 应用添加用户引导 </li><li><a href="https://github.com/HeinrichReimer/material-intro">material-intro</a> ★1178 - 简单的MD风格的应用介绍页 </li><li><a href="https://github.com/Popalay/Tutors">Tutors</a> ★75 - 种显示用户界面教程 </li><li><a href="https://github.com/limedroid/XAnimLayout">XAnimLayout</a> ★18 - 轻松实现引导页动画</li></ul><h2 id="Popup"><a href="#Popup" class="headerlink" title="Popup"></a>Popup</h2><ul><li><a href="https://github.com/MasayukiSuda/BubbleLayout">BubbleLayout</a> ★548 - 气泡文字框 </li><li><a href="https://github.com/cpiz/BubbleView">BubbleView</a> ★494 - 带箭头的Android气泡控件&#x2F;容器类 </li><li><a href="https://github.com/pinguo-zhouwei/CustomPopwindow">CustomPopwindow</a> ★243 - PopupWindow 的常用API封装</li></ul><h2 id="滑动返回"><a href="#滑动返回" class="headerlink" title="滑动返回"></a>滑动返回</h2><ul><li><a href="https://github.com/r0adkll/Slidr">Slidr</a> ★1437 - 滑动消失功能 </li><li><a href="https://github.com/liuguangqiang/SwipeBack">SwipeBack</a> ★1095 - 使用手势完成Activity </li><li><a href="https://github.com/Jude95/SwipeBackHelper">SwipeBackHelper</a> ★993 - 仿微信下级activity联动效果 </li><li><a href="https://github.com/XBeats/and_swipeback">and_swipeback</a> ★752 - 利用滑动手势退出当前Activity </li><li><a href="https://github.com/bingoogolapple/BGASwipeBackLayout-Android">BGASwipeBackLayout-Android</a> ★676 - 实现滑动返回布局 </li><li><a href="https://github.com/oubowu/SlideBack">SlideBack</a> ★676 - 高仿微信视差手势滑动返回库 </li><li><a href="https://github.com/sockeqwe/SwipeBack">SwipeBack</a> ★608 - 滑动回退功能 </li><li><a href="https://github.com/YoKeyword/SwipeBackFragment">SwipeBackFragment</a> ★329 - 滑动Fragment或Activity边缘拖动返回 </li><li><a href="https://github.com/zhaozhentao/KugouLayout">KugouLayout</a> ★295 - 模仿酷狗播放器滑动返回的layout </li><li><a href="https://github.com/GeeJoe/EdgeSlidingBack">EdgeSlidingBack</a> ★116 - 一个仿ios边缘右滑返回的库</li></ul><h2 id="TV组件"><a href="#TV组件" class="headerlink" title="TV组件"></a>TV组件</h2><ul><li><a href="https://github.com/hejunlin2013/TVSample">TVSample</a> ★541 - 仿泰捷视频最新TV版 Metro UI </li><li><a href="https://github.com/hejunlin2013/LivePlayback">LivePlayback</a> ★468 - Android TV直播电视节目 </li><li><a href="https://github.com/evilbinary/TvWidget">TvWidget</a> ★293 - tv常用效果控件 </li><li><a href="https://github.com/songwenju/CustomTvRecyclerView">CustomTvRecyclerView</a> ★43 - 针对Android Tv Launcher页的recyclerView </li><li><a href="https://github.com/hejunlin2013/EpisodeListView">EpisodeListView</a> ★24 - Android剧集列表控件</li></ul><h2 id="软键盘"><a href="#软键盘" class="headerlink" title="软键盘"></a>软键盘</h2><ul><li><a href="https://github.com/Jacksgong/JKeyboardPanelSwitch">JKeyboardPanelSwitch</a> ★2111 - 键盘面板冲突及布局闪动处理方案 </li><li><a href="https://github.com/pqpo/InputMethodHolder">InputMethodHolder</a> ★281 - 监听系统软键盘的状态 </li><li><a href="https://github.com/yingLanNull/HideKeyboard">HideKeyboard</a> ★210 - 自动隐藏软键盘 </li><li><a href="https://github.com/GeorgeArgyrakis/FloatingKeyboard">FloatingKeyboard</a> ★89 - 浮动可拖拽的KeyboardView </li><li><a href="https://github.com/AlexMofer/SmoothInputLayout">SmoothInputLayout</a> ★50 - 仿微信式平滑输入面板 </li><li><a href="https://github.com/zybieku/SoftKeyboardUtil">SoftKeyboardUtil</a> ★44 - 一行代码实现Android软键盘和EditText各种交互 </li><li><a href="https://github.com/Hamadakram/KeyHide">KeyHide</a> ★33 - 隐藏Android键盘的简单方法 </li><li><a href="https://github.com/GabrielSamojlo/keyboard-dismisser">keyboard-dismisser</a> ★32 - 点击任何键盘外的部分来取消键盘 </li><li><a href="https://github.com/GitPhoenix/KeyboardView">KeyboardView</a> ★22 - 自定义安全键盘</li></ul><h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><ul><li><a href="https://github.com/laobie/StatusBarUtil">StatusBarUtil</a> ★3326 - 为Android应用设置状态栏 </li><li><a href="https://github.com/niorgai/StatusBarCompat">StatusBarCompat</a> ★1297 - Android 沉浸式状态栏 </li><li><a href="https://github.com/H07000223/FlycoSystemBar">FlycoSystemBar</a> ★857 - SystemBar助手 </li><li><a href="https://github.com/gyf-dev/ImmersionBar">ImmersionBar</a> ★853 - android沉浸式实现</li></ul><h2 id="StepView"><a href="#StepView" class="headerlink" title="StepView"></a>StepView</h2><ul><li><a href="https://github.com/baoyachi/StepView">StepView</a> ★2502 - 步骤指示器 </li><li><a href="https://github.com/badoualy/stepper-indicator">stepper-indicator</a> ★1039 - 引导步骤指示器 </li><li><a href="https://github.com/stepstone-tech/android-material-stepper">android-material-stepper</a> ★974 - 在Android应用中使用MD步进 </li><li><a href="https://github.com/drozdzynski/Steppers">Steppers</a> ★714 - Android步骤视图库 </li><li><a href="https://github.com/VictorAlbertos/BreadcrumbsView">BreadcrumbsView</a> ★565 - 显示给定序列的当前步骤 </li><li><a href="https://github.com/saiwu-bigkoo/Android-SnappingStepper">Android-SnappingStepper</a> ★198 - 漂亮的增减数字控制UI控件 </li><li><a href="https://github.com/zhangxuyang321/StepView">StepView</a> ★170 - 横向版和竖向版步骤视图 </li><li><a href="https://github.com/liuhaizhu/StateProgressView">StateProgressView</a> ★12 - 显示网购物流信息等进度的android view</li></ul><h2 id="表格-Table"><a href="#表格-Table" class="headerlink" title="表格(Table)"></a>表格(Table)</h2><ul><li><a href="https://github.com/zhouchaoyuan/excelPanel">excelPanel</a> ★1305 - 仿Excel表格的RecyclerView </li><li><a href="https://github.com/Kelin-Hong/ScrollablePanel">ScrollablePanel</a> ★1265 - 二维RecyclerView </li><li><a href="https://github.com/Cleveroad/AdaptiveTableLayout">AdaptiveTableLayout</a> ★1144 - 读取和写入CSV文件 </li><li><a href="https://github.com/ISchwarz23/SortableTableView">SortableTableView</a> ★730 - 提供TableView和SortableTableView的安卓库 </li><li><a href="https://github.com/InQBarna/TableFixHeaders">TableFixHeaders</a> ★665 - 带有标题的表格的安卓部件 </li><li><a href="https://github.com/lungerWang/BiDirTable">BiDirTable</a> ★31 - 可双向滑动的表格 </li><li><a href="https://github.com/RmondJone/LockTableView">LockTableView</a> ★19 - Android自定义表格 </li><li><a href="https://github.com/andjdk/HVScrollListView">HVScrollListView</a> ★6 - 实现横纵滑动的列表控件</li></ul><h2 id="滚动视差-Parallex"><a href="#滚动视差-Parallex" class="headerlink" title="滚动视差(Parallex)"></a>滚动视差(Parallex)</h2><ul><li><a href="https://github.com/SchibstedSpain/Parallax-Layer-Layout">Parallax-Layer-Layout</a> ★761 - Android分层视差效果 </li><li><a href="https://github.com/Narfss/ParallaxEverywhere">ParallaxEverywhere</a> ★620 - 视差效果的另类Android视图库 </li><li><a href="https://github.com/gjiazhe/ScrollParallaxImageView">ScrollParallaxImageView</a> ★402 - 滚动视差效果 </li><li><a href="https://github.com/AndroidMsky/linkScrollMsky">linkScrollMsky</a> ★65 - 仿知乎个人主页渐隐嵌套滑动 </li><li><a href="https://github.com/demoNo/ParallaxViewPager">ParallaxViewPager</a> ★63 - 带视差效果的简单ViewPager</li></ul><h2 id="SideBar"><a href="#SideBar" class="headerlink" title="SideBar"></a>SideBar</h2><ul><li><a href="https://github.com/danoz73/RecyclerViewFastScroller">RecyclerViewFastScroller</a> ★887 - 连接到RecyclerView实现快速滚动 </li><li><a href="https://github.com/kongnanlive/SideBar">SideBar</a> ★764 - 全新的快速索引导航栏 </li><li><a href="https://github.com/Solartisan/WaveSideBar">WaveSideBar</a> ★750 - 快速跳跃分组的侧边栏控件 </li><li><a href="https://github.com/gjiazhe/WaveSideBar">WaveSideBar</a> ★700 - 波浪效果索引侧边栏 </li><li><a href="https://github.com/L4Digital/FastScroll">FastScroll</a> ★532 - 类似列表视图的FastScroller </li><li><a href="https://github.com/saiwu-bigkoo/Android-QuickSideBar">Android-QuickSideBar</a> ★399 - 快速查阅对应分组的侧边栏</li></ul><h2 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h2><ul><li><a href="https://github.com/mikepenz/AboutLibraries">AboutLibraries</a> ★1780 - 提供库信息的库 </li><li><a href="https://github.com/medyo/android-about-page">Android About Page</a> ★1257 - 快速创建独一无二的About页面 </li><li><a href="https://github.com/jrvansuita/MaterialAbout">MaterialAbout</a> ★829 - 显示一个MD风格的about页面 </li><li><a href="https://github.com/daniel-stoneuk/material-about-library">material-about-library</a> ★769 - 为app轻松创建关于页面 </li><li><a href="https://github.com/drakeet/about-page">about-page</a> ★95 - 基于MultiType的about页面 </li><li><a href="https://github.com/leonHua/LSettingView">LSettingView</a> ★48 - 设置界面条目封装</li></ul><h2 id="详情页"><a href="#详情页" class="headerlink" title="详情页"></a>详情页</h2><ul><li><a href="https://github.com/cnbleu/SlideDetailsLayout">SlideDetailsLayout</a> ★264 - 上拉加载图文详情功能 </li><li><a href="https://github.com/happylishang/DragScrollDetailsLayout">DragScrollDetailsLayout</a> ★248 - 仿淘宝京东蘑菇街商品详情页 </li><li><a href="https://github.com/hexianqiao3755/GoodsInfoPage">GoodsInfoPage</a> ★206 - 仿京东天猫app的商品详情页 </li><li><a href="https://github.com/RiccardoMoro/LongPressPopup">LongPressPopup</a> ★193 - 长按显示详细信息 </li><li><a href="https://github.com/klinker41/article-android">article-android</a> ★91 - 以可读格式显示web文章 </li><li><a href="https://github.com/iceAnson/NewsDetail">NewsDetail</a> ★66 - 仿今日头条详情页实现 </li><li><a href="https://github.com/chenpengfei88/WdjAppDetail">WdjAppDetail</a> ★45 - 仿豌豆荚应用列表跳转详情界面特效 </li><li><a href="https://github.com/LineChen/TwoPageLayout">TwoPageLayout</a> ★15 - 仿淘宝商品详情页</li></ul><h2 id="FAB"><a href="#FAB" class="headerlink" title="FAB"></a>FAB</h2><ul><li><a href="https://github.com/Clans/FloatingActionButton">FloatingActionButton</a> ★3237 - 浮动动作按钮 </li><li><a href="https://github.com/gowong/material-sheet-fab">material-sheet-fab</a> ★1259 - 实现浮动操作按钮的库 </li><li><a href="https://github.com/JoaquimLey/FabOptions">FabOptions</a> ★820 - 多功能自定义FAB组件 </li><li><a href="https://github.com/andremion/Floating-Navigation-View">Floating-Navigation-View</a> ★806 - 浮动菜单显示锚导航视图 </li><li><a href="https://github.com/bowyer-app/FabTransitionLayout">FabTransitionLayout</a> ★429 - 浮动操作按钮转换 </li><li><a href="https://github.com/devsideal/SquareMenu">SquareMenu</a> ★406 - 可自定义的浮动动作按钮 </li><li><a href="https://github.com/andremion/CounterFab">CounterFab</a> ★374 - 在右上角显示一个计数器的标记</li></ul><h2 id="Indicator"><a href="#Indicator" class="headerlink" title="Indicator"></a>Indicator</h2><ul><li><a href="https://github.com/chenupt/SpringIndicator">SpringIndicator</a> ★1879 - 仿MorningRoutine引导的指示器 </li><li><a href="https://github.com/LyndonChin/AndroidRubberIndicator">AndroidRubberIndicator</a> ★1405 - ViewPager的rubber指示器 </li><li><a href="https://github.com/Taishi-Y/MusicIndicator">MusicIndicator</a> ★268 - Music indicator </li><li><a href="https://github.com/LuckSiege/EasyIndicator">EasyIndicator</a> ★51 - 简单的tab指示器</li></ul><h2 id="分享组件"><a href="#分享组件" class="headerlink" title="分享组件"></a>分享组件</h2><ul><li><a href="https://github.com/shaohui10086/ShareUtil">ShareUtil</a> ★851 - 综合性的分享及登录工具库 </li><li><a href="https://github.com/kayan1990/ShareButton">ShareButton</a> ★452 - 一个具有流畅动画的分享按钮 </li><li><a href="https://github.com/zhangke3016/GeneratePicture">GeneratePicture</a> ★133 - 选取页面内容生成精美分享图片</li></ul><h2 id="升级更新"><a href="#升级更新" class="headerlink" title="升级更新"></a>升级更新</h2><ul><li><a href="https://github.com/czy1121/update">update</a> ★936 - 清晰灵活简单易用的应用更新库 </li><li><a href="https://github.com/yjfnypeu/UpdatePlugin">UpdatePlugin</a> ★698 - 自由定制的app更新组件 </li><li><a href="https://github.com/feicien/android-auto-update">android-auto-update</a> ★544 - 安卓应用自动更新库 </li><li><a href="https://github.com/fccaikai/AppUpdate">AppUpdate</a> ★106 - Android 检查更新库 </li><li><a href="https://github.com/bingoogolapple/BGAUpdate-Android">BGAUpdate-Android</a> ★93 - 应用更新功能 </li><li><a href="https://github.com/qiangxi/CheckUpdateLibrary">CheckUpdateLibrary</a> ★76 - Android专用检查软件更新的库 </li><li><a href="https://github.com/wenwenwen888/BackgroundUpdate">BackgroundUpdate</a> ★36 - 后台更新APP</li></ul><h2 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h2><ul><li><a href="https://github.com/rubensousa/FloatingToolbar">FloatingToolbar</a> ★1143 - FloatingActionButton变形而来的工具栏 </li><li><a href="https://github.com/badoualy/morphy-toolbar">morphy-toolbar</a> ★968 - 切换fragments的精致过渡动画 </li><li><a href="https://github.com/afollestad/material-cab">material-cab</a> ★759 - 自定义的灵活上下文活动栏 </li><li><a href="https://github.com/githubwing/ByeBurger">ByeBurger</a> ★746 - 极其简便的快速实现隐藏标题栏和导航栏 </li><li><a href="https://github.com/adonixis/android-animated-menu-items">android-animated-menu-items</a> ★696 - toolbar中动画菜单条目的示例 </li><li><a href="https://github.com/florent37/AwesomeBar">AwesomeBar</a> ★504 - 优美的侧边工具菜单 </li><li><a href="https://github.com/RameshBhupathi/CollapsingToolbar-With-Webview">CollapsingToolbar-With-Webview</a> ★190 - 带有可折叠toolbar的Webview </li><li><a href="https://github.com/JuL1205/SlideshowToolbar">SlideshowToolbar</a> ★188 - 安卓Slideshow Toolbar </li><li><a href="https://github.com/xiaohaibin/CustomTitileBar">CustomTitileBar</a> ★38 - 通用Android标题栏控件</li></ul><h2 id="Sort-amp-Drag"><a href="#Sort-amp-Drag" class="headerlink" title="Sort&amp;Drag"></a>Sort&amp;Drag</h2><ul><li><a href="https://github.com/askerov/DynamicGrid">DynamicGrid</a> ★805 - Android可拖拽GridView </li><li><a href="https://github.com/ISchwarz23/SortableTableView">SortableTableView</a> ★730 - 提供TableView和SortableTableView的安卓库 </li><li><a href="https://github.com/AlphaBoom/ClassifyView">ClassifyView</a> ★306 - 拖拽合并的RecyclerView </li><li><a href="https://github.com/SwiftyWang/android-drag-square">android-drag-square</a> ★213 - 编辑个人资料及图片可拖拽排序</li></ul><h2 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h2><ul><li><a href="https://github.com/rockerhieu/emojicon">emojicon</a> ★2767 - Android中实现emojis表情 </li><li><a href="https://github.com/Luolc/EmojiRain">EmojiRain</a> ★510 - 小巧的Android掉emoji表情包实现 </li><li><a href="https://github.com/googlesamples/android-EmojiCompat">android-EmojiCompat</a> ★313 - EmojiCompat支持库使用样例</li></ul><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><ul><li><a href="https://github.com/linger1216/labelview">labelview</a> ★1366 - 轻松实现视图之上的标签 </li><li><a href="https://github.com/shts/TriangleLabelView">TriangleLabelView</a> ★587 - 显示三角视图 </li><li><a href="https://github.com/yanbober/AvatarLabelView">AvatarLabelView</a> ★424 - 可配置的迷你版轻量级 Label 辅助类 </li><li><a href="https://github.com/luxiliu/LabelLayout">LabelLayout</a> ★38 - 在另一个视图顶部显示标签文本</li></ul><h2 id="WheelView"><a href="#WheelView" class="headerlink" title="WheelView"></a>WheelView</h2><ul><li><a href="https://github.com/lantouzi/WheelView-Android">WheelView-Android</a> ★875 - 具有轮视图的选择器 </li><li><a href="https://github.com/shchurov/HorizontalWheelView">HorizontalWheelView</a> ★815 - 供用户输入的模型水平轮控制器 </li><li><a href="https://github.com/LukeDeighton/WheelView">WheelView</a> ★705 - 实现一个可旋转的轮盘 </li><li><a href="https://github.com/weidongjian/androidWheelView">androidWheelView</a> ★611 - 仿照iOS的滚轮控件 </li><li><a href="https://github.com/BCsl/CursorWheelLayout">CursorWheelLayout</a> ★497 - 把视图放到一个可旋转轮子中</li></ul><h2 id="PinCode"><a href="#PinCode" class="headerlink" title="PinCode"></a>PinCode</h2><ul><li><a href="https://github.com/aritraroy/PatternLockView">PatternLockView</a> ★1236 - MD风格的Android解锁视图 </li><li><a href="https://github.com/OrangeGangsters/LolliPin">LolliPin</a> ★1159 - MD风格的Android的PIN码库 </li><li><a href="https://github.com/aritraroy/PinLockView">PinLockView</a> ★801 - PIN锁自定义视图 </li><li><a href="https://github.com/GoodieBag/Pinview">Pinview</a> ★414 - Android的Pinview库 </li><li><a href="https://github.com/hanks-zyh/PasscodeView">PasscodeView</a> ★203 - Android查看视图 </li><li><a href="https://github.com/kevalpatel2106/PasscodeView">PasscodeView</a> ★150 - 轻松安全的验证用户 </li><li><a href="https://github.com/huzenan/EasyGestureUnlock">EasyGestureUnlock</a> ★26 - 轻量级手势解锁视图</li></ul><h2 id="CoordinatorLayout"><a href="#CoordinatorLayout" class="headerlink" title="CoordinatorLayout"></a>CoordinatorLayout</h2><ul><li><a href="https://github.com/saulmm/CoordinatorBehaviorExample">CoordinatorBehaviorExample</a> ★2037 - 仿Hangouts4简介动画 </li><li><a href="https://github.com/vitovalov/TabbedCoordinatorLayout">TabbedCoordinatorLayout</a> ★668 - 演示CoordinatorLayout的示例项目 </li><li><a href="https://github.com/googlesamples/android-ConstraintLayoutExamples">android-ConstraintLayoutExamples</a> ★376 - 展示ContraintLayout的特性和使用 </li><li><a href="https://github.com/architjn/SharePanel">SharePanel</a> ★49 - 显示分享按钮面板 </li><li><a href="https://github.com/Liuncoolman/collapsingtoolbarlayout">collapsingtoolbarlayout</a> ★15 - 可滑动悬浮式顶部导航栏</li></ul><h2 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h2><ul><li><a href="https://github.com/linfaxin/TransitionPlayer">TransitionPlayer</a> ★1147 - 控制过渡动画的Android库 </li><li><a href="https://github.com/eschao/android-PageFlip">android-PageFlip</a> ★1126 - 3D风格页面翻页 </li><li><a href="https://github.com/wajahatkarim3/EasyFlipView">EasyFlipView</a> ★663 - 快速而简单的翻转视图 </li><li><a href="https://github.com/wealthfront/magellan">magellan</a> ★350 - 最简单的Android导航库 </li><li><a href="https://github.com/zhangke3016/TranslationCompat">TranslationCompat</a> ★150 - 动画过渡兼容库</li></ul><h2 id="悬浮窗"><a href="#悬浮窗" class="headerlink" title="悬浮窗"></a>悬浮窗</h2><ul><li><a href="https://github.com/liuguangli/FloatUtil">FloatUtil</a> ★157 - 简单的浮窗工具 </li><li><a href="https://github.com/mrrobot97/NetSpeed">NetSpeed</a> ★35 - 悬浮窗网速显示计</li></ul><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><ul><li><a href="https://github.com/onlylemi/MapView">MapView</a> ★493 - 室内地图视图 </li><li><a href="https://github.com/ar-android/DrawRouteMaps">DrawRouteMaps</a> ★161 - 路线地图功能 </li><li><a href="https://github.com/jineshfrancs/ThemedGoogleMap">ThemedGoogleMap</a> ★160 - 创建带自定义主题的GoogleMap的实用类 </li><li><a href="https://github.com/yipianfengye/android-togetherMap">android-togetherMap</a> ★32 - 高德地图的marker聚合功能</li></ul><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ul><li><a href="https://github.com/falnatsheh/MarkdownView">MarkdownView</a> ★725 - Android的Markdown </li><li><a href="https://github.com/tiagohm/MarkdownView">MarkdownView</a> ★578 - 显示Markdown文本的Android库 </li><li><a href="https://github.com/Hitomis/SortRichEditor">SortRichEditor</a> ★285 - 图文混合编辑的富文本编辑器 </li><li><a href="https://github.com/tiagohm/CodeView">CodeView</a> ★130 - Android 代码高亮</li></ul><h2 id="SeekBar"><a href="#SeekBar" class="headerlink" title="SeekBar"></a>SeekBar</h2><ul><li><a href="https://github.com/rubensousa/PreviewSeekBar">PreviewSeekBar</a> ★1915 - 显示视频预览的SeekBar </li><li><a href="https://github.com/woxingxiao/BubbleSeekBar">BubbleSeekBar</a> ★911 - 自定义SeekBar </li><li><a href="https://github.com/Jay-Goo/RangeSeekBar">RangeSeekBar</a> ★121 - 可双向范围选择的SeekBar </li><li><a href="https://github.com/iammert/HueSeekBar">HueSeekBar</a> ★45 - 来自Philips Hue app灵感的SeekBar </li><li><a href="https://github.com/Brioal/RangeSeekBar">RangeSeekBar</a> ★26 - 定值范围选择控件</li></ul><h2 id="DownloadView"><a href="#DownloadView" class="headerlink" title="DownloadView"></a>DownloadView</h2><ul><li><a href="https://github.com/Ajian-studio/GADownloading">GADownloading</a> ★733 - 创意下载进度条 </li><li><a href="https://github.com/dudu90/FreshDownloadView">FreshDownloadView</a> ★618 - 显示一个动画下载进程 </li><li><a href="https://github.com/Metal626/360DownLoadView">360DownLoadView</a> ★30 - 仿360市场下载按钮</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/facebook/Shimmer">Shimmer</a> ★7857 - 闪光效果插件 </li><li><a href="https://github.com/Bearded-Hen/Android-Bootstrap">Android Bootstrap</a> ★5987 - Bootstrap风格安卓主题 </li><li><a href="https://github.com/facebook/litho">litho</a> ★3481 - 创建Android高效UI </li><li><a href="https://github.com/square/flow">flow</a> ★2269 - 命名UI状态 </li><li><a href="https://github.com/codeestX/ENViews">ENViews</a> ★1464 - 华丽丽的动效控件库 </li><li><a href="https://github.com/lawloretienne/QuickReturn">QuickReturn</a> ★1464 - 展示QuickReturn UI 模块 </li><li><a href="https://github.com/UFreedom/FloatingView">FloatingView</a> ★1186 - 使目标视图漂浮在锚视图上 </li><li><a href="https://github.com/andyxialm/SmoothCheckBox">SmoothCheckBox</a> ★1073 - Android带动画的自定义CheckBox </li><li><a href="https://github.com/ogaclejapan/ArcLayout">ArcLayout</a> ★1033 - 非常简单的arc布局库 </li><li><a href="https://github.com/googlesamples/android-PictureInPicture">android-PictureInPicture</a> ★1017 - 演示手持设备画中画模式 </li><li><a href="https://github.com/dongjunkun/CouponView">CouponView</a> ★1009 - 优惠券效果 </li><li><a href="https://github.com/developer-shivam/Crescento">Crescento</a> ★902 - 图像视图和相关布局的下面添加曲线 </li><li><a href="https://github.com/baoyongzhang/BigBang">BigBang</a> ★902 - 仿了Smartisan OS 的 BigBang 功能 </li><li><a href="https://github.com/sharish/ScratchView">ScratchView</a> ★868 - 仿刮刮卡视图 </li><li><a href="https://github.com/michael-rapp/ChromeLikeTabSwitcher">ChromeLikeTabSwitcher</a> ★781 - 标签切换器 </li><li><a href="https://github.com/Yasic/ParticleTextView">ParticleTextView</a> ★774 - 用粒子动画显示文字的 Android 自定义 View </li><li><a href="https://github.com/zagum/Android-ExpandIcon">Android-ExpandIcon</a> ★739 - Google风格上下箭头的简单自定义实现 </li><li><a href="https://github.com/JetradarMobile/android-snowfall">android-snowfall</a> ★728 - 安卓Snowfall View的全自定义实现 </li><li><a href="https://github.com/wuapnjie/StickerView">StickerView</a> ★724 - 贴纸视图的缩放拖动翻转删除 </li><li><a href="https://github.com/Yasic/QQBubbleView">QQBubbleView</a> ★723 - 仿QQ空间直播礼物冒泡特效 </li><li><a href="https://github.com/recruit-lifestyle/FloatingView">FloatingView</a> ★714 - 显示悬浮窗效果 </li><li><a href="https://github.com/FabianTerhorst/Isometric">Isometric</a> ★703 - 安卓图形库 </li><li><a href="https://github.com/kexanie/MathView">MathView</a> ★689 - 在Android应用中显示数学公式 </li><li><a href="https://github.com/mcxtzhang/PathAnimView">PathAnimView</a> ★675 - 用于做Path动画的自定义View </li><li><a href="https://github.com/misakuo/3dTagCloudAndroid">3dTagCloudAndroid</a> ★668 - 将一组View展示为一个3D球形集合 </li><li><a href="https://github.com/IntruderShanky/Squint">Squint</a> ★639 - 提供视图的对角线裁剪 </li><li><a href="https://github.com/Ajian-studio/GABottleLoading">GABottleLoading</a> ★635 - 贝塞尔风暴 </li><li><a href="https://github.com/dynamitechetan/FogView_Library">FogView_Library</a> ★586 - 安卓雾气视图库 </li><li><a href="https://github.com/alibaba/Tangram-Android">Tangram-Android</a> ★585 - 动态化构建Native页面的框架 </li><li><a href="https://github.com/florent37/Depth">Depth</a> ★571 - 在fragments中添加Depth </li><li><a href="https://github.com/dalong982242260/LoopRotarySwitch">LoopRotarySwitch</a> ★561 - 3d旋转切换view </li><li><a href="https://github.com/a-voyager/ScrollNumber">ScrollNumber</a> ★554 - 简单优雅易用的滚动数字控件 </li><li><a href="https://github.com/ByoxCode/DrawView">DrawView</a> ★548 - 提供涂鸦功能 </li><li><a href="https://github.com/tomergoldst/tooltips">tooltips</a> ★532 - 在任何视图上添加工具提示 </li><li><a href="https://github.com/stkent/PolygonDrawingUtil">PolygonDrawingUtil</a> ★527 - 在canvas上绘制规则多边形 </li><li><a href="https://github.com/crosswall/Android-Coverflow">Android-Coverflow</a> ★507 - 漂亮的Android封面浏览 </li><li><a href="https://github.com/kongnanlive/android-combination-avatar">android-combination-avatar</a> ★503 - 模仿QQ讨论组组合头像 </li><li><a href="https://github.com/klinker24/Android-DragDismissActivity">Android-DragDismissActivity</a> ★495 - 滑动取消Activity </li><li><a href="https://github.com/zhengken/LyricViewDemo">LyricViewDemo</a> ★494 - 强大灵活的歌词视图 </li><li><a href="https://github.com/ShogoMizumoto/ZDepthShadow">ZDepthShadow</a> ★487 - MD风格的安卓拉直深入阴影 </li><li><a href="https://github.com/CaMnter/EasyCountDownTextureView">EasyCountDownTextureView</a> ★453 - 使用TextureView轻松实现倒计时 </li><li><a href="https://github.com/barryhappy/TContributionsView">TContributionsView</a> ★436 - 显示类似github贡献度的View </li><li><a href="https://github.com/gjiazhe/LayoutSwitch">LayoutSwitch</a> ★429 - 列表布局与网格布局的切换 </li><li><a href="https://github.com/myinnos/AppIconNameChanger">AppIconNameChanger</a> ★397 - 动态的改变安卓应用Icon和名称 </li><li><a href="https://github.com/RiccardoMoro/FreeDrawView">FreeDrawView</a> ★365 - 一个可以自由涂鸦的视图 </li><li><a href="https://github.com/dolphinwang/ImageCoverFlow">ImageCoverFlow</a> ★340 - 图片封面浏览效果 </li><li><a href="https://github.com/wingjay/WJMagicCurveView">WJMagicCurveView</a> ★307 - 神奇的魔法曲线 </li><li><a href="https://github.com/pcevikogullari/AndroidShortcuts">AndroidShortcuts</a> ★302 - 快捷方式示例app </li><li><a href="https://github.com/Freshman111/VerificationCodeView">VerificationCodeView</a> ★301 - 动态生成验证码 </li><li><a href="https://github.com/team-supercharge/ShimmerLayout">ShimmerLayout</a> ★296 - 高效的闪光效果 </li><li><a href="https://github.com/Lauzy/LBehavior">LBehavior</a> ★290 - 简单实现标题栏导航栏滑动动画 </li><li><a href="https://github.com/vlad1m1r990/Lemniscate">Lemniscate</a> ★290 - 制作别致的进度视图 </li><li><a href="https://github.com/xenione/tab-digit">tab-digit</a> ★279 - 一个Flip Clock 库 </li><li><a href="https://github.com/qinci/EdgeTranslucent">EdgeTranslucent</a> ★278 - 任意View边沿渐变透明 </li><li><a href="https://github.com/DingMouRen/FallingView">FallingView</a> ★252 - 实现碎片飘落效果的控件 </li><li><a href="https://github.com/Yellow5A5/ClearScreenHelper">ClearScreenHelper</a> ★250 - 清屏相关的需求 </li><li><a href="https://github.com/woxingxiao/DashboardView">DashboardView</a> ★247 - 安卓自定义仪表盘View </li><li><a href="https://github.com/smartbetter/GooView">GooView</a> ★245 - 一个自定义粘性控件 </li><li><a href="https://github.com/Hitomis/CrazyShadow">CrazyShadow</a> ★226 - 为 View 添加阴影效果 </li><li><a href="https://github.com/ImmortalZ/jellyball">jellyball</a> ★226 - 高仿 path下拉小球 </li><li><a href="https://github.com/YiiGuxing/CompositionAvatar">CompositionAvatar</a> ★221 - 仿QQ讨论组头像 </li><li><a href="https://github.com/developer-shivam/ChanelView">ChanelView</a> ★202 - 说明手势的简单用例 </li><li><a href="https://github.com/hanbaokun/FloatingViewService">FloatingViewService</a> ★201 - 一个服务开启悬浮球 </li><li><a href="https://github.com/gavinliu/SimpleOneStep">SimpleOneStep</a> ★190 - 仿OneStep </li><li><a href="https://github.com/ChyengJason/ShoppingCart">ShoppingCart</a> ★184 - 仿饿了么购物车效果 </li><li><a href="https://github.com/jcmore2/FreeView">FreeView</a> ★181 - 浮动视图 </li><li><a href="https://github.com/AlexLiuSheng/FloatView">FloatView</a> ★172 - 类似来电秀的效果 </li><li><a href="https://github.com/huzenan/EasyTransition">EasyTransition</a> ★169 - 一个轻量级的共享元素迁移库 </li><li><a href="https://github.com/quiin/UnifiedContactPicker">UnifiedContactPicker</a> ★153 - 统一用户联系人 </li><li><a href="https://github.com/uin3566/DragFooterView">DragFooterView</a> ★144 - 向左拖拽跳转至更多页面 </li><li><a href="https://github.com/HalfStackDeveloper/FloatBall">FloatBall</a> ★144 - 高仿flyme悬浮球 </li><li><a href="https://github.com/hzw1199/AndroidGpsStatus">AndroidGpsStatus</a> ★139 - 显示GPS状态和信号强度 </li><li><a href="https://github.com/AhmadNemati/WindView">WindView</a> ★135 - 显示天气风速和压力状态 </li><li><a href="https://github.com/pavel163/AttributesDispatcher">AttributesDispatcher</a> ★111 - 创建一个自定义视图 </li><li><a href="https://github.com/MindorksOpenSource/SnapHelperExample">SnapHelperExample</a> ★104 - SnapHelper的Android示例 </li><li><a href="https://github.com/zhangxuyang321/XyzInfo">XyzInfo</a> ★92 - 自定义Switch和Ruler控件 </li><li><a href="https://github.com/zhangyuChen1991/MagicLine">MagicLine</a> ★85 - 简单的规律绘制直线构造神奇的视觉效果 </li><li><a href="https://github.com/stewForAni/Lamp">Lamp</a> ★81 - 简单的Android工艺灯控件 </li><li><a href="https://github.com/ImKarl/WaitView">WaitView</a> ★80 - 显示等待加载状态的View </li><li><a href="https://github.com/hugeinc/Vibes">Vibes</a> ★76 - 安卓的径向传播背景 </li><li><a href="https://github.com/liuguangli/VerificationCodeInput">VerificationCodeInput</a> ★72 - 简洁验证码输入框 </li><li><a href="https://github.com/a5533348/PayUI">PayUI</a> ★70 - 支付密码弹出层 </li><li><a href="https://github.com/jeanboydev/Android-RadarView">Android-RadarView</a> ★64 - 仿支付宝芝麻分解读 </li><li><a href="https://github.com/JuniperPhoton/FlipperView">FlipperView</a> ★61 - 使用翻转过渡改变不同状态 </li><li><a href="https://github.com/ruzhan123/HorizontalNumberView">HorizontalNumberView</a> ★61 - 简单的Android滑动缩放视图 </li><li><a href="https://github.com/tdscientist/ShelfView">ShelfView</a> ★59 - 显示书架上的书的自定义视图 </li><li><a href="https://github.com/donglua/GithubContributionsWidget">GithubContributionsWidget</a> ★56 - github贡献的Android部件 </li><li><a href="https://github.com/skydoves/ElasticViews">ElasticViews</a> ★49 - 触摸动画Android视图 </li><li><a href="https://github.com/webianks/EasyFeedback">EasyFeedback</a> ★47 - 收集Android应用程序的反馈 </li><li><a href="https://github.com/hearsilent/PixelSlide">PixelSlide</a> ★47 - 上下的展开箭头扩展示例 </li><li><a href="https://github.com/panacena/RuleView">RuleView</a> ★47 - 自定义刻度尺控件 </li><li><a href="https://github.com/LiuHongtao/PaintView">PaintView</a> ★43 - 在图片上涂鸦 </li><li><a href="https://github.com/GHdeng/NetMonitor">NetMonitor</a> ★43 - 使用广播监听网络变化 </li><li><a href="https://github.com/wobiancao/StickyDemo">StickyDemo</a> ★41 - 三步实现控件悬浮 </li><li><a href="https://github.com/capur16/DigitSpeedView">DigitSpeedView</a> ★39 - 独特的安卓数字测速仪 </li><li><a href="https://github.com/cdflynn/checkview">checkview</a> ★37 - 动画check标记 </li><li><a href="https://github.com/cmfsotelo/FlipLayout">FlipLayout</a> ★36 - 容易的对ViewGroup的子View进行交换 </li><li><a href="https://github.com/JadynAi/Particle">Particle</a> ★33 - 一个android萤火虫飞舞的粒子效果 </li><li><a href="https://github.com/simplepeng/BubbleView">BubbleView</a> ★30 - 模仿QQ水泡拖拽效果 </li><li><a href="https://github.com/WangGanxin/CircleRangeView">CircleRangeView</a> ★29 - 自定义圆形仪表盘View </li><li><a href="https://github.com/ghnor/StatusBarFits">StatusBarFits</a> ★25 - Android状态栏 </li><li><a href="https://github.com/fashare2015/HoverView">HoverView</a> ★23 - 仿知乎的底部抽屉 </li><li><a href="https://github.com/HeartlandSoftware/AndroidHeatMap">AndroidHeatMap</a> ★23 - 易于使用的热点图控件 </li><li><a href="https://github.com/yongming9011/VerificationCodeView">VerificationCodeView</a> ★22 - Android简单的验证码控件 </li><li><a href="https://github.com/msandroid/MultiShapeView">MultiShapeView</a> ★20 - 支持圆角矩形圆形自定义View </li><li><a href="https://github.com/cooldev727/WeekView">WeekView</a> ★18 - 安卓周视图 </li><li><a href="https://github.com/dengzq/LetterView">LetterView</a> ★12 - 选中字母完成单词</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>ui</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android useful doc</title>
    <link href="/2017-07-28-android-useful-doc/"/>
    <url>/2017-07-28-android-useful-doc/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>声明：本文转自作者<a href="https://github.com/Android-Mu">coding小生</a>的github开源项目<a href="https://github.com/Android-Mu/AndroidSourceCodeXS">AndroidSourceCodeXS</a>，仅供自己学习备忘。</p><h3 id="App-系列（高仿、练手等）"><a href="#App-系列（高仿、练手等）" class="headerlink" title="App 系列（高仿、练手等）"></a>App 系列（高仿、练手等）</h3><p><a href="http://mp.weixin.qq.com/s/u8oo7cdb-sqtge4jVw8lbg"><strong>SmartRecom：一款干货满满，助你进阶的 App 项目</strong></a></p><p><a href="http://mp.weixin.qq.com/s/xdFskas_X4FwCqUES-JAjQ"><strong>Android 仿今日头条的开源项目</strong></a></p><p><a href="http://mp.weixin.qq.com/s/jOW40fpAlNGvrOfQe9vJyA"><strong>手把手教你从零开始做一个好看的 APP</strong></a></p><p><a href="http://mp.weixin.qq.com/s/twunvTc8IY9tSoC7kc-SXg"><strong>KeepGank.IO - 又一款开源 Gank.IO 客户端. 欢迎 star</strong></a></p><p><a href="http://mp.weixin.qq.com/s/K6wVgsn4MI0mx2cwKWFPUw"><strong>一个用来巩固 Android 基础的 APP</strong></a></p><p><a href="http://mp.weixin.qq.com/s/8QcXFaBLsgUiSRH2Gy_szQ"><strong>jsoup爬虫简书首页数据做个小Demo</strong></a></p><p><a href="http://mp.weixin.qq.com/s/gMzDv_sCJS6Vzx76liI-Rg"><strong>快毕业了，撸一个小项目(新闻段子客户端)</strong></a></p><p><a href="https://mp.weixin.qq.com/s/0hMV7IMei74LTuUmFQ1Snw"><strong>Android 一款十分简洁、优雅的日记APP</strong></a></p><h3 id="自定义-x2F-仿系列"><a href="#自定义-x2F-仿系列" class="headerlink" title="自定义 &#x2F; 仿系列"></a>自定义 &#x2F; 仿系列</h3><p><a href="http://mp.weixin.qq.com/s/XBM7eYuFl7I8mNCTizKuyA"><strong>仿 Nice 首页图片列表 9 图样式，并实现拖拽效果</strong></a></p><p><a href="http://mp.weixin.qq.com/s/YIYDVyDLeevHRJ0tZfs1_A"><strong>仿简书动态 searchview 的实现，代码就这么多点</strong></a><br><a href="http://mp.weixin.qq.com/s/76yng2hofs0DBaKq55Ufjg"><br><strong>Android 使用 Path 仿支付宝支付成功失败动画</strong></a></p><p><a href="http://mp.weixin.qq.com/s/mgU5M9mR_gZa5K-L92ZjBA"><strong>Android 仿 QQ 侧滑菜单</strong></a></p><p><a href="http://mp.weixin.qq.com/s/dmGzlEYn7fOk1LakiIrEAw"><strong>京东快报轮播公告的实现</strong></a></p><p><a href="http://mp.weixin.qq.com/s/0WSfWzoX9MnUOj79_P7pig"><strong>[Android] 自定义 View 之仿 QQ 讨论组头像</strong></a></p><p><a href="http://mp.weixin.qq.com/s/1YjGkgGKpMSYDdkSu18ZUQ"><strong>一步步教你画股票图,K 线图,高仿雪球股票</strong></a></p><p><a href="http://mp.weixin.qq.com/s/zxSd9AMAItocZJczW4FxDA"><strong>Android 自定义控件(仿天猫搜索框)</strong></a></p><p><a href="http://mp.weixin.qq.com/s/1IYsvApJERkPU-10keJ8-w"><strong>自定义圆环百分占比 view （label 文字支持自动换行和设置显示行数）</strong></a></p><p><a href="http://mp.weixin.qq.com/s/Ii1brow3qiEOxrdCHehImw"><strong>Android 仿 instagram 和微博的头像点击加载动画</strong></a></p><p><a href="http://mp.weixin.qq.com/s/xtw6OjMhn1o4eW8tiHQD5g"><strong>真正的画廊，左右条目可点击居中，左右条目可滑动</strong></a></p><p><a href="http://mp.weixin.qq.com/s/5eZxtu-_O0_hqW2b_prK_g"><strong>从未如此惊艳！你好，SuperTextView</strong></a></p><p><a href="http://mp.weixin.qq.com/s/jwxfcvgnoIFViJ6Bcb8V1w"><strong>Android 撸起袖子，自己封装 DialogFragment</strong></a></p><p><a href="https://mp.weixin.qq.com/s/e7otNLqCSBW9rz4ChLx_cg"><strong>类似 QQ 的文件管理器</strong></a></p><p><a href="http://mp.weixin.qq.com/s/e5cG1soYm7m2KMB2PnTiqw"><strong>Android 模仿微信选择图片</strong></a></p><p><a href="http://mp.weixin.qq.com/s/ZK7BDlK8dE2oRqieGvBXew"><strong>教你手写一个贝塞尔曲线效果的 Loading View</strong></a></p><p><a href="http://mp.weixin.qq.com/s/sSIrHOChrgi6ccFKWm80uQ"><strong>仿简书长按文章生成图片效果</strong></a></p><p><a href="http://mp.weixin.qq.com/s/9AvvuKkiW8tveiEVQ0y5oA"><strong>Android自定义view之属性动画熟悉</strong></a></p><p><a href="http://mp.weixin.qq.com/s/-Up4UwJiS2UQ_hS5yefd4Q"><strong>Android自定义控件之天气视图</strong></a></p><p><a href="http://mp.weixin.qq.com/s/SCaWJFRMI4oVIJLOvGYw7Q"><strong>手把手教你打造RecyclerView滚动特效</strong></a></p><h3 id="框架-x2F-库（封装使用）"><a href="#框架-x2F-库（封装使用）" class="headerlink" title="框架&#x2F;库（封装使用）"></a>框架&#x2F;库（封装使用）</h3><p><a href="http://mp.weixin.qq.com/s/VJHbdNc4HmEvk0LNK8tftg"><strong>一步一步带你认识 MVP+Retrofit+Rxjava 并封装（一）</strong></a></p><p><a href="http://mp.weixin.qq.com/s/7VK9CLvJ-ZMW0dLHs6qJVg"><strong>Android 基于 glide 4.0 封装图片加载库</strong></a></p><p><a href="http://mp.weixin.qq.com/s/r47F32QY9olF6wVAF3d-0Q"><strong>MVP+多线程+断点续传 实现 app 在线升级库 (手把手教你打造自己的 lib)</strong></a></p><p><a href="http://mp.weixin.qq.com/s/Dx7u7sxI-lBSCbokKWUHHg"><strong>教你打造 Android 揭面水波动画库-AnimationHelper</strong></a></p><p><a href="http://mp.weixin.qq.com/s/mbZsvdImJE_RszoK1vMjGg"><strong>【Android】Realm 详解</strong></a></p><p><a href="http://mp.weixin.qq.com/s/JMd8_62yNhN9VCzlt13PZg"><strong>Retrofit2+okhttp3缓存设置</strong></a></p><p><a href="http://mp.weixin.qq.com/s/BYtF_Kzy7OWePJRNpfoHWQ"><strong>阿里巴巴推出超强针对布局方案和布局复用的开源框架（vlayout）</strong></a></p><p><a href="http://mp.weixin.qq.com/s/9WYNEhQ2NpK_dh6fOXeuFQ"><strong>Android 实现一个简单的下载工具</strong></a></p><p><a href="http://mp.weixin.qq.com/s/Q-H30R1jQinbaB3jYowOZQ"><strong>Android架构那些事之第三方库的隔离</strong></a></p><h3 id="求职"><a href="#求职" class="headerlink" title="求职"></a>求职</h3><p><a href="http://mp.weixin.qq.com/s/N8EcP9dV1LWzkQDNRF2YOg"><strong>2017 年 Android 曲折的求职之路</strong></a></p><p><a href="https://mp.weixin.qq.com/s/HjUOj7M9b94w97ROh8T91g"><strong>2017 Android 暑期实习生面试经验谈</strong></a></p><p><a href="http://mp.weixin.qq.com/s/86ejicK5BBo3LYoAEBlhaA"><strong>杭州找 Android 工作的点点滴滴</strong></a></p><p><a href="http://mp.weixin.qq.com/s/wd2vaDa1Pi3DpAXDjbebgA"><strong>那些IT培训出来的Android工程师，希望你面试时涨点记性</strong></a></p><p><a href="http://mp.weixin.qq.com/s/NiRoLfuN4B2PeNLlQpieNw"><strong>为跳槽的你献计献策（Android）</strong></a></p><h3 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h3><p><a href="http://mp.weixin.qq.com/s/GuiP2dmkM9z8rzzxdn3Pww"><strong>瓶颈：没有技术深度的苦恼</strong></a></p><p><a href="http://mp.weixin.qq.com/s/0U733-oOv6HTW-tmhWi4Vw"><strong>良心推荐：总结 Android 开发中必备的代码 Review 清单</strong></a></p><p><a href="https://mp.weixin.qq.com/s/bRKqNu6AntHAooCJg2VZJg"><strong>想编程，是勤奋自学还是去培训班学习？</strong></a></p><p><a href="https://mp.weixin.qq.com/s/TBhccRDmI47e2vl8TcX4SA"><strong>编程之旅，致新入行的朋友</strong></a></p><p><a href="http://mp.weixin.qq.com/s/M6vd26jO4-IccS-DX8k59A"><strong>程序员，你还没有软技能吗？难怪你不幸福</strong></a></p><p><a href="https://mp.weixin.qq.com/s/-O8G1wInED5PhMOo_d6KOg"><strong>2017，你绝对想尝试的新安卓库</strong></a></p><p><a href="http://mp.weixin.qq.com/s/w_NiEJLx0AECepZ8cRhzsg"><strong>[干货]Android 中的 Calendar，听说你有这样的需求</strong></a></p><p><a href="http://mp.weixin.qq.com/s/B_I5Q75Bp1z0am-5wqKeXQ"><strong>变革者——献给所有软件开发自学者</strong></a></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><a href="http://mp.weixin.qq.com/s/mkSJKT7zbzcSlY4GQ_v-9Q"><strong>Android 之 Context 底层原理</strong></a></p><p><a href="http://mp.weixin.qq.com/s/pPrfIq-8yV5CnbIIKprm7Q"><strong>可能是讲解 Binder 机制最好的文章</strong></a></p><p><a href="http://mp.weixin.qq.com/s/vZsqyfL4ss2sMLr_nZLcow"><strong>全栈级别梳理-Android系统启动流程</strong></a></p><p><a href="http://mp.weixin.qq.com/s/eZnhFc-U6QW2bfGz3ppYOA"><strong>浅析HandlerThread</strong></a></p><p><a href="http://mp.weixin.qq.com/s/Xkx4OJ2ed-itqGfzD-538Q"><strong>源码分析之LayoutInflater</strong></a></p><h3 id="职场"><a href="#职场" class="headerlink" title="职场"></a>职场</h3><p><a href="http://mp.weixin.qq.com/s/u9xrlRvSPrH9KYpVWYIxcQ"><strong>程序员如何选择未来的职业路线</strong></a></p><p><a href="http://mp.weixin.qq.com/s/8jMnBGEoHegQ-rMIj1C2kA"><strong>【转】程序员该如何定位？看这四大方向</strong></a></p><h3 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a>经验分享</h3><p><a href="http://mp.weixin.qq.com/s/0U3DHX60c2rYHUX01iagMw"><strong>程序员之路-学习经验总结分享</strong></a></p><p><a href="http://mp.weixin.qq.com/s/0azo-znEXajF2R54g_0q3g"><strong>如何提升你的能力？给年轻程序员的几条建议</strong></a></p><p><a href="https://mp.weixin.qq.com/s/z-BbaMOYkGU0AF8_x6EpJg"><strong>给一年左右经验想去大厂的同学们的一些建议</strong></a></p><p><a href="http://mp.weixin.qq.com/s/o4ac8J8gC60__9hFkOzvkw"><strong>Android 技术总监应该干的那些事</strong></a></p><h3 id="完整系列"><a href="#完整系列" class="headerlink" title="完整系列"></a>完整系列</h3><h4 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h4><p><a href="http://mp.weixin.qq.com/s/Lhtk02a3tVeM5Zn5Hrv6Nw"><strong>Android NDK 开发之旅 1–C 语言基础–基本数据类型</strong></a></p><p><a href="http://mp.weixin.qq.com/s/6VGYIzs32A1KmiNIGrqqQg"><strong>Android NDK 开发之旅 2–C 语言基础–指针</strong></a></p><p><a href="http://mp.weixin.qq.com/s/-GpOZQaMspA_uNvef0UwnQ"><strong>Android NDK 开发之旅 3 – C 语言基础–内存分配</strong></a></p><p><a href="http://mp.weixin.qq.com/s/ULWt4FxksS2BvPnkN2745A"><strong>Android NDK 开发之旅 4–C 语言基础–字符串</strong></a></p><p><a href="http://mp.weixin.qq.com/s/JHA3dZd6YprJtWhRYMLsFA"><strong>Android NDK 开发之旅 5–C 语言基础–结构体</strong></a></p><p><a href="http://mp.weixin.qq.com/s/_OyWzA1iCRiw2zTamQlOjw"><strong>Android NDK 开发之旅 6–C 语言基础–联合体与枚举</strong></a></p><p><a href="http://mp.weixin.qq.com/s/uOZ5TGaaGVWgs8lvLn9F-g"><strong>Android NDK 开发之旅 7–C 语言基础–IO</strong></a></p><p><a href="http://mp.weixin.qq.com/s/xlmo7xypqvDLVoM5H8_Uhg"><strong>Android NDK 开发之旅 8–C 语言基础–预编译</strong></a></p><p><a href="http://mp.weixin.qq.com/s/LhhLa2x_vG6qRtNb3mek_w"><strong>Android NDK 开发之旅 9–JNI–JNI 开发流程</strong></a></p><p><a href="http://mp.weixin.qq.com/s/-lhGXHhPIpQ9G1Bo7-5rmw"><strong>Android NDK 开发之旅 10—14</strong></a></p><h4 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h4><p><a href="http://mp.weixin.qq.com/s/Az0RzhKCPA0YQUym7RyIcQ"><strong>给初学者的 RxJava2.0 教程</strong></a></p><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p><a href="http://mp.weixin.qq.com/s/XpJMsamUYz0YpKjXIcbR3A"><strong>开发中的设计模式总结</strong></a></p><h3 id="项目中的技术"><a href="#项目中的技术" class="headerlink" title="项目中的技术"></a>项目中的技术</h3><p><a href="https://mp.weixin.qq.com/s/D_zp1036eufuYCjPpR4FDw"><strong>Android Kotlin&amp;BLE(低功耗蓝牙) 笔记</strong></a></p><p><a href="http://mp.weixin.qq.com/s/JTvj6srNjvy4Ex-_ZfVY9Q"><strong>Kotlin Primer·第六章·集合泛型与操作符</strong></a></p><p><a href="http://mp.weixin.qq.com/s/NXiLi3nGa2sCAUtzzHjurQ"><strong>优雅地刷新 RecyclerView</strong></a></p><p><a href="http://mp.weixin.qq.com/s/_9D38SOYReTCHzYnpd0tVg"><strong>App 竞品技术分析（系列）</strong></a></p><p><a href="https://mp.weixin.qq.com/s/QNk4UrTfPc9CkiF3b3fdQA"><strong>Glide 加载图片实现进度条效果</strong></a></p><p><a href="http://mp.weixin.qq.com/s/A9uVEyXEZJ-z7wOSTS5_0Q"><strong>Android 模块化探索与实践</strong></a></p><p><a href="http://mp.weixin.qq.com/s/j-uSXSVh8bLLuiBH6dk1sA"><strong>Android 让你的布局飞起来</strong></a></p><p><a href="http://mp.weixin.qq.com/s/6CbpduZKUCgHiy0pp1cahA"><strong>项目需求讨论-RecycleView 分页加载实现分析</strong></a></p><p><a href="http://mp.weixin.qq.com/s/u0e0OlJuhiJz3ca_fTJgzQ"><strong>Android 搜索结果显示高亮(有数据滑动底部自动刷新)</strong></a></p><p><a href="http://mp.weixin.qq.com/s/t53INi1kEZggXwLGCioqqA"><strong>Android 通用的下拉刷新，重温事件传递</strong></a></p><p><a href="https://mp.weixin.qq.com/s/W8wRz_qtTTldslVpzgcu0A"><strong>Android 检查版本升级应该怎么做？</strong></a></p><p><a href="http://mp.weixin.qq.com/s/WcG_LKwPy-qQ-NaY1JyUKg"><strong>Android 夜间模式换肤</strong></a></p><p><a href="http://mp.weixin.qq.com/s/0nfnbCZMM5bKpaG3169CBw"><strong>Android 选择图片上传功能【支持多选拍照预览等】</strong></a></p><p><a href="http://mp.weixin.qq.com/s/oz0d5mOfqhgkCe6fjVmvMw"><strong>聊聊安卓 App 里的搜索</strong></a></p><p><a href="http://mp.weixin.qq.com/s/Oivap3YCeT5IXsVpl7n-lQ"><strong>分享一种 RecyclerView 滑动到底部自动加载的实现方案</strong></a></p><p><a href="http://mp.weixin.qq.com/s/DMksgHOuGWhztESGfDgucA"><strong>Android 中使用 RecyclerView + SnapHelper 实现类似 ViewPager 效果</strong></a></p><p><a href="http://mp.weixin.qq.com/s/TYBDXB-cYwkn8fQGSNTu3g"><strong>加快 apk 的构建速度，如何把编译时间从 130 秒降到 17 秒</strong></a></p><p><a href="http://mp.weixin.qq.com/s/2PoLfcnDYmVRSuhImHJDRQ"><strong>Android 优化 APP 构建速度的 17 条建议</strong></a></p><p><a href="http://mp.weixin.qq.com/s/EEuhjTWkLNrUBnS_WIISmw"><strong>Android应用瘦身，从18MB到12.5MB</strong></a></p><p><a href="http://mp.weixin.qq.com/s/kFPDThFZo7ZGOBLUv22myQ"><strong>细细品读！深入浅出，官方文档看ConstraintLayout</strong></a></p><p><a href="http://mp.weixin.qq.com/s/tRCtm6xf48ujVyjrK71BeA"><strong>安卓中如何给按钮添加点击音效</strong></a></p><p><a href="http://mp.weixin.qq.com/s/2IIx-KMET2hN5wVi1X86pA"><strong>知乎和简书的夜间模式实现套路</strong></a></p><p><a href="http://mp.weixin.qq.com/s/IO-nDY_gMBpSRAOqFPKwCg"><strong>学会这两招，再敲代码，才给力</strong></a></p><p><a href="http://mp.weixin.qq.com/s/RfFIxjHvjodCiihaUpeorw"><strong>使用 Scalpel 3D展示界面布局</strong></a></p><p><a href="http://mp.weixin.qq.com/s/pJlXVmlPrfcvOPBqqaFvXA"><strong>Android 时间轴的实现（RecyclerView更简单）</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js 基础知识</title>
    <link href="/2017-07-16-js-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2017-07-16-js-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h2><p>参考：<a href="http://javascript.ruanyifeng.com/stdlib/arraybuffer.html">二进制数组</a></p><p>ArrayBuffer对象、TypedArray对象、DataView对象是JavaScript操作二进制数据的一个接口。这些对象早就存在，属于独立的规格，ES6将它们纳入了ECMAScript规格，并且增加了新的方法。</p><p>这些对象原始的设计目的，与WebGL项目有关。所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个32位整数，两端的JavaScript脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像C语言那样，直接操作字节，将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。</p><p>二进制数组就是在这种背景下诞生的。它很像C语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了JavaScript处理二进制数据的能力，使得开发者有可能通过JavaScript与操作系统的原生接口进行二进制通信。</p><p>二进制数组由三个对象组成。</p><ol><li><p>ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。</p></li><li><p>TypedArray对象：用来生成内存的视图，通过9个构造函数，可以生成9种数据格式的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图, Float32Array（32位浮点数）数组视图等等。</p></li><li><p>DataView对象：用来生成内存的视图，可以自定义格式和字节序，比如第一个字节是Uint8（无符号8位整数）、第二个字节是Int16（16位整数）、第三个字节是Float32（32位浮点数）等等。</p></li></ol><p>简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray对象代表确定类型的二进制数据，DataView对象代表不确定类型的二进制数据。它们支持的数据类型一共有9种（DataView对象支持除Uint8C以外的其他8种）。</p>]]></content>
    
    
    <categories>
      
      <category>FrontEnd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket 学习笔记</title>
    <link href="/2017-07-16-WebSocket-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2017-07-16-WebSocket-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>WebSocket一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并被RFC7936所补充规范。WebSocket API也被W3C定为标准。<br>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在，很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。<br>而比较新的技术去做轮询的效果是Comet。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源。<br>在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。<br>Websocket使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的Websocket。如：</p><pre><code class="hljs">ws://example.com/wsapiwss://secure.example.com/</code></pre><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><p><img src="https://blogres.blackist.org/202002011055_172.png"></p><p>其他特点包括：</p><ol><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li></ol><h2 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h2><p>WebSocket 是独立的、创建在 TCP 上的协议。<br>Websocket 通过 HTTP&#x2F;1.1 协议的101状态码进行握手。<br>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。</p><h2 id="Property-and-Method"><a href="#Property-and-Method" class="headerlink" title="Property and Method"></a>Property and Method</h2><p>WebSocket 对象提供了一组用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。</p><p>WebSocket构造器方法接受一个必须的参数和一个可选的参数：</p><pre><code class="hljs">WebSocket WebSocket(in DOMString url, in optional DOMString protocols);WebSocket WebSocket(in DOMString url,in optional DOMString[] protocols);</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>url<br>表示要连接的URL。这个URL应该为响应WebSocket的地址。<br>protocols 可选<br>可以是一个单个的协议名字字符串或者包含多个协议名字字符串的数组。这些字符串用来表示子协议，这样做可以让一个服务器实现多种WebSocket子协议（例如你可能希望通过制定不同的协议来处理不同类型的交互）。如果没有制定这个参数，它会默认设为一个空字符串。<br>构造器方法可能抛出以下异常：</p><p>SECURITY_ERR<br>试图连接的端口被屏蔽。<br>方法概述<br>void close(in optional unsigned long code, in optional DOMString reason);<br>void send(in DOMString data);</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>binaryType [DOMString]一个字符串表示被传输二进制的内容的类型。取值应当是”blob”或者”arraybuffer”。”blob”表示使用DOMBlob 对象，而”arraybuffer”表示使用 ArrayBuffer 对象。</p></li><li><p>bufferedAmount[unsigned long]调用 send() 方法将多字节数据加入到队列中等待传输，但是还未发出。该值会在所有队列数据被发送后重置为 0。而当连接关闭时不会设为0。如果持续调用send()，这个值会持续增长。只读。</p></li><li><p>extensions[DOMString]服务器选定的扩展。目前这个属性只是一个空字符串，或者是一个包含所有扩展的列表。<br>oncloseEventListener用于监听连接关闭事件监听器。当 WebSocket 对象的readyState 状态变为 CLOSED 时会触发该事件。这个监听器会接收一个叫close的 CloseEvent 对象。</p></li><li><p>onerror[EventListener]当错误发生时用于监听error事件的事件监听器。会接受一个名为“error”的event对象。</p></li><li><p>onmessage[EventListener]一个用于消息事件的事件监听器，这一事件当有消息到达的时候该事件会触发。这个Listener会被传入一个名为”message”的 MessageEvent 对象。</p></li><li><p>onopen[EventListener]一个用于连接打开事件的事件监听器。当readyState的值变为 OPEN 的时候会触发该事件。该事件表明这个连接已经准备好接受和发送数据。这个监听器会接受一个名为”open”的事件对象。</p></li><li><p>protocol[DOMString]一个表明服务器选定的子协议名字的字符串。这个属性的取值会被取值为构造器传入的protocols参数。</p></li><li><p>readyState[unsigned short]连接的当前状态。取值是 Ready state constants之一。 只读。</p></li><li><p>url[DOMString]传入构造器的URL。它必须是一个绝对地址的URL。只读。</p></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>Ready state 常量：用来描述 WebSocket 连接的状态。</p><ul><li>CONNECTING0连接还没开启。</li><li>OPEN1连接已开启并准备好进行通信。</li><li>CLOSING2连接正在关闭的过程中。</li><li>CLOSED3连接已经关闭，或者连接无法建立。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><p>关闭WebSocket连接或停止正在进行的连接请求。如果连接的状态已经是closed，这个方法不会有任何效果</p><p>void close(in optional unsigned short code, in optional DOMString reason);<br>参数</p><p>code 可选<br>一个数字值表示关闭连接的状态号，表示连接被关闭的原因。如果这个参数没有被指定，默认的取值是1000 （表示正常连接关闭）。 请看CloseEvent页面的 list of status codes来看默认的取值。<br>reason 可选<br>一个可读的字符串，表示连接被关闭的原因。这个字符串必须是不长于123字节的UTF-8 文本（不是字符）。<br>可能抛出的异常</p><p>INVALID_ACCESS_ERR<br>选定了无效的code。<br>SYNTAX_ERR<br>reason 字符串太长或者含有unpaired surrogates。<br>注意： 在Gecko中，Gecko 8.0 (Firefox 8.0 &#x2F; Thunderbird 8.0 &#x2F; SeaMonkey 2.5)之间的版本的实现不支持任何参数。</p><h4 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h4><p>通过WebSocket连接向服务器发送数据。</p><p>void send(in DOMString data);<br>void send(in ArrayBuffer data);<br>void send(in Blob data);<br>参数</p><p>data<br>要发送到服务器的数据。<br>可能抛出的异常</p><p>INVALID_STATE_ERR<br>当前连接的状态不是OPEN。<br>SYNTAX_ERR<br>数据是一个包含unpaired surrogates的字符串。<br>注意: Gecko 6.0实现的send()方法与规范的要求有一些不同。Gecko会返回一个 boolean表示连接是否依然处于开启状态 （并且这个数据被成功放入的发送队列或者被发送）。在 Gecko 8.0中这个问题被修正了。</p><h2 id="学习连接"><a href="#学习连接" class="headerlink" title="学习连接"></a>学习连接</h2><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 阮一峰的网络日志</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-WebSocket/index.html">WebSocket实战</a>（useful）</p><p><a href="http://colobu.com/2015/02/27/WebSockets-tutorial-on-Wildfly-8/">WebSocket 实例注解开发</a>(useful)</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebSocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
